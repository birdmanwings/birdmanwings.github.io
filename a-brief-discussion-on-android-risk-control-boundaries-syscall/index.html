<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="风控的本质是剔除坏人，保留好人。  在上文中我们讨论了 Android 风控中的 Java 层的边界对抗，但是在实际应用中更为核心的对抗还是在 native 层，而在 native 层如果我们直接调用 libc 库的函数去进行环境检测信息提取，是非常容易被 Hook 拦截，比较常见的就是使用 syscall 直接进行系统调用，本文主要就围绕 syscall 的边界攻防以及原理进行展开分析。 SY">
<meta property="og:type" content="article">
<meta property="og:title" content="深入Android风控边界-syscall">
<meta property="og:url" content="http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/index.html">
<meta property="og:site_name" content="BDWMS">
<meta property="og:description" content="风控的本质是剔除坏人，保留好人。  在上文中我们讨论了 Android 风控中的 Java 层的边界对抗，但是在实际应用中更为核心的对抗还是在 native 层，而在 native 层如果我们直接调用 libc 库的函数去进行环境检测信息提取，是非常容易被 Hook 拦截，比较常见的就是使用 syscall 直接进行系统调用，本文主要就围绕 syscall 的边界攻防以及原理进行展开分析。 SY">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://image.bdwms.com/image-20231012140125400.png">
<meta property="og:image" content="https://image.bdwms.com/image-20231012115404308.png">
<meta property="article:published_time" content="2023-10-07T11:48:11.000Z">
<meta property="article:modified_time" content="2025-05-10T00:44:42.995Z">
<meta property="article:author" content="bdwms">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.bdwms.com/image-20231012140125400.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>深入Android风控边界-syscall</title>
    <!-- async scripts -->
    <!-- Google Analytics -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-188330730-1"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-188330730-1');
  </script>


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 5.4.2"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/categories/">Category</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/smart-contract-security-ethernaut-part-three/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/a-brief-discussion-on-android-risk-control-boundaries-binder/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&text=深入Android风控边界-syscall"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&title=深入Android风控边界-syscall"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&is_video=false&description=深入Android风控边界-syscall"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=深入Android风控边界-syscall&body=Check out this article: http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&title=深入Android风控边界-syscall"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&title=深入Android风控边界-syscall"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&title=深入Android风控边界-syscall"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&title=深入Android风控边界-syscall"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&name=深入Android风控边界-syscall&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&t=深入Android风控边界-syscall"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SYSCALL-%E8%B0%83%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">SYSCALL 调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ptrace-%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">Ptrace 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Seccomp-BRF-%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">Seccomp-BRF 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Seccomp"><span class="toc-number">3.1.</span> <span class="toc-text">Seccomp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BRF"><span class="toc-number">3.2.</span> <span class="toc-text">BRF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SVC-%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.</span> <span class="toc-text">SVC 调用拦截实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proot-%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">Proot 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#main"><span class="toc-number">5.1.</span> <span class="toc-text">main</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">子进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">父进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E6%80%9D%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">总结思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">7.</span> <span class="toc-text">参考链接</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        深入Android风控边界-syscall
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">bdwms</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-10-07T11:48:11.000Z" class="dt-published" itemprop="datePublished">2023-10-07</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Android/">Android</a>
    </div>


      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <blockquote>
<p>风控的本质是剔除坏人，保留好人。</p>
</blockquote>
<p>在上文中我们讨论了 Android 风控中的 Java 层的边界对抗，但是在实际应用中更为核心的对抗还是在 native 层，而在 native 层如果我们直接调用 libc 库的函数去进行环境检测信息提取，是非常容易被 Hook 拦截，比较常见的就是使用 syscall 直接进行系统调用，本文主要就围绕 syscall 的边界攻防以及原理进行展开分析。</p>
<h2 id="SYSCALL-调用"><a href="#SYSCALL-调用" class="headerlink" title="SYSCALL 调用"></a>SYSCALL 调用</h2><p>上篇文章中我们提到了用户态与内核台，为了让用户态的程序能够访问受限的硬件设备等，需要在用户空间中发起请求，由内核空间负责执行，这也是为了保证内核的稳定和安全性，syscall 就是连接用户空间和内核空间的桥梁。Linux系统，用户空间通过向内核空间发出Syscall，产生软中断，从而让程序陷入内核态，执行相应的操作。对于 Android 里面的 syscall 调用，可以直接参考 bionic 中的代码：</p>
<p>arm64-v8a：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* Move syscall No. from x0 to x8 */</span><br><span class="line">mov     x8, x0</span><br><span class="line">/* Move syscall parameters from x1 thru x6 to x0 thru x5 */</span><br><span class="line">mov     x0, x1</span><br><span class="line">mov     x1, x2</span><br><span class="line">mov     x2, x3</span><br><span class="line">mov     x3, x4</span><br><span class="line">mov     x4, x5</span><br><span class="line">mov     x5, x6</span><br><span class="line">svc     #0</span><br><span class="line"></span><br><span class="line">/* check if syscall returned successfully */</span><br><span class="line">cmn     x0, #(MAX_ERRNO + 1)</span><br><span class="line">cneg    x0, x0, hi</span><br><span class="line">b.hi    __set_errno_internal</span><br><span class="line"></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>armeabi-v7a：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mov     ip, sp</span><br><span class="line">stmfd   sp!, &#123;r4, r5, r6, r7&#125;</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_rel_offset r4, 0</span><br><span class="line">.cfi_rel_offset r5, 4</span><br><span class="line">.cfi_rel_offset r6, 8</span><br><span class="line">.cfi_rel_offset r7, 12</span><br><span class="line">mov     r7, r0</span><br><span class="line">mov     r0, r1</span><br><span class="line">mov     r1, r2</span><br><span class="line">mov     r2, r3</span><br><span class="line">ldmfd   ip, &#123;r3, r4, r5, r6&#125;</span><br><span class="line">swi     #0</span><br><span class="line">ldmfd   sp!, &#123;r4, r5, r6, r7&#125;</span><br><span class="line">.cfi_def_cfa_offset 0</span><br><span class="line">cmn     r0, #(MAX_ERRNO + 1)</span><br><span class="line">bxls    lr</span><br><span class="line">neg     r0, r0</span><br><span class="line">b       __set_errno_internal</span><br></pre></td></tr></table></figure>

<p>以上我们就可以传入系统调用号，其他参数来通过汇编进行系统调用了，攻击者对于库函数的 Hook 拦截例如 inlinehook 就没用了。</p>
<h2 id="Ptrace-原理"><a href="#Ptrace-原理" class="headerlink" title="Ptrace 原理"></a>Ptrace 原理</h2><p>svc 是进入内核态的最后一道门槛，那么是否能够对直接的系统调用进行拦截呢。ptrace 就是由 linux 系统提供的强大调试工具，gdb 等工具就是依靠 ptrace 进行实现的。ptrace 能够在非 Root 模式下直接调试自己本进程，可以注入暂停进程，修改寄存器等，同时 ptrace 也可以调试内核态。这里我们简单看了解下 ptrace：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">kill</span>(<span class="built_in">getpid</span>(), SIGSTOP);  <span class="comment">// Stop until the parent is ready to continue</span></span><br><span class="line">        <span class="built_in">child</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="built_in">waitpid</span>(child_pid, &amp;status, <span class="number">0</span>);  <span class="comment">// Wait for child to stop</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_SETOPTIONS, child_pid, <span class="number">0</span>, PTRACE_O_TRACESECCOMP | PTRACE_O_TRACESYSGOOD) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_SYSCALL, child_pid, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// Continue the child</span></span><br><span class="line">        <span class="built_in">parent</span>(child_pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父进程 fork() 出子进程后，子进程通过 <code>ptrace(PTRACE_TRACEME, 0, 0, 0)</code> 告诉父进程自己可以被调试，并停止运行，直到父进程发送调试命令才会继续执行。父进程可以继续操作设置，并通过 <code>ptrace(PTRACE_SYSCALL, child_pid, 0, 0)</code> 来继续子进程。</p>
<p>这里简单说明下 PTRACE_SYSCALL 和 PTRACE_CONT 的区别，两者都是恢复暂停的被调试进程，PTRACE_SYSCALL 可以理解为单步执行，当遇到下一个 svc 的 syscall_enter 和 syscall_exit 时还是会暂停，而 PTRACE_CONT 则会继续执行。</p>
<h2 id="Seccomp-BRF-原理"><a href="#Seccomp-BRF-原理" class="headerlink" title="Seccomp-BRF 原理"></a>Seccomp-BRF 原理</h2><p>在上文中其实我们就可以通过 ptrace 利用 PTRACE_SYSCALL 来进行单步调试，并在进入和退出阶段来修改寄存器中的内容，从而来完成对函数调用的参数与返回值的修改。但是有一个很严重的问题就是每一个 syscall 都进行拦截的话，就会产生大量的暂停与进程间通信，造成程序的卡顿。那么有没有一种方法能够解决这个问题呢？当然是有的，接下来我们来介绍下 seccomp 和 BRF。</p>
<h3 id="Seccomp"><a href="#Seccomp" class="headerlink" title="Seccomp"></a>Seccomp</h3><p>seccomp（全称secure computing mode）是 linux kernel支持的一种安全机制。在 linux 系统里，大量的系统调用直接暴露给用户态程序。但是并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。通过 seccomp，我们限制程序使用某些系统调用，这样可以减少系统的暴露面，同时是程序进入一种“安全”的状态，这也就是沙箱的雏形。</p>
<p>seccomp 分为两种模式，在 strict 模式下仅支持，其他系统调用就会直接 SIGKILL 退出。：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read，write，_exit，sigreturn</span><br></pre></td></tr></table></figure>

<p>Linux 3.5 之后引入了第二个模式：SECCOMP_MODE_FILTER，支持 BRF 过滤模式下自定义规则，在该模式下允许指定哪些系统调用可以，seccomp-brf 基于 Berkeley 的数据包进行规则匹配，从而完成过滤。</p>
<h3 id="BRF"><a href="#BRF" class="headerlink" title="BRF"></a>BRF</h3><p>BPF在1992年的tcpdump程序中首次提出，tcpdump是一个网络数据包的监控工具， 但是由于数据包的数量很大，而且将内核空间捕获到的数据包传输到用户空间会带来很多不必要的性能损耗，所以要对数据包进行过滤，只保留感兴趣的那一部分，而在内核中过滤感兴趣的数据包比在用户空间中进行过滤更有效。BPF 就是提供了一种进行内核过滤的方法，因此用户空间只需要处理经过内核过滤的后感兴趣的数据包。</p>
<p>BPF定义了一个可以在内核内实现的虚拟机(VM)。该虚拟机有以下特性：</p>
<ul>
<li>简单指令集<ul>
<li>小型指令集</li>
<li>所有的指令大小相同</li>
<li>实现过程简单、快速</li>
</ul>
</li>
<li>只有分支向前指令<ul>
<li>程序是有向无环图(DAGs)，没有循环</li>
</ul>
</li>
<li>易于验证程序的有效性&#x2F;安全性<ul>
<li>简单的指令集⇒可以验证操作码和参数</li>
<li>可以检测死代码</li>
<li>程序必须以 Return 结束</li>
<li>BPF过滤器程序仅限于4096条指令</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct sock_filter filter[] = &#123;</span><br><span class="line">    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, nr)),</span><br><span class="line">    BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, __NR_write, 0, 1),</span><br><span class="line">    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_TRACE),</span><br><span class="line">    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">&#125;;</span><br><span class="line">struct sock_fprog prog = &#123;</span><br><span class="line">    .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])), /* BPF指令的数量 */</span><br><span class="line">    .filter = filter, /*指向BPF数组的指针 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看下这个 BRF 规则的具体含义：</p>
<p>这段 BPF（Berkeley Packet Filter）代码定义了一个 seccomp 过滤器，它用于决定如何处理系统调用。这个特定的过滤器是为了处理 <code>write</code> 系统调用。下面是每行代码的解释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr))</span><br></pre></td></tr></table></figure>
<p>这条指令加载系统调用号到 BPF 的寄存器。<code>BPF_LD</code> 是加载指令，<code>BPF_W</code> 表示我们正在加载一个字（word，即32位），<code>BPF_ABS</code> 表示我们正在做一个绝对加载，<code>offsetof(struct seccomp_data, nr)</code> 获取 <code>seccomp_data</code> 结构中 <code>nr</code> 字段的偏移量，这个字段包含了系统调用号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, __NR_write, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这条指令检查加载的系统调用号是否是 <code>write</code> 系统调用的调用号（<code>__NR_write</code>）。<code>BPF_JMP</code> 是跳转指令，<code>BPF_JEQ</code> 是等于比较，<code>BPF_K</code> 表示我们正在比较一个常数。如果系统调用号是 <code>write</code>，则跳过下一条指令（即 <code>BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_TRACE)</code>），直接执行 <code>BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)</code>，否则，执行下一条指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_TRACE)</span><br></pre></td></tr></table></figure>
<p>如果执行到这条指令，说明系统调用号不是 <code>write</code>。这条指令告诉 seccomp 将这个系统调用事件发送给 ptrace，以便我们的代码可以处理它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)</span><br></pre></td></tr></table></figure>
<p>如果执行到这条指令，说明系统调用号是 <code>write</code>。这条指令告诉 seccomp 允许这个系统调用继续执行，不要将它发送给 ptrace。</p>
<p>通过这种方式，这个过滤器只允许 <code>write</code> 系统调用直接执行，而所有其他系统调用都会被发送到 ptrace，以便我们的代码可以处理它们。</p>
<h2 id="SVC-调用拦截实践"><a href="#SVC-调用拦截实践" class="headerlink" title="SVC 调用拦截实践"></a>SVC 调用拦截实践</h2><p>这里我们简单写一个例子来尝试拦截 syscall，具体项目参考 <a target="_blank" rel="noopener" href="https://github.com/birdmanwings/seccomp-test%EF%BC%9A">https://github.com/birdmanwings/seccomp-test：</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;elf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span>  <span class="comment">// for struct iovec</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall_arm64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_filter</span> filter[] = &#123;</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_LD + BPF_W + BPF_ABS, <span class="built_in">offsetof</span>(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        <span class="built_in">BPF_JUMP</span>(BPF_JMP + BPF_JEQ + BPF_K, __NR_write, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET + BPF_K, SECCOMP_RET_TRACE),</span><br><span class="line">        <span class="built_in">BPF_STMT</span>(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_fprog</span> prog = &#123;</span><br><span class="line">        .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="built_in">sizeof</span>(filter)/<span class="built_in">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prctl</span>(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;prctl(NO_NEW_PRIVS)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prctl</span>(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog)) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;prctl(SECCOMP)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, <span class="string">&quot;Hello, World!\n&quot;</span>, <span class="number">13</span>);  <span class="comment">// This will be intercepted</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parent</span><span class="params">(<span class="type">pid_t</span> child_pid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">user_pt_regs</span> regs;</span><br><span class="line">    <span class="type">int</span> entryexit = <span class="number">0</span>;  <span class="comment">// 用于跟踪系统调用的入口和退出点</span></span><br><span class="line"></span><br><span class="line">    iov.iov_base = &amp;regs;</span><br><span class="line">    iov.iov_len = <span class="built_in">sizeof</span>(regs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">waitpid</span>(child_pid, &amp;status, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status) || <span class="built_in">WIFSIGNALED</span>(status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(status)) &#123;</span><br><span class="line">            <span class="comment">// 当停止是由于系统调用引起时</span></span><br><span class="line">            <span class="keyword">if</span> (status &gt;&gt; <span class="number">8</span> == (SIGTRAP | <span class="number">0x80</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_GETREGSET, child_pid, NT_PRSTATUS, &amp;iov) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 通过 entryexit 变量区分系统调用的入口和退出点</span></span><br><span class="line">                <span class="keyword">if</span> (entryexit == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;System Call Entry: Number %llu\n&quot;</span>, regs.regs[<span class="number">8</span>]);</span><br><span class="line">                    entryexit = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;System Call Exit: Number %llu\n&quot;</span>, regs.regs[<span class="number">8</span>]);</span><br><span class="line">                    entryexit = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Check if the stop was caused by a seccomp event</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((status &gt;&gt; <span class="number">8</span>) == (SIGTRAP | (PTRACE_EVENT_SECCOMP &lt;&lt; <span class="number">8</span>))) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Parent: PTRACE_EVENT_SECCOMP event received.\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_SYSCALL, child_pid, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">kill</span>(<span class="built_in">getpid</span>(), SIGSTOP);  <span class="comment">// Stop until the parent is ready to continue</span></span><br><span class="line">        <span class="built_in">child</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="built_in">waitpid</span>(child_pid, &amp;status, <span class="number">0</span>);  <span class="comment">// Wait for child to stop</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ptrace</span>(PTRACE_SETOPTIONS, child_pid, <span class="number">0</span>, PTRACE_O_TRACESECCOMP | PTRACE_O_TRACESYSGOOD) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_SYSCALL, child_pid, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// Continue the child</span></span><br><span class="line">        <span class="built_in">parent</span>(child_pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>main 中父进程 fork 出子进程。</li>
<li>父进程 waitpid(child_pid, &amp;status, 0); 等待子进程暂停。</li>
<li>子进程设置自己为 PTRACE_TRACEME，然后 kill(getpid(), SIGSTOP); 暂停自己。</li>
<li>父进程收到子进程暂停的信号，开始设置 PTRACE_SETOPTIONS，PTRACE_O_TRACESECCOMP 用于设置 seccomp，PTRACE_O_TRACESYSGOOD 用于设置区分系统调用。</li>
<li>父进程 ptrace(PTRACE_SYSCALL, child_pid, 0, 0); 继续子进程。</li>
<li>子进程中就是设置 BRF 规则并开启对 write 系统调用的过滤，然后调用 write 函数。</li>
<li>父进程就是一个循环 wait 子进程的信号，监控的就是 seccomp 信号和系统调用信号，这里笔者维护了一个 entryexit 变量来观察系统调用与 seccomp 触发的顺序。</li>
</ol>
<p>这里补充一个知识点，在系统调用时存在两个阶段 syscall-entry-stop 和 syscall-exit-stop，而触发 seccomp 规则发出的 PTRACE_EVENT_SECCOMP 信号在 Linux kernel 版本 4.8 起 PTRACE_EVENT_SECCOMP 是在 syscall-entry-stop 和 syscall-exit-stop 之间，在 Linux 3.5 到 Linux 4.7 之间 PTRACE_EVENT_SECCOMP 是在 syscall-entry-stop 之前的，具体可以翻看 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/ptrace.2.html">ptrace 手册</a>。</p>
<p><img src="https://image.bdwms.com/image-20231012140125400.png" alt="image-20231012140125400"></p>
<p>然后编译执行并推送到 Android 手机中，首先可以看下笔者的这部小米测试机版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/version</span></span><br><span class="line">Linux version 4.19.157-perf-gf8cdf943b2b3 (builder@pangu-build-component-vendor-96687-7t4pv-tshlp-g02mt) (clang version 10.0.7 for Android NDK, GNU ld (binutils-2.27-bd24d23f) 2.27.0.20170315) #1 SMP PREEMPT Wed Jun 7 08:25:17 UTC 2023</span><br></pre></td></tr></table></figure>

<p>linux 版本是 4.19，然后再看执行结果：</p>
<p><img src="https://image.bdwms.com/image-20231012115404308.png" alt="image-20231012115404308"></p>
<p>可以看到 write 的系统调用号 64，首先是 syscall enter 阶段收到的 SIGTRAP | 0x80  然后是 PTRACE_EVENT_SECCOMP，最后是 syscall exit 阶段的 SIGTRAP | 0x80。</p>
<h2 id="Proot-原理"><a href="#Proot-原理" class="headerlink" title="Proot 原理"></a>Proot 原理</h2><p>基于以上的理论，我们就可以对与 syscall 的调用进行拦截，ptrace 就可以在不同的时机对寄存器进行修改，从而达到对参数与返回值修改的目的，但是其中还是有很多的细节，比较幸运的是我们可以参考一个比较成熟的项目 <a target="_blank" rel="noopener" href="https://github.com/proot-me/proot">proot</a>。PRoot 是 <code>chroot</code>、<code>mount --bind</code> 和 <code>binfmt_misc</code> 的用户态实现。用户不需要拥有系统特权就可以在任意目录建立一个新的根文件系统。从而在建立的根文件系统内做任何事情。也可以借助QEMU user-mode甚至能够运行其他CPU构架的程序。</p>
<p>Proot 的核心原理就是利用 ptrace 机制去实现的，我们下面就来分析下整个 Proot 的核心流程：</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>先看 cli.c 中的 main 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tracee *tracee;</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Configure the memory allocator.  */</span></span><br><span class="line">	<span class="built_in">talloc_enable_leak_report</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(TALLOC_VERSION_MAJOR) &amp;&amp; TALLOC_VERSION_MAJOR &gt;= 2</span></span><br><span class="line">	<span class="built_in">talloc_set_log_stderr</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Pre-create the first tracee (pid == 0).  */</span></span><br><span class="line">	tracee = <span class="built_in">get_tracee</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (tracee == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	tracee-&gt;pid = <span class="built_in">getpid</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Pre-configure the first tracee.  */</span></span><br><span class="line">	status = <span class="built_in">parse_config</span>(tracee, argc, argv);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Start the first tracee.  */</span></span><br><span class="line">	status = <span class="built_in">launch_process</span>(tracee, &amp;argv[status]);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">print_execve_help</span>(tracee, tracee-&gt;exe, status);</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Start tracing the first tracee and all its children.  */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="built_in">event_loop</span>());</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	<span class="built_in">TALLOC_FREE</span>(tracee);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (exit_failure) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fatal error: see `%s --help`.\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父进程创建第一个 tracee 并在 launch_process 中绑定，同时之后的子进程都会与一个 tracee 绑定并挂在第一个 tracee 下来进行管理，tracee 作为管理进程的结构体，这里可以简单看下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Information related to a tracee process. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tracee</span> &#123;</span><br><span class="line">	<span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * Private resources                                                  *</span></span><br><span class="line"><span class="comment">	 **********************************************************************/</span></span><br><span class="line">	<span class="comment">/* tracee的双向链表  */</span></span><br><span class="line">	<span class="built_in">LIST_ENTRY</span>(tracee) link;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 进程pid */</span></span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 唯一的Tracee标识符 */</span></span><br><span class="line">	<span class="type">uint64_t</span> vpid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 是否正在运行  */</span></span><br><span class="line">	<span class="type">bool</span> running;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 是否准备好释放 */</span></span><br><span class="line">	<span class="type">bool</span> terminated;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 终止此跟踪是否意味着立即终止所有跟踪。 */</span></span><br><span class="line">        <span class="type">bool</span> killall_on_exit;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 父级tracee */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tracee</span> *parent;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 它是一个“克隆”吗，即具有与其创建者相同的父级。 */</span></span><br><span class="line">	<span class="type">bool</span> clone;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在沙箱中对ptrace进行仿真实现 (tracer side).  */</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="type">size_t</span> nb_ptracees;</span><br><span class="line">		<span class="built_in">LIST_HEAD</span>(zombies, tracee) zombies;</span><br><span class="line"></span><br><span class="line">		<span class="type">pid_t</span> wait_pid;</span><br><span class="line">		<span class="type">word_t</span> wait_options;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">enum</span> &#123;</span><br><span class="line">			DOESNT_WAIT = <span class="number">0</span>,</span><br><span class="line">			WAITS_IN_KERNEL,</span><br><span class="line">			WAITS_IN_PROOT</span><br><span class="line">		&#125; waits_in;</span><br><span class="line">	&#125; as_ptracer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在沙箱中对ptrace进行仿真实现 (tracee side).  */</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">tracee</span> *ptracer;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="meta">#<span class="keyword">define</span> STRUCT_EVENT struct &#123; int value; bool pending; &#125;</span></span><br><span class="line"></span><br><span class="line">			STRUCT_EVENT proot;</span><br><span class="line">			STRUCT_EVENT ptracer;</span><br><span class="line">		&#125; event4;</span><br><span class="line"></span><br><span class="line">		<span class="type">bool</span> tracing_started;</span><br><span class="line">		<span class="type">bool</span> ignore_loader_syscalls;</span><br><span class="line">		<span class="type">bool</span> ignore_syscalls;</span><br><span class="line">		<span class="type">word_t</span> options;</span><br><span class="line">		<span class="type">bool</span> is_zombie;</span><br><span class="line">	&#125; as_ptracee;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当前的状态</span></span><br><span class="line"><span class="comment">	 *        0: enter syscall</span></span><br><span class="line"><span class="comment">	 *        1: exit syscall no error </span></span><br><span class="line"><span class="comment">	 *   -errno: exit syscall with error.  */</span></span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_IN_SYSENTER(tracee) ((tracee)-&gt;status == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_IN_SYSEXIT(tracee) (!IS_IN_SYSENTER(tracee))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_IN_SYSEXIT2(tracee, sysnum) (IS_IN_SYSEXIT(tracee) \</span></span><br><span class="line"><span class="meta">				     &amp;&amp; get_sysnum((tracee), ORIGINAL) == sysnum)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如何重新启动此tracee */</span></span><br><span class="line">	PTRACE_REQUEST_TYPE restart_how;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tracee 跟踪的通用寄存器的值。  */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">user_regs_struct</span> _regs[NB_REG_VERSION];</span><br><span class="line">	<span class="type">bool</span> _regs_were_changed;</span><br><span class="line">	<span class="type">bool</span> restore_original_regs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对SIGSTOP的状态进行特殊处理。  */</span></span><br><span class="line">	<span class="keyword">enum</span> &#123;</span><br><span class="line">		SIGSTOP_IGNORED = <span class="number">0</span>,  <span class="comment">/* Ignore SIGSTOP (once the parent is known).  */</span></span><br><span class="line">		SIGSTOP_ALLOWED,      <span class="comment">/* Allow SIGSTOP (once the parent is known).   */</span></span><br><span class="line">		SIGSTOP_PENDING,      <span class="comment">/* Block SIGSTOP until the parent is unknown.  */</span></span><br><span class="line">	&#125; sigstop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 用于收集所有临时动态内存分配的上下文。  */</span></span><br><span class="line">	TALLOC_CTX *ctx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 用于收集释放此tracee后应释放的所有动态内存分配的上下文。  */</span></span><br><span class="line">	TALLOC_CTX *life_context;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Specify the type of the final component during the</span></span><br><span class="line"><span class="comment">	 * initialization of a binding.  This variable is first</span></span><br><span class="line"><span class="comment">	 * defined in bind_path() then used in build_glue().  */</span></span><br><span class="line">	<span class="type">mode_t</span> glue_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在子重新配置期间，新设置与@tracee的文件系统名称空间相对应。此外，@paths保存其$PATH环境变量，以模拟execvp（3）行为。  */</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">tracee</span> *tracee;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *paths;</span><br><span class="line">	&#125; reconf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* PRoot在实际系统调用后插入的未请求的系统调用。这是一个系统调用链*/</span></span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">chained_syscalls</span> *syscalls;</span><br><span class="line">		<span class="type">bool</span> force_final_result;</span><br><span class="line">		<span class="type">word_t</span> final_result;</span><br><span class="line">	&#125; chain;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*加载运行期间所需要的加载信息*/</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">load_info</span> *load_info;</span><br><span class="line">	<span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * Private but inherited resources                                    *</span></span><br><span class="line"><span class="comment">	 **********************************************************************/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调试信息详细级别  */</span></span><br><span class="line">	<span class="type">int</span> verbose;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这个tracee的seccomp加速状态.  */</span></span><br><span class="line">	<span class="keyword">enum</span> &#123; DISABLED = <span class="number">0</span>, DISABLING, ENABLED &#125; seccomp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 确保在seccomp下始终命中sysexit阶段。 */</span></span><br><span class="line">	<span class="type">bool</span> sysexit_pending;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * Shared or private resources, depending on the CLONE_FS/VM flags.   *</span></span><br><span class="line"><span class="comment">	 **********************************************************************/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 与文件系统名称空间相关的信息。 */</span></span><br><span class="line">	FileSystemNameSpace *fs;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 虚拟堆，使用常规内存映射进行模拟。 */</span></span><br><span class="line">	Heap *heap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * Shared resources until the tracee makes a call to execve().        *</span></span><br><span class="line"><span class="comment">	 **********************************************************************/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 执行程序的路径  */</span></span><br><span class="line">	<span class="type">char</span> *exe;</span><br><span class="line">	<span class="type">char</span> *new_exe;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * Shared or private resources, depending on the (re-)configuration   *</span></span><br><span class="line"><span class="comment">	 **********************************************************************/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Runner command-line.  */</span></span><br><span class="line">	<span class="type">char</span> **qemu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* guest rootfs和host rootfs用来映射的路径 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *glue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为此tracee启用的扩展列表。  */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">extensions</span> *extensions;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * Shared but read-only resources                                     *</span></span><br><span class="line"><span class="comment">	 **********************************************************************/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对于混合模式，guest LD_LIBRARY_PATH在“guest-&gt;host”转换期间保存，以便在“host-&gt;client”转换期间恢复（仅当主机LD_LIBRORY_PATH未更改时）。 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *host_ldso_paths;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *guest_ldso_paths;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 用于诊断目的 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *tool_name;</span><br><span class="line"></span><br><span class="line">&#125; Tracee;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><p>接下来我们先看子进程的动作，在 launch_process 中子进程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">launch_process</span><span class="params">(Tracee *tracee, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *<span class="type">const</span> default_argv[] = &#123; <span class="string">&quot;-sh&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">	<span class="type">long</span> status;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Warn about open file descriptors. They won&#x27;t be</span></span><br><span class="line"><span class="comment">	 * translated until they are closed. */</span></span><br><span class="line">	<span class="built_in">list_open_fd</span>(tracee);</span><br><span class="line"></span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">switch</span>(pid) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">		<span class="built_in">note</span>(tracee, ERROR, SYSTEM, <span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -errno;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* child */</span></span><br><span class="line">		<span class="comment">/* Declare myself as ptraceable before executing the</span></span><br><span class="line"><span class="comment">		 * requested program. */</span></span><br><span class="line">		status = <span class="built_in">ptrace</span>(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">note</span>(tracee, ERROR, SYSTEM, <span class="string">&quot;ptrace(TRACEME)&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> -errno;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Synchronize with the tracer&#x27;s event loop.  Without</span></span><br><span class="line"><span class="comment">		 * this trick the tracer only sees the &quot;return&quot; from</span></span><br><span class="line"><span class="comment">		 * the next execve(2) so PRoot wouldn&#x27;t handle the</span></span><br><span class="line"><span class="comment">		 * interpreter/runner.  I also verified that strace</span></span><br><span class="line"><span class="comment">		 * does the same thing. */</span></span><br><span class="line">		<span class="built_in">kill</span>(<span class="built_in">getpid</span>(), SIGSTOP);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Improve performance by using seccomp mode 2, unless</span></span><br><span class="line"><span class="comment">		 * this support is explicitly disabled.  */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;PROOT_NO_SECCOMP&quot;</span>) == <span class="literal">NULL</span>)</span><br><span class="line">			(<span class="type">void</span>) <span class="built_in">enable_syscall_filtering</span>(tracee);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Now process is ptraced, so the current rootfs is already the</span></span><br><span class="line"><span class="comment">		 * guest rootfs.  Note: Valgrind can&#x27;t handle execve(2) on</span></span><br><span class="line"><span class="comment">		 * &quot;foreign&quot; binaries (ENOEXEC) but can handle execvp(3) on such</span></span><br><span class="line"><span class="comment">		 * binaries.  */</span></span><br><span class="line">		<span class="built_in">execvp</span>(tracee-&gt;exe, argv[<span class="number">0</span>] != <span class="literal">NULL</span> ? argv : default_argv);</span><br><span class="line">		<span class="keyword">return</span> -errno;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">/* parent */</span></span><br><span class="line">		<span class="comment">/* We know the pid of the first tracee now.  */</span></span><br><span class="line">		tracee-&gt;pid = pid;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Never reached.  */</span></span><br><span class="line">	<span class="keyword">return</span> -ENOSYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子进程 status &#x3D; ptrace(PTRACE_TRACEME, 0, NULL, NULL); 并发送 SIGSTOP 信号 <code>kill(getpid(), SIGSTOP);</code> 来告诉父进程自己可以被调试，并且在 enable_syscall_filtering 中配置并开启 seccomp-brf </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">enable_syscall_filtering</span><span class="params">(<span class="type">const</span> Tracee *tracee)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FilteredSysnum *filtered_sysnums = <span class="literal">NULL</span>;</span><br><span class="line">	Extension *extension;</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>(tracee != <span class="literal">NULL</span> &amp;&amp; tracee-&gt;ctx != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add the sysnums required by PRoot to the list of filtered</span></span><br><span class="line"><span class="comment">	 * sysnums.  <span class="doctag">TODO:</span> only if path translation is required.  */</span></span><br><span class="line">	status = <span class="built_in">merge_filtered_sysnums</span>(tracee-&gt;ctx, &amp;filtered_sysnums, proot_sysnums);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Merge the sysnums required by the extensions to the list</span></span><br><span class="line"><span class="comment">	 * of filtered sysnums.  */</span></span><br><span class="line">	<span class="keyword">if</span> (tracee-&gt;extensions != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">LIST_FOREACH</span>(extension, tracee-&gt;extensions, link) &#123;</span><br><span class="line">			<span class="keyword">if</span> (extension-&gt;filtered_sysnums == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			status = <span class="built_in">merge_filtered_sysnums</span>(tracee-&gt;ctx, &amp;filtered_sysnums,</span><br><span class="line">							extension-&gt;filtered_sysnums);</span><br><span class="line">			<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	status = <span class="built_in">set_seccomp_filters</span>(filtered_sysnums);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 set_seccomp_filters 中为不同的架构进行不同 brf 规则的设置，注意有一些类似 <code>&#123; *PR_accept*,       FILTER_SYSEXIT &#125;,</code> 的东西 FILTER_SYSEXIT 在后面用于标记是否需要处理 syscall_exit 阶段，用于修改返回值的时机。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">status = <span class="built_in">prctl</span>(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* To output this BPF program for debug purpose:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     write(2, program.filter, program.len * sizeof(struct sock_filter));</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">status = <span class="built_in">prctl</span>(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;program);</span><br><span class="line"><span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">goto</span> end;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用<code>prctl</code>函数，使用<code>PR_SET_NO_NEW_PRIVS</code>选项，以确保在应用过滤器后，进程不能获取新的权限。</li>
<li>调用<code>prctl</code>函数，使用<code>PR_SET_SECCOMP</code>选项和<code>SECCOMP_MODE_FILTER</code>模式，应用构建的BPF程序作为seccomp过滤器。</li>
</ul>
<p>设置完成后就可以 <code>execvp(tracee-&gt;exe, argv[0] != NULL ? argv : default_argv);</code> 中执行指定的命令了。</p>
<h3 id="父进程"><a href="#父进程" class="headerlink" title="父进程"></a>父进程</h3><p>回到 main 函数中，父进程的业务逻辑主要在 event_loop 函数中，跟进：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="type">int</span> tracee_status;</span><br><span class="line">  Tracee *tracee;</span><br><span class="line">  <span class="type">int</span> signal;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is the only safe place to free tracees.  */</span></span><br><span class="line">  <span class="built_in">free_terminated_tracees</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wait for the next tracee&#x27;s stop. */</span></span><br><span class="line">  pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;tracee_status, __WALL);</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != ECHILD) &#123;</span><br><span class="line">      <span class="built_in">note</span>(<span class="literal">NULL</span>, ERROR, SYSTEM, <span class="string">&quot;waitpid()&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get information about this tracee. */</span></span><br><span class="line">  tracee = <span class="built_in">get_tracee</span>(<span class="literal">NULL</span>, pid, <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">assert</span>(tracee != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  tracee-&gt;running = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">VERBOSE</span>(tracee, <span class="number">6</span>, <span class="string">&quot;vpid %&quot;</span> PRIu64 <span class="string">&quot;: got event %x&quot;</span>,</span><br><span class="line">    tracee-&gt;vpid, tracee_status);</span><br><span class="line"></span><br><span class="line">  status = <span class="built_in">notify_extensions</span>(tracee, NEW_STATUS, tracee_status, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tracee-&gt;as_ptracee.ptracer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">bool</span> keep_stopped = <span class="built_in">handle_ptracee_event</span>(tracee, tracee_status);</span><br><span class="line">    <span class="keyword">if</span> (keep_stopped)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  signal = <span class="built_in">handle_tracee_event</span>(tracee, tracee_status);</span><br><span class="line">  (<span class="type">void</span>) <span class="built_in">restart_tracee</span>(tracee, signal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 while 的无限循环中， waitpid 等待子进程的信号，调用 handle_tracee_event 处理 tracee 中的信息，然后 restart_tracee 恢复重启子进程，这里我们忽略 proot 的 extension 拓展机制。我们继续看父进程也就是调试进程是如何处理的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">is_kernel_4_8</span>())</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">handle_tracee_event_kernel_4_8</span>(tracee, tracee_status);</span><br></pre></td></tr></table></figure>

<p>可以看到这里会针对 4.8 上下的版本进行不同的操作，也是我们上文提到 4.8 之后 syscall_enter，syscall_exit，PTRACE_EVENT_SECCOMP 顺序是不同的。先看低于 4.8 版本的处理逻辑，这里主要关注暂停信号的处理逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">WIFSTOPPED</span>(tracee_status)) &#123;</span><br><span class="line"><span class="comment">/* Don&#x27;t use WSTOPSIG() to extract the signal</span></span><br><span class="line"><span class="comment"> * since it clears the PTRACE_EVENT_* bits. */</span></span><br><span class="line">signal = (tracee_status &amp; <span class="number">0xfff00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (signal) &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">bool</span> deliver_sigtrap = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SIGTRAP: &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> default_ptrace_options = (</span><br><span class="line">    PTRACE_O_TRACESYSGOOD	|</span><br><span class="line">    PTRACE_O_TRACEFORK	|</span><br><span class="line">    PTRACE_O_TRACEVFORK	|</span><br><span class="line">    PTRACE_O_TRACEVFORKDONE	|</span><br><span class="line">    PTRACE_O_TRACEEXEC	|</span><br><span class="line">    PTRACE_O_TRACECLONE	|</span><br><span class="line">    PTRACE_O_TRACEEXIT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Distinguish some events from others and</span></span><br><span class="line"><span class="comment">   * automatically trace each new process with</span></span><br><span class="line"><span class="comment">   * the same options.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Note that only the first bare SIGTRAP is</span></span><br><span class="line"><span class="comment">   * related to the tracing loop, others SIGTRAP</span></span><br><span class="line"><span class="comment">   * carry tracing information because of</span></span><br><span class="line"><span class="comment">   * TRACE*FORK/CLONE/EXEC.  */</span></span><br><span class="line">  <span class="keyword">if</span> (deliver_sigtrap)</span><br><span class="line">    <span class="keyword">break</span>;  <span class="comment">/* Deliver this signal as-is.  */</span></span><br><span class="line"></span><br><span class="line">  deliver_sigtrap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to enable seccomp mode 2...  */</span></span><br><span class="line">  status = <span class="built_in">ptrace</span>(PTRACE_SETOPTIONS, tracee-&gt;pid, <span class="literal">NULL</span>,</span><br><span class="line">      default_ptrace_options | PTRACE_O_TRACESECCOMP);</span><br><span class="line">  <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... otherwise use default options only.  */</span></span><br><span class="line">    status = <span class="built_in">ptrace</span>(PTRACE_SETOPTIONS, tracee-&gt;pid, <span class="literal">NULL</span>,</span><br><span class="line">        default_ptrace_options);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">note</span>(tracee, ERROR, SYSTEM, <span class="string">&quot;ptrace(PTRACE_SETOPTIONS)&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fall through. */</span></span><br><span class="line"><span class="keyword">case</span> SIGTRAP | <span class="number">0x80</span>:</span><br><span class="line">  signal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This tracee got signaled then freed during the</span></span><br><span class="line"><span class="comment">     sysenter stage but the kernel reports the sysexit</span></span><br><span class="line"><span class="comment">     stage; just discard this spurious tracee/event.  */</span></span><br><span class="line">  <span class="keyword">if</span> (tracee-&gt;exe == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    tracee-&gt;restart_how = PTRACE_CONT; <span class="comment">/* SYSCALL OR CONT */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (tracee-&gt;seccomp) &#123;</span><br><span class="line">  <span class="keyword">case</span> ENABLED:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_IN_SYSENTER</span>(tracee)) &#123;</span><br><span class="line">      <span class="comment">/* sysenter: ensure the sysexit</span></span><br><span class="line"><span class="comment">       * stage will be hit under seccomp.  */</span></span><br><span class="line">      tracee-&gt;restart_how = PTRACE_SYSCALL;</span><br><span class="line">      tracee-&gt;sysexit_pending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* sysexit: the next sysenter</span></span><br><span class="line"><span class="comment">       * will be notified by seccomp.  */</span></span><br><span class="line">      tracee-&gt;restart_how = PTRACE_CONT;</span><br><span class="line">      tracee-&gt;sysexit_pending = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Fall through.  */</span></span><br><span class="line">  <span class="keyword">case</span> DISABLED:</span><br><span class="line">    <span class="built_in">translate_syscall</span>(tracee);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This syscall has disabled seccomp.  */</span></span><br><span class="line">    <span class="keyword">if</span> (tracee-&gt;seccomp == DISABLING) &#123;</span><br><span class="line">      tracee-&gt;restart_how = PTRACE_SYSCALL;</span><br><span class="line">      tracee-&gt;seccomp = DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> DISABLING:</span><br><span class="line">    <span class="comment">/* Seccomp was disabled by the</span></span><br><span class="line"><span class="comment">     * previous syscall, but its sysenter</span></span><br><span class="line"><span class="comment">     * stage was already handled.  */</span></span><br><span class="line">    tracee-&gt;seccomp = DISABLED;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_IN_SYSENTER</span>(tracee))</span><br><span class="line">      tracee-&gt;status = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SIGTRAP | PTRACE_EVENT_SECCOMP2 &lt;&lt; <span class="number">8</span>:</span><br><span class="line"><span class="keyword">case</span> SIGTRAP | PTRACE_EVENT_SECCOMP &lt;&lt; <span class="number">8</span>: &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  signal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!seccomp_detected) &#123;</span><br><span class="line">    <span class="built_in">VERBOSE</span>(tracee, <span class="number">1</span>, <span class="string">&quot;ptrace acceleration (seccomp mode 2) enabled&quot;</span>);</span><br><span class="line">    tracee-&gt;seccomp = ENABLED;</span><br><span class="line">    seccomp_detected = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Use the common ptrace flow if seccomp was</span></span><br><span class="line"><span class="comment">   * explicitely disabled for this tracee.  */</span></span><br><span class="line">  <span class="keyword">if</span> (tracee-&gt;seccomp != ENABLED)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  status = <span class="built_in">ptrace</span>(PTRACE_GETEVENTMSG, tracee-&gt;pid, <span class="literal">NULL</span>, &amp;flags);</span><br><span class="line">  <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Use the common ptrace flow when</span></span><br><span class="line"><span class="comment">   * sysexit has to be handled.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((flags &amp; FILTER_SYSEXIT) != <span class="number">0</span>) &#123;</span><br><span class="line">    tracee-&gt;restart_how = PTRACE_SYSCALL;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Otherwise, handle the sysenter</span></span><br><span class="line"><span class="comment">   * stage right now.  */</span></span><br><span class="line">  tracee-&gt;restart_how = PTRACE_CONT;</span><br><span class="line">  <span class="built_in">translate_syscall</span>(tracee);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This syscall has disabled seccomp, so move</span></span><br><span class="line"><span class="comment">   * the ptrace flow back to the common path to</span></span><br><span class="line"><span class="comment">   * ensure its sysexit will be handled.  */</span></span><br><span class="line">  <span class="keyword">if</span> (tracee-&gt;seccomp == DISABLING)</span><br><span class="line">    tracee-&gt;restart_how = PTRACE_SYSCALL;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个 case SIGTRAP:  是用来在首次收到信号时设置 PTRACE_O_TRACESECCOMP 的，在真要触发 BRF 的逻辑时，触发的顺序是：</p>
<p>PTRACE_EVENT_SECCOMP -&gt; syscall_enter_stop -&gt; 调用执行 -&gt;  syscall_exit_stop</p>
<p>所以在命中 case 是 case SIGTRAP | PTRACE_EVENT_SECCOMP2 &lt;&lt; 8: case SIGTRAP | PTRACE_EVENT_SECCOMP &lt;&lt; 8:，可以看到核心逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">status = <span class="built_in">ptrace</span>(PTRACE_GETEVENTMSG, tracee-&gt;pid, <span class="literal">NULL</span>, &amp;flags);</span><br><span class="line"><span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use the common ptrace flow when</span></span><br><span class="line"><span class="comment"> * sysexit has to be handled.  */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; FILTER_SYSEXIT) != <span class="number">0</span>) &#123;</span><br><span class="line">  tracee-&gt;restart_how = PTRACE_SYSCALL;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Otherwise, handle the sysenter</span></span><br><span class="line"><span class="comment"> * stage right now.  */</span></span><br><span class="line">tracee-&gt;restart_how = PTRACE_CONT;</span><br><span class="line"><span class="built_in">translate_syscall</span>(tracee);</span><br></pre></td></tr></table></figure>

<p>获取 flags 也就是上文说的是否有设置 FILTER_SYSEXIT ，如果没有设置说明不需要处理返回值，那么将 tracee 设置为 PTRACE_CONT 在调用 restart_tracee 时直接跳过 syscall_exit 阶段，直到命中下一个 seccomp 规则，并在 translate_syscall 中处理具体逻辑一般用于处理参数，接下来并不会命中 case SIGTRAP | 0x80；</p>
<p>第二种情况需要处理 FILTER_SYSEXIT，那么 restart_how 设置为 PTRACE_SYSCALL 直接返回重启子进程时就会单步调试，在 case SIGTRAP | 0x80 时 IS_IN_SYSENTER(tracee) 为 true 时继续设置 PTRACE_SYSCALL 然后 Fall through 到 case DISABLED: 中，首先处理 syscall_enter_stop 阶段，之后重启再次触发 0x80 的 case，IS_IN_SYSENTER 为 false，设置 restart_how 为 PTRACE_CONT，让子进程重启时继续到触发 BRF 规则为止，之后同理 Fall through 到 DISABLED 调用 translate_syscall</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (tracee-&gt;seccomp) &#123;</span><br><span class="line">			<span class="keyword">case</span> ENABLED:</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">IS_IN_SYSENTER</span>(tracee)) &#123;</span><br><span class="line">					<span class="comment">/* sysenter: ensure the sysexit</span></span><br><span class="line"><span class="comment">					 * stage will be hit under seccomp.  */</span></span><br><span class="line">					tracee-&gt;restart_how = PTRACE_SYSCALL;</span><br><span class="line">					tracee-&gt;sysexit_pending = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/* sysexit: the next sysenter</span></span><br><span class="line"><span class="comment">					 * will be notified by seccomp.  */</span></span><br><span class="line">					tracee-&gt;restart_how = PTRACE_CONT;</span><br><span class="line">					tracee-&gt;sysexit_pending = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/* Fall through.  */</span></span><br><span class="line">			<span class="keyword">case</span> DISABLED:</span><br><span class="line">				<span class="built_in">translate_syscall</span>(tracee);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* This syscall has disabled seccomp.  */</span></span><br><span class="line">				<span class="keyword">if</span> (tracee-&gt;seccomp == DISABLING) &#123;</span><br><span class="line">					tracee-&gt;restart_how = PTRACE_SYSCALL;</span><br><span class="line">					tracee-&gt;seccomp = DISABLED;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> DISABLING:</span><br><span class="line">				<span class="comment">/* Seccomp was disabled by the</span></span><br><span class="line"><span class="comment">				 * previous syscall, but its sysenter</span></span><br><span class="line"><span class="comment">				 * stage was already handled.  */</span></span><br><span class="line">				tracee-&gt;seccomp = DISABLED;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">IS_IN_SYSENTER</span>(tracee))</span><br><span class="line">					tracee-&gt;status = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>我们再看一下 4.8 以上处理的方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (signal) &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">bool</span> deliver_sigtrap = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SIGTRAP: &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> default_ptrace_options = (</span><br><span class="line">    PTRACE_O_TRACESYSGOOD	|</span><br><span class="line">    PTRACE_O_TRACEFORK	|</span><br><span class="line">    PTRACE_O_TRACEVFORK	|</span><br><span class="line">    PTRACE_O_TRACEVFORKDONE	|</span><br><span class="line">    PTRACE_O_TRACEEXEC	|</span><br><span class="line">    PTRACE_O_TRACECLONE	|</span><br><span class="line">    PTRACE_O_TRACEEXIT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Distinguish some events from others and</span></span><br><span class="line"><span class="comment">   * automatically trace each new process with</span></span><br><span class="line"><span class="comment">   * the same options.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Note that only the first bare SIGTRAP is</span></span><br><span class="line"><span class="comment">   * related to the tracing loop, others SIGTRAP</span></span><br><span class="line"><span class="comment">   * carry tracing information because of</span></span><br><span class="line"><span class="comment">   * TRACE*FORK/CLONE/EXEC.  */</span></span><br><span class="line">  <span class="keyword">if</span> (deliver_sigtrap)</span><br><span class="line">    <span class="keyword">break</span>;  <span class="comment">/* Deliver this signal as-is.  */</span></span><br><span class="line"></span><br><span class="line">  deliver_sigtrap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to enable seccomp mode 2...  */</span></span><br><span class="line">  status = <span class="built_in">ptrace</span>(PTRACE_SETOPTIONS, tracee-&gt;pid, <span class="literal">NULL</span>,</span><br><span class="line">      default_ptrace_options | PTRACE_O_TRACESECCOMP);</span><br><span class="line">  <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    seccomp_enabled = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/* ... otherwise use default options only.  */</span></span><br><span class="line">    status = <span class="built_in">ptrace</span>(PTRACE_SETOPTIONS, tracee-&gt;pid, <span class="literal">NULL</span>,</span><br><span class="line">        default_ptrace_options);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">note</span>(tracee, ERROR, SYSTEM, <span class="string">&quot;ptrace(PTRACE_SETOPTIONS)&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;PROOT_NO_SECCOMP&quot;</span>) == <span class="literal">NULL</span>)</span><br><span class="line">      seccomp_enabled = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/* Fall through. */</span></span><br><span class="line"><span class="keyword">case</span> SIGTRAP | PTRACE_EVENT_SECCOMP2 &lt;&lt; <span class="number">8</span>:</span><br><span class="line"><span class="keyword">case</span> SIGTRAP | PTRACE_EVENT_SECCOMP &lt;&lt; <span class="number">8</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!seccomp_detected &amp;&amp; seccomp_enabled) &#123;</span><br><span class="line">    <span class="built_in">VERBOSE</span>(tracee, <span class="number">1</span>, <span class="string">&quot;ptrace acceleration (seccomp mode 2) enabled&quot;</span>);</span><br><span class="line">    tracee-&gt;seccomp = ENABLED;</span><br><span class="line">    seccomp_detected = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (signal == (SIGTRAP | PTRACE_EVENT_SECCOMP2 &lt;&lt; <span class="number">8</span>) ||</span><br><span class="line">      signal == (SIGTRAP | PTRACE_EVENT_SECCOMP &lt;&lt; <span class="number">8</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line">    signal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use the common ptrace flow if seccomp was</span></span><br><span class="line"><span class="comment">     * explicitly disabled for this tracee.  */</span></span><br><span class="line">    <span class="keyword">if</span> (tracee-&gt;seccomp != ENABLED)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    status = <span class="built_in">ptrace</span>(PTRACE_GETEVENTMSG, tracee-&gt;pid, <span class="literal">NULL</span>, &amp;flags);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; FILTER_SYSEXIT) == <span class="number">0</span>) &#123;</span><br><span class="line">      tracee-&gt;restart_how = PTRACE_CONT;</span><br><span class="line">      <span class="built_in">translate_syscall</span>(tracee);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (tracee-&gt;seccomp == DISABLING)</span><br><span class="line">        tracee-&gt;restart_how = PTRACE_SYSCALL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fall through. */</span></span><br><span class="line"><span class="keyword">case</span> SIGTRAP | <span class="number">0x80</span>:</span><br><span class="line"></span><br><span class="line">  signal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This tracee got signaled then freed during the</span></span><br><span class="line"><span class="comment">     sysenter stage but the kernel reports the sysexit</span></span><br><span class="line"><span class="comment">     stage; just discard this spurious tracee/event.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tracee-&gt;exe == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    tracee-&gt;restart_how = PTRACE_CONT; <span class="comment">/* SYSCALL OR CONT */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (tracee-&gt;seccomp) &#123;</span><br><span class="line">  <span class="keyword">case</span> ENABLED:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_IN_SYSENTER</span>(tracee)) &#123;</span><br><span class="line">      <span class="comment">/* sysenter: ensure the sysexit</span></span><br><span class="line"><span class="comment">       * stage will be hit under seccomp.  */</span></span><br><span class="line">      tracee-&gt;restart_how = PTRACE_SYSCALL;</span><br><span class="line">      tracee-&gt;sysexit_pending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* sysexit: the next sysenter</span></span><br><span class="line"><span class="comment">       * will be notified by seccomp.  */</span></span><br><span class="line">      tracee-&gt;restart_how = PTRACE_CONT;</span><br><span class="line">      tracee-&gt;sysexit_pending = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Fall through.  */</span></span><br><span class="line">  <span class="keyword">case</span> DISABLED:</span><br><span class="line">    <span class="built_in">translate_syscall</span>(tracee);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This syscall has disabled seccomp.  */</span></span><br><span class="line">    <span class="keyword">if</span> (tracee-&gt;seccomp == DISABLING) &#123;</span><br><span class="line">      tracee-&gt;restart_how = PTRACE_SYSCALL;</span><br><span class="line">      tracee-&gt;seccomp = DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> DISABLING:</span><br><span class="line">    <span class="comment">/* Seccomp was disabled by the</span></span><br><span class="line"><span class="comment">     * previous syscall, but its sysenter</span></span><br><span class="line"><span class="comment">     * stage was already handled.  */</span></span><br><span class="line">    tracee-&gt;seccomp = DISABLED;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_IN_SYSENTER</span>(tracee))</span><br><span class="line">      tracee-&gt;status = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>同理先处理第一个 SIGTRAP，因为触发顺序是：syscall_enter -&gt; PTRACE_EVENT_SECCOMP -&gt; syscall_exit</p>
<p>因为设置的是 seccomp-BRF，所以首先触发的是 case SIGTRAP | PTRACE_EVENT_SECCOMP2 &lt;&lt; 8:case SIGTRAP | PTRACE_EVENT_SECCOMP &lt;&lt; 8:，所以当不需要 FILTER_SYSEXIT 时，设置 restart_how 为 PTRACE_CONT，然后 translate_syscall(tracee); 执行 enter 阶段的操作，重启后直到下一个 BRF 规则。</p>
<p>如果需要 FILTER_SYSEXIT 那么 Fall through 到 case SIGTRAP | 0x80: 执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ENABLED:</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">IS_IN_SYSENTER</span>(tracee)) &#123;</span><br><span class="line">					<span class="comment">/* sysenter: ensure the sysexit</span></span><br><span class="line"><span class="comment">					 * stage will be hit under seccomp.  */</span></span><br><span class="line">					tracee-&gt;restart_how = PTRACE_SYSCALL;</span><br><span class="line">					tracee-&gt;sysexit_pending = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>继续 Fall Through 到，调用 translate_syscall 对函数调用前的参数进行处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> DISABLED:</span><br><span class="line">				<span class="built_in">translate_syscall</span>(tracee);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* This syscall has disabled seccomp.  */</span></span><br><span class="line">				<span class="keyword">if</span> (tracee-&gt;seccomp == DISABLING) &#123;</span><br><span class="line">					tracee-&gt;restart_how = PTRACE_SYSCALL;</span><br><span class="line">					tracee-&gt;seccomp = DISABLED;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>重启后因为 PTRACE_SYSCALL 再次触发 case SIGTRAP | 0x80: 同理到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/* sysexit: the next sysenter</span></span><br><span class="line"><span class="comment">					 * will be notified by seccomp.  */</span></span><br><span class="line">					tracee-&gt;restart_how = PTRACE_CONT;</span><br><span class="line">					tracee-&gt;sysexit_pending = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p>继续处理 syscall_exit 阶段，具体每个不同的 syscall 处理逻辑可以自行翻看代码不再赘述，这里已经分析清楚整个的核心逻辑。</p>
<h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>整个 proot 代码已经十分健壮，我们可以稍加修改就能移植到 Android，后续有时间可以考虑开发，并且伴随着 Android 版本的升级，seccomp-brf 的能力也可以逐渐开启，我们可以看到主流 Android 版本已经支持：</p>
<table>
<thead>
<tr>
<th>8.1  Oreo</th>
<th>27</th>
<th>3.18.70 4.4.88 4.9.56</th>
<th>4.10.0</th>
</tr>
</thead>
<tbody><tr>
<td>9.0  Pie</td>
<td>28</td>
<td>4.4.146 4.9.118 4.14.61</td>
<td>4.15.0</td>
</tr>
<tr>
<td>10.0  Q</td>
<td>29</td>
<td>4.9.191 4.14.142 4.19.71</td>
<td>5.0.3</td>
</tr>
</tbody></table>
<p>但是考虑到国内手机厂商的可能魔改内核，真正在生产环境使用还是需要考虑周全，不过作为攻击方来进行利用已经足够成熟了，而笔者在这两篇文章中也说明了边界对抗的核心，希望能够进一步的深入思考安全与风控的本质。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/55006186/how-to-get-the-return-code-of-the-syscall-using-seccomp-ret-data-and-ptrace-gete">How to get the return code of the syscall using SECCOMP_RET_DATA and PTRACE_GETEVENTMSG</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/proot-me/proot">proot</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273160-1.htm">SVC的TraceHook沙箱的实现&amp;无痕Hook实现思路</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7197337416096038967">PRoot沙箱机制浅析</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-275511-1.htm">seccomp-bpf+ptrace实现修改系统调用原理（附demo）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273495.htm">Seccomp BPF与容器安全</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/ptrace.2.html">ptrace linux manual</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://draveness.me/whys-the-design-syscall-overhead/">为什么系统调用会消耗较多资源</a></p>
</li>
</ul>

  </div>
</article>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/categories/">Category</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SYSCALL-%E8%B0%83%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">SYSCALL 调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ptrace-%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">Ptrace 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Seccomp-BRF-%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">Seccomp-BRF 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Seccomp"><span class="toc-number">3.1.</span> <span class="toc-text">Seccomp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BRF"><span class="toc-number">3.2.</span> <span class="toc-text">BRF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SVC-%E8%B0%83%E7%94%A8%E6%8B%A6%E6%88%AA%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.</span> <span class="toc-text">SVC 调用拦截实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proot-%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">Proot 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#main"><span class="toc-number">5.1.</span> <span class="toc-text">main</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">子进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">父进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E6%80%9D%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">总结思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">7.</span> <span class="toc-text">参考链接</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&text=深入Android风控边界-syscall"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&title=深入Android风控边界-syscall"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&is_video=false&description=深入Android风控边界-syscall"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=深入Android风控边界-syscall&body=Check out this article: http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&title=深入Android风控边界-syscall"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&title=深入Android风控边界-syscall"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&title=深入Android风控边界-syscall"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&title=深入Android风控边界-syscall"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&name=深入Android风控边界-syscall&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/a-brief-discussion-on-android-risk-control-boundaries-syscall/&t=深入Android风控边界-syscall"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2018-2025
    <a target="_blank" rel="noopener" href="https://bdwms.site">bdwms<a>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
          <li><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">皖ICP备18025933号-3</a></li>
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->


 
  <link
    rel="preload"
    href="/lib/font-awesome/css/all.min.css"
    as="style"
    onload="this.onload=null;this.rel='stylesheet'"
  />
  <noscript
    ><link
      rel="stylesheet"
      href="/lib/font-awesome/css/all.min.css"
  /></noscript>


    <!-- jquery -->

  
<script src="/lib/jquery/jquery.min.js"></script>





<!-- clipboard -->

  
    
<script src="/lib/clipboard/clipboard.min.js"></script>

  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'birdmanwings/birdmanwings.github.io';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>智能合约安全-Ethernaut上篇</title>
      <link href="smart-contract-security-ethernaut-part-one/"/>
      <url>smart-contract-security-ethernaut-part-one/</url>
      
        <content type="html"><![CDATA[<blockquote><p>让我们畅谈智能合约安全吧</p></blockquote><p><a href="https://ethernaut.openzeppelin.com/">Ethernaut</a> 是 <a href="https://openzeppelin.com/">OpenZeppelin</a> 创建的一个智能合约 CTF 网站，这里笔者通过这里的 CTF 关卡来熟悉下智能合约中的常见漏洞，因为篇幅原因分为几篇进行更新。</p><h2 id="题库"><a href="#题库" class="headerlink" title="题库"></a>题库</h2><h3 id="0x00-Hello-Ethernaut"><a href="#0x00-Hello-Ethernaut" class="headerlink" title="0x00 Hello Ethernaut"></a>0x00 Hello Ethernaut</h3><p>熟悉环境和操作，安装好小狐狸 MetaMask 后从水龙头获得测试网代币，然后打开 Chrome 开发者工具，点击 Get new instance 获取关卡：</p><p><img src="https://image.bdwms.com/image-20230831213036573.png" alt="image-20230831213036573"></p><p>然后就是按照提示在 Console 中交互 JS：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">info</span>()</span><br><span class="line"><span class="string">&quot;You will find what you need in info1().&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">info1</span>()</span><br><span class="line"><span class="string">&quot;Try info2(), but with &quot;</span>hello<span class="string">&quot; as a parameter.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">info2</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="string">&quot;The property infoNum holds the number of the next info method to call.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">infoNum</span>()</span><br><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">info42</span>()</span><br><span class="line"><span class="string">&quot;theMethodName is the name of the next method.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">theMethodName</span>()</span><br><span class="line"><span class="string">&quot;The method name is method7123949.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">method7123949</span>()</span><br><span class="line"><span class="string">&quot;If you know the password, submit it to authenticate().&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">password</span>()</span><br><span class="line"><span class="string">&quot;ethernaut0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">authenticate</span>(<span class="string">&quot;ethernaut0&quot;</span>)</span><br></pre></td></tr></table></figure><p>交互完成后，点击 Submit instance 提交答案，就会获得关卡的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Instance &#123;</span><br><span class="line"></span><br><span class="line">  string public password;</span><br><span class="line">  uint8 public infoNum = 42;</span><br><span class="line">  string public theMethodName = &#x27;The method name is method7123949.&#x27;;</span><br><span class="line">  bool private cleared = false;</span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  constructor(string memory _password) &#123;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;You will find what you need in info1().&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info1() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;Try info2(), but with &quot;hello&quot; as a parameter.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info2(string memory param) public pure returns (string memory) &#123;</span><br><span class="line">    if(keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked(&#x27;hello&#x27;))) &#123;</span><br><span class="line">      return &#x27;The property infoNum holds the number of the next info method to call.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#x27;Wrong parameter.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info42() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;theMethodName is the name of the next method.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function method7123949() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;If you know the password, submit it to authenticate().&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function authenticate(string memory passkey) public &#123;</span><br><span class="line">    if(keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) &#123;</span><br><span class="line">      cleared = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getCleared() public view returns (bool) &#123;</span><br><span class="line">    return cleared;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是我们交互的 js 调用的函数。</p><h3 id="0x01-Fallback"><a href="#0x01-Fallback" class="headerlink" title="0x01 Fallback"></a>0x01 Fallback</h3><p>要求为成为 owner 并让 balance 为 0，提示是使用 fallback 函数：</p><ol><li>you claim ownership of the contract</li><li>you reduce its balance to 0</li></ol><p>先看代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    payable(owner).transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以观察到如果想要修改 owner 有两个入口点，contribute 函数中贡献超过原来的 owner 或者 receive 函数中达成发送者 value 大于 0 并且 contribitions map 中对应的地址也大于 0。显然本题不是让我们暴力一直 contribute，所以我们可以了解下回退函数：</p><blockquote><p>当你调用的函数在合约中不存在，或者直接向合约中发送以太坊主币的时候，都会调用回退函数；fallback()是一个后备函数，receive 只负责接受主币；当以太坊主币发送到合约时，首先要判断 <strong>msg.data</strong> 是否为空，如果不为空就会调用 **fallback()**，如果为空，再判断 <strong>receive</strong> 函数是否存在，如果存在，调用 <strong>receive</strong> 函数，如果不存在，调用 <strong>fallback</strong> 函数，</p></blockquote><p>这里没有 fallback，所以我们可以通过直接给合约发送 value 来触发 receive 函数来获取 owner。总结下思路就是：</p><ol><li>contribute 先贡献 ether：<code>contract.contribute(&#123;value: toWei(&quot;0.00001&quot;)&#125;)</code></li><li>直接给 contract 发送 value，触发 receive 获取 owner： <code>contract.sendTransaction(&#123;value: toWei(&quot;0.00001&quot;)&#125;)</code></li><li>最后调用 withdraw 函数：<code>contract.withdraw()</code></li></ol><p>我们利用预先准备的 toWei 函数来换算单位，然后也可以看到我们 sendTransaction 后的 owner 成为了我们自己的地址</p><p><img src="https://image.bdwms.com/image-20230903233546448.png" alt="image-20230903233546448"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈区块链（三）-以太坊纵览</title>
      <link href="block-chain-3-eth-history/"/>
      <url>block-chain-3-eth-history/</url>
      
        <content type="html"><![CDATA[<blockquote><p>历史，现在以及未来</p></blockquote><p>为了更好地了解以太坊的全貌，本篇文章将主要介绍以太坊的历史背景，当前发展以及未来愿景，着重强调在以太坊发展中的关键节点与核心技术。</p><h2 id="以太坊回顾"><a href="#以太坊回顾" class="headerlink" title="以太坊回顾"></a>以太坊回顾</h2><p>在数字货币的世界中，比特币无疑是第一个引起全球关注的项目，但紧随其后的以太坊却以其独特的智能合约功能和去中心化应用平台，开启了区块链2.0的新篇章。</p><h3 id="区块链技术的基础"><a href="#区块链技术的基础" class="headerlink" title="区块链技术的基础"></a>区块链技术的基础</h3><p>区块链技术是一种分布式数据库技术，通过多个节点共同维护一个公开的、不可篡改的账本。其核心是利用密码学原理确保数据的完整性和安全性。比特币作为第一个实现区块链技术的项目，主要用于创建和管理数字货币。</p><h3 id="以太坊的技术基础"><a href="#以太坊的技术基础" class="headerlink" title="以太坊的技术基础"></a>以太坊的技术基础</h3><p>以太坊在区块链的基础上，引入了智能合约的概念。智能合约是一段自动执行的代码，可以在区块链上部署和运行。以太坊虚拟机（EVM）作为其核心组件，允许开发者使用Solidity等编程语言编写智能合约。</p><h3 id="与比特币的技术与理念上的不同"><a href="#与比特币的技术与理念上的不同" class="headerlink" title="与比特币的技术与理念上的不同"></a>与比特币的技术与理念上的不同</h3><ul><li><strong>技术层面</strong>：比特币主要作为一种数字货币，而以太坊则提供了一个完整的编程环境，允许开发者构建复杂的去中心化应用（DApps）。</li><li><strong>理念层面</strong>：比特币旨在创建一种去中心化的数字货币系统，而以太坊则更进一步，旨在建立一个去中心化的世界计算机。</li></ul><h3 id="中心思想"><a href="#中心思想" class="headerlink" title="中心思想"></a>中心思想</h3><p>以太坊作为区块链2.0的代表，从一个概念发展成为全球最大的智能合约平台，其历史不仅是技术创新的历程，更是一次对传统金融体系和互联网服务的挑战与革新。本文将深入探讨以太坊的发展历程、技术架构、重大事件以及未来展望。</p><h2 id="早期发展"><a href="#早期发展" class="headerlink" title="早期发展"></a>早期发展</h2><h3 id="Vitalik-Buterin的构想"><a href="#Vitalik-Buterin的构想" class="headerlink" title="Vitalik Buterin的构想"></a>Vitalik Buterin的构想</h3><p>2013年，一个名为Vitalik Buterin的年轻才子开始构思一个全新的区块链平台。他的目标不仅仅是创建一种数字货币，而是提供一个允许人们自由构建去中心化应用的平台。这一构想最终演变成了以太坊。</p><h3 id="白皮书和黄皮书的发布"><a href="#白皮书和黄皮书的发布" class="headerlink" title="白皮书和黄皮书的发布"></a>白皮书和黄皮书的发布</h3><ul><li><strong>白皮书</strong>：Vitalik在2013年底发布了以太坊白皮书，详细描述了以太坊的设计理念和架构。</li><li><strong>黄皮书</strong>：随后，Gavin Wood博士发布了以太坊黄皮书，深入解释了以太坊虚拟机（EVM）的技术细节。</li></ul><h3 id="众筹和开发团队的组建"><a href="#众筹和开发团队的组建" class="headerlink" title="众筹和开发团队的组建"></a>众筹和开发团队的组建</h3><ul><li><strong>众筹</strong>：2014年中，以太坊进行了为期42天的众筹，成功筹集到超过31000个比特币，成为当时最大的众筹项目之一。</li><li><strong>开发团队</strong>：众筹成功后，一支由全球顶尖开发者组成的团队开始了以太坊的开发工作，包括了许多后来在区块链领域有着重要影响的人物。</li></ul><h2 id="技术架构与创新"><a href="#技术架构与创新" class="headerlink" title="技术架构与创新"></a>技术架构与创新</h2><h3 id="智能合约的工作原理"><a href="#智能合约的工作原理" class="headerlink" title="智能合约的工作原理"></a>智能合约的工作原理</h3><p>以太坊的核心创新之一是智能合约。智能合约是一段存储在以太坊区块链上的代码，可以自动执行预定的逻辑。通过智能合约，开发者可以创建复杂的去中心化应用，如去中心化金融、供应链管理等。</p><h3 id="以太坊虚拟机（EVM）的设计"><a href="#以太坊虚拟机（EVM）的设计" class="headerlink" title="以太坊虚拟机（EVM）的设计"></a>以太坊虚拟机（EVM）的设计</h3><p>以太坊虚拟机（EVM）是以太坊的核心组件，负责执行智能合约的代码。EVM是一个堆栈式虚拟机，支持Turing完备的编程语言，如Solidity。EVM的设计使得以太坊成为一个灵活且强大的分布式计算平台。</p><h3 id="共识机制的演变：从PoW到PoS"><a href="#共识机制的演变：从PoW到PoS" class="headerlink" title="共识机制的演变：从PoW到PoS"></a>共识机制的演变：从PoW到PoS</h3><ul><li><strong>工作量证明（PoW）</strong>：以太坊最初采用的是与比特币相同的工作量证明机制，要求矿工解决复杂的数学问题以验证交易。</li><li><strong>权益证明（PoS）</strong>：为了提高效率和可持续性，以太坊计划过渡到权益证明机制。在PoS下，验证者通过持有的代币数量和时间来参与验证过程，大大降低了能源消耗。</li></ul><p>具体原理可以参考上一篇文章：<a href="https://bdwms.site/block-chain-2-eth-basic/">以太坊基础</a></p><h2 id="重大事件和里程碑"><a href="#重大事件和里程碑" class="headerlink" title="重大事件和里程碑"></a>重大事件和里程碑</h2><h3 id="2023年：上海和卡佩拉升级"><a href="#2023年：上海和卡佩拉升级" class="headerlink" title="2023年：上海和卡佩拉升级"></a>2023年：上海和卡佩拉升级</h3><ul><li><strong>上海升级（2023年4月12日）</strong>：引入质押提款，是以太坊2.0的重要里程碑。</li><li><strong>卡佩拉升级（2023年4月12日）</strong>：信标链的第三次重大升级，同步进行。</li></ul><h3 id="2022年：合并和准备"><a href="#2022年：合并和准备" class="headerlink" title="2022年：合并和准备"></a>2022年：合并和准备</h3><ul><li><strong>巴黎升级（2022年9月15日）</strong>：结束了挖矿算法，是以太坊从工作量证明转向权益证明的关键步骤。</li><li><strong>Bellatrix升级（2022年9月6日）</strong>：为合并做好准备。</li><li><strong>灰色冰川升级（2022年6月30日）</strong>：推迟了难度炸弹。</li></ul><h3 id="2021年：信标链的发展"><a href="#2021年：信标链的发展" class="headerlink" title="2021年：信标链的发展"></a>2021年：信标链的发展</h3><ul><li><strong>伦敦升级（2021年8月5日）</strong>：引入了EIP-1559，是以太坊交易费市场的重大改革。</li><li><strong>柏林升级（2021年4月15日）</strong>：优化了虚拟机操作的燃料成本。</li></ul><h3 id="2020年：信标链的诞生"><a href="#2020年：信标链的诞生" class="headerlink" title="2020年：信标链的诞生"></a>2020年：信标链的诞生</h3><ul><li><strong>信标链创世块（2020年12月1日）</strong>：信标链的启动，标志着以太坊2.0时代的开始。</li><li><strong>质押存款合约（2020年10月14日）</strong>：引入质押机制。</li></ul><h3 id="2019年及之前：早期的升级和分叉"><a href="#2019年及之前：早期的升级和分叉" class="headerlink" title="2019年及之前：早期的升级和分叉"></a>2019年及之前：早期的升级和分叉</h3><ul><li><strong>伊斯坦布尔分叉（2019年12月8日）</strong>：优化了虚拟机中特定操作的燃料成本。</li><li><strong>君士坦丁堡分叉（2019年2月28日）</strong>：确保在实现权益证明之前，区块链不会冻结。</li><li><strong>去中心化自治组织分叉（2016年7月20日）</strong>：响应2016 DAO攻击，恢复被盗走的以太币。</li></ul><h2 id="以太坊生态系统和社区的发展"><a href="#以太坊生态系统和社区的发展" class="headerlink" title="以太坊生态系统和社区的发展"></a>以太坊生态系统和社区的发展</h2><h3 id="以太坊生态系统的多样性"><a href="#以太坊生态系统的多样性" class="headerlink" title="以太坊生态系统的多样性"></a>以太坊生态系统的多样性</h3><p>以太坊生态系统包括了各种各样的项目和应用，从去中心化金融（DeFi）到非同质化代币（NFT）的艺术市场，再到去中心化自治组织（DAO）等。</p><ul><li><strong>去中心化金融（DeFi）</strong>：以太坊上的DeFi项目如Uniswap、Compound等，为用户提供了无需中介的金融服务。</li><li><strong>非同质化代币（NFT）</strong>：NFT项目如CryptoKitties、OpenSea等，为艺术家和收藏家提供了独特的数字资产交易平台。</li><li><strong>去中心化自治组织（DAO）</strong>：DAO项目如MolochDAO、Aragon等，允许社区成员共同决策和管理资源。</li></ul><h3 id="社区的参与和贡献"><a href="#社区的参与和贡献" class="headerlink" title="社区的参与和贡献"></a>社区的参与和贡献</h3><p>以太坊的社区由开发者、用户、研究人员、企业家等多元化的成员组成。社区的活跃参与和贡献是以太坊持续创新和发展的关键因素。</p><ul><li><strong>开发者社区</strong>：全球范围内的开发者共同参与以太坊的开发和维护，通过GitHub、论坛等渠道协作。</li><li><strong>用户社区</strong>：用户通过使用DApps、参与治理等方式，推动了以太坊生态系统的繁荣。他们的反馈和需求也直接影响了以太坊的发展方向和改进。</li><li><strong>以太坊基金会</strong>：以太坊基金会作为非营利组织，支持以太坊的研究、开发和教育工作，是整个生态系统的重要支柱。</li></ul><h3 id="重大会议和活动"><a href="#重大会议和活动" class="headerlink" title="重大会议和活动"></a>重大会议和活动</h3><p>以太坊社区定期举办各种会议和活动，促进了知识共享、合作和创新。</p><ul><li><strong>Devcon</strong>：以太坊的年度开发者大会，汇集了全球的开发者、学者和爱好者，共同探讨最新的技术趋势和挑战。</li><li><strong>以太坊黑客松</strong>：全球范围内的黑客松活动，鼓励开发者共同探索和创造新的应用，也是许多创新项目的孵化地。</li></ul><h2 id="以太坊的未来展望和挑战"><a href="#以太坊的未来展望和挑战" class="headerlink" title="以太坊的未来展望和挑战"></a>以太坊的未来展望和挑战</h2><h3 id="以太坊的全球愿景"><a href="#以太坊的全球愿景" class="headerlink" title="以太坊的全球愿景"></a>以太坊的全球愿景</h3><p>以太坊自2015年发布以来取得了难以置信的成功，但社区仍在期待关键升级以激发以太坊的全部潜能。以下是以太坊未来的主要方向：</p><ul><li><strong>升级的必要性</strong>：随着需求量的激增，交易费用上升和磁盘空间的快速增长等问题变得突出。以太坊的一系列升级将解决这些问题，包括“宁静”和“以太坊2.0”等。</li><li><strong>可扩展性的挑战</strong>：以太坊需要在不增加单节点能力的情况下增加每秒交易处理数。分片升级和二层网络卷叠解决方案将直接解决这个问题。</li><li><strong>安全性的提升</strong>：计划进行的升级将提升以太坊面对协同攻击时的安全性。权益证明机制下的安全性将增强，保护验证者免受拒绝服务攻击，并增强验证者的匿名性。</li><li><strong>可持续发展</strong>：以太坊将过渡到权益证明机制，能耗将减少大约99.95%。这种可持续性的增强也带来了安全方面的好处，使得攻击区块链的代价增加，但保护区块链安全的成本更低。</li></ul><h3 id="当前面临的问题"><a href="#当前面临的问题" class="headerlink" title="当前面临的问题"></a>当前面临的问题</h3><ul><li><strong>网络拥堵</strong>：以太坊需要减少网络拥堵、提高速度，以更好地服务全球用户。</li><li><strong>磁盘空间</strong>：随着网络的发展壮大，运行一个节点正在变得越来越难。</li><li><strong>去中心化扩展的挑战</strong>：如何在去中心化的前提下变得更具有可扩展性并且更安全，被称为可扩展性的三难困境。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以太坊自2015年发布以来，已经从一个激进的概念发展成为全球最重要的区块链平台之一。它不仅推动了去中心化应用（DApps）和智能合约的革命，还促进了去中心化金融（DeFi）和许多其他创新领域的发展。</p><p><strong>历史回顾</strong>：从最初的白皮书到首次公开发布，再到各种重大升级和里程碑，以太坊的历史充满了挑战和成就。它的发展反映了一个不断学习、创新和适应的社区。</p><p><strong>技术基础</strong>：以太坊的技术基础包括智能合约、虚拟机和共识算法等，这些都是其成功的关键组成部分。与其他区块链产品相比，以太坊在技术和理念上的不同使其在全球范围内脱颖而出。</p><p><strong>未来展望</strong>：以太坊的未来展望充满了机遇和挑战。从可扩展性到安全性，再到可持续发展，每一个方面都需要精心的规划和执行。以太坊2.0和其他升级计划将使平台更加可扩展、安全和可持续。</p><p><strong>全球影响</strong>：以太坊不仅是一个技术平台，还是一个全球社区和生态系统的象征。它将持续增长，直到造福全人类，实现全球范围内的数字未来。</p><p>以太坊的历史和未来展望揭示了一个充满活力和变革的区块链世界。它的成功不仅依赖于技术的先进性，还依赖于全球社区的共同参与和合作。以太坊的故事是一个关于创新、合作和不懈追求卓越的故事，它将继续激励和引领整个区块链行业的发展。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://ethereum.org/zh/history/">以太坊历史和分叉</a></li><li><a href="https://ethereum.org/zh/roadmap/vision/">以太坊愿景</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Aop-安全领域的魔法</title>
      <link href="aop-security-magic/"/>
      <url>aop-security-magic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>AOP，将切面思想融入到安全领域</p></blockquote><p>AOP 全称为 Aspect-oriented Programming，即面向切面编程。通过预编译，运行时动态代理或者注入等方式，不直接修改源码的情况下向业务逻辑中添加新功能的的编程范式。AOP 技术现在被广泛运用于各个平台的研发生产流程中，不管是客户端还是服务端，又或者是 Java，Objective-C，C++ 等多种语言都存在不同的 AOP 技术。这种不侵入业务开发流程的能力，也正是安全人员需要的，在不影响业务正常发展的前提下，完成必要的安全需求。在这篇文章中，笔者将会尽可能全的介绍相关的 AOP 技术，同时由于笔者对于移动端较为熟悉，所以本篇文章先覆盖移动端，例如服务端 RASP 暂时不涉及。</p><h2 id="AOP-背景"><a href="#AOP-背景" class="headerlink" title="AOP 背景"></a>AOP 背景</h2><p>移动端AOP（面向切面编程）技术是一种编程范式，它允许开发者将横切关注点（cross-cutting concerns）与核心业务逻辑分离。在移动端（Android和iOS）开发中，AOP技术可以帮助开发者更高效地处理诸如日志记录、性能监控、权限管理、安全检查等通用功能。</p><p>移动端 AOP 技术可分为以下两个层面：</p><ol><li>语言层面：Java、C、OC 等。</li><li>切入时机：编译时、加载时、运行时。</li></ol><h2 id="Android-与-iOS-基础"><a href="#Android-与-iOS-基础" class="headerlink" title="Android 与 iOS 基础"></a>Android 与 iOS 基础</h2><table><thead><tr><th><strong>特性</strong></th><th><strong>Android</strong></th><th><strong>iOS</strong></th></tr></thead><tbody><tr><td>操作系统</td><td>基于 Linux 内核</td><td>基于 Darwin 内核</td></tr><tr><td>开发语言</td><td>Java, Kotlin, C&#x2F;C++</td><td>Objective-C, Swift,C&#x2F;C++</td></tr><tr><td>运行时环境</td><td>Android Runtime (ART)</td><td>Objective-C Runtime, Swift Runtime</td></tr><tr><td>应用安装包格式</td><td>APK (Android Package)</td><td>IPA (iOS App Store Package)</td></tr><tr><td>代码执行方式</td><td>JIT (Just-In-Time) 和 AOT (Ahead-Of-Time) 编译，比较老的还有解释执行</td><td>AOT (Ahead-Of-Time) 编译</td></tr><tr><td>编译过程</td><td>Java文件 -&gt; .class 文件 -&gt; .dex文件 -&gt; apk</td><td>.m&#x2F;.swift 文件 -&gt; .o 文件 -&gt; Mach-O 可执行文件</td></tr><tr><td>运行过程</td><td>创建进程 -&gt; 加载运行时库 -&gt; 创建虚拟机实例 -&gt; 加载应用 dex 文件</td><td>启动应用 -&gt; 创建进程 -&gt; 加载 Mach-o 文件 -&gt; 加载动态库</td></tr><tr><td>AOP 相关概念</td><td>Java 字节码, Java 反射机制, JNI (Java Native Interface)</td><td>Objective-C 消息传递机制, Method Swizzling, 动态库注入</td></tr><tr><td>AOP 技术中的语言特性</td><td>Java: 基于 JVM，支持字节码操作，反射</td><td>Objective-C: 动态语言，支持消息传递和方法交换，C: 与操作系统更紧密，支持动态库注入和以及各种hook方法</td></tr></tbody></table><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ol><li><p>开发</p><ul><li>Java：基于虚拟机的类加载，字节码解释执行，AOT和JIT，解释执行。</li><li>kotlin：国内 APP 还是以 Java 为主，kotlin 这里暂时不涉及。</li><li>c&#x2F;c++：native 层开发，基于 NDK。</li></ul></li><li><p>编译</p><ul><li>Java文件 -&gt; .class 文件 -&gt; .dex文件 -&gt; apk（签名）</li><li>c&#x2F;c++文件 -&gt; ndk编译为 so -&gt; 打包到 apk 中</li></ul><p><img src="https://image.bdwms.com/2bc13d5f-8e49-4d45-9ce1-25c1d8460d61.png" alt="img"></p></li><li><p>安装</p><ol><li>下载安装，校验签名，资源等</li><li>注册应用到系统中，包括各种权限，资源文件等</li></ol></li><li><p>运行</p><ul><li><p>创建第一个进程</p></li><li><p>加载各种运行时库</p></li><li><p>创建虚拟机实例( Android 5 以后为 ART 虚拟机，逐渐有了 jit ,aot 的能力)</p></li><li><p>加载应用 dex 文件，并将类，方法注册进虚拟机中</p></li><li><p>应用正式启动</p></li></ul></li></ol><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><ol><li>开发<ul><li>objective-c：动态方法分发、多态和运行时类型检查等特性。通过消息传递机制，Objective-C 运行时能够在运行时确定方法调用的目标，实现动态方法解析和替换等高级功能。</li><li>swift</li><li>c&#x2F;c++</li></ul></li><li>编译</li></ol><p><img src="https://image.bdwms.com/a7489b9a-b47a-4fcf-a568-dfaa754addb6.png" alt="img"></p><p><img src="https://image.bdwms.com/9e975926-0be1-423b-98be-6eb8a57cf095.png" alt="img"></p><ol><li>安装<ul><li>安装应用</li><li>校验签名</li><li>分配沙盒</li></ul></li><li>运行<ul><li>启动应用，创建进程</li><li>加载 Mach-o文件</li><li>读 Mach-o 文件头，获取元数据</li><li>dyld动态链接加载，加载动态库，包括各种系统库，三方库</li><li>解析符号，将可执行文件和动态库中的符号，链接到正确的内存地址，包括函数调用，全局变量等</li><li>初始化环境，包括创建主线程等</li></ul></li></ol><h2 id="Android-AOP-技术"><a href="#Android-AOP-技术" class="headerlink" title="Android AOP 技术"></a>Android AOP 技术</h2><h3 id="Java层"><a href="#Java层" class="headerlink" title="Java层"></a>Java层</h3><p><img src="https://image.bdwms.com/c2836868-e90c-46ae-b6ef-bf2540a6be06.png" alt="img"></p><h4 id="静态AOP"><a href="#静态AOP" class="headerlink" title="静态AOP"></a>静态AOP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;</span><br><span class="line">    u2             minor_version;</span><br><span class="line">    u2             major_version;</span><br><span class="line">    u2             constant_pool_count;</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             this_class;</span><br><span class="line">    u2             super_class;</span><br><span class="line">    u2             interfaces_count;</span><br><span class="line">    u2             interfaces[interfaces_count];</span><br><span class="line">    u2             fields_count;</span><br><span class="line">    field_info     fields[fields_count];</span><br><span class="line">    u2             methods_count;</span><br><span class="line">    method_info    methods[methods_count];</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原理：编译时 class 字节码修改</li><li>代表技术：apt注解，AspectJ 编译器</li></ul><h4 id="动态-x2F-半动态AOP"><a href="#动态-x2F-半动态AOP" class="headerlink" title="动态&#x2F;半动态AOP"></a>动态&#x2F;半动态AOP</h4><p><img src="https://image.bdwms.com/da9fa4a1-cb3a-4aa3-9471-729b8da806f7.png" alt="img"></p><ul><li>原理：运行时对象生成，修改字节码，然后利用 classloader等方式加载生成的 class；但是也可以在编译时修改 class 或者 dex</li><li>代表技术：ASM, Javassist, Cglib&#x2F;DexMaker、Java 动态代理（只支持接口代理）、ByteBuddy（依赖Java虚拟机）</li></ul><h3 id="虚拟机层"><a href="#虚拟机层" class="headerlink" title="虚拟机层"></a>虚拟机层</h3><p><img src="https://image.bdwms.com/5e25d7f5-bbb1-41c5-b45d-ec3e849c8e09.png"></p><ul><li>原理：针对 Dalvik&#x2F;ART 虚拟机进行劫持修改: <ul><li>Dalvik 修改 Method 结构体重的 insns 字段；</li><li>Art 修改 ArtMethod 中的 entry_point_from_quick_compiled_code 字段；</li></ul></li><li>代表技术：Xposed, Dexposed, Frida java层, Epic, Sandhook</li></ul><h3 id="Native-层"><a href="#Native-层" class="headerlink" title="Native 层"></a>Native 层</h3><h4 id="静态-AOP"><a href="#静态-AOP" class="headerlink" title="静态 AOP"></a>静态 AOP</h4><h4 id="动态-AOP"><a href="#动态-AOP" class="headerlink" title="动态 AOP"></a>动态 AOP</h4><ol><li><p>inlinehook</p><ul><li>原理：Inline Hook：直接修改目标函数在内存中的机器码，使其在执行到某个点时跳转到我们自己的代码（Hook函数）。在此处我们可以执行额外的操作（例如修改参数、记录日志等），然后再跳回原始函数的剩余部分继续执行。</li><li>代表技术：ShadowHook，dobby</li></ul></li><li><p>PLT Hook</p><p><img src="https://image.bdwms.com/1c0f9814-ae84-46e9-8e89-6bdf4e2857ca-20230625135839325.png"></p><ul><li><p>原理：PLT&#x2F;GOT Hook; Trap Hook基于信号捕获，具体原理如下</p><ol><li><p>当程序使用动态链接库时，编译器会在程序中生成一个PLT（Procedure Linkage Table）和GOT（Global Offset Table）。PLT用于存储函数调用的跳转指令（为了延时绑定），而GOT用于存储动态链接库中函数的实际地址（避免每次都解析地址）。</p></li><li><p>当程序第一次调用动态链接库中的某个函数时，会先跳转到PLT中对应的条目，PLT条目会将控制流转移到GOT中的地址。第一次访问时，GOT中存储的是一个解析器（resolver）函数的地址，该解析器会查找并填充动态链接库中函数的实际地址，然后跳转到该地址执行函数。</p></li><li><p>当再次调用相同的函数时，PLT条目会直接跳转到GOT中存储的动态链接库函数地址，从而避免重复解析。</p></li><li><p>首先，找到目标函数在GOT中的地址条目。接着，将GOT中的地址条目修改为自定义函数（hook函数）的地址。为了在hook函数中调用原始函数，需要保存原始函数的地址，以便在执行完hook函数后跳转回原始函数。</p></li></ol></li><li><p>代表技术：Bhook 框架</p></li></ul></li></ol><h2 id="iOS-AOP-技术"><a href="#iOS-AOP-技术" class="headerlink" title="iOS AOP 技术"></a>iOS AOP 技术</h2><h3 id="Objective-C-层"><a href="#Objective-C-层" class="headerlink" title="Objective-C 层"></a>Objective-C 层</h3><h4 id="静态-AOP-1"><a href="#静态-AOP-1" class="headerlink" title="静态 AOP"></a>静态 AOP</h4><ul><li>原理：mach-o符号劫持</li><li>代表技术：objc_msgSend符号表劫持，修改Mach-O文件中的符号表，将原始函数名称重定向到自定义函数，兼容性不好</li></ul><h4 id="动态-AOP-1"><a href="#动态-AOP-1" class="headerlink" title="动态 AOP"></a>动态 AOP</h4><p><img src="https://image.bdwms.com/c4b9963a-26e8-41a5-98b6-442173684d46.png" alt="img"></p><ul><li><p>原理：Method Swizzling</p><p>在运行时，类(Class)维护了一个消息分发列表来解决消息的正确发送。每一个消息列表的入口是一个方法(Method)，这个方法映射了一对键值对，其中键值是这个方法的名字Selector(SEL)，值是指向这个方法实现的函数指针Implementation(IMP)</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (void)greet;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (void)greet &#123;</span><br><span class="line">    NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">[person greet];</span><br><span class="line"></span><br><span class="line">1. 运行时系统根据 person 指针找到其对应的类（Person 类）；</span><br><span class="line">2. 在 Person 类的消息分发列表中，查找键值为 @selector(greet) 的条目；</span><br><span class="line">3. 找到对应的 Implementation（即 greet 方法的实现）；</span><br><span class="line">4. 执行 Implementation，输出 &quot;Hello, World!&quot;。</span><br></pre></td></tr></table></figure><ul><li>代表技术：RSSwizzle, Aspect, JSPatch</li></ul><h3 id="Native-层-1"><a href="#Native-层-1" class="headerlink" title="Native 层"></a>Native 层</h3><h4 id="静态AOP-1"><a href="#静态AOP-1" class="headerlink" title="静态AOP"></a>静态AOP</h4><ul><li>原理：Clang LLVM插桩</li><li>代表技术：Dobby 跨平台的 inline hook 框架</li></ul><h4 id="动态AOP"><a href="#动态AOP" class="headerlink" title="动态AOP"></a>动态AOP</h4><ol><li>Inline Hook</li><li>符号表 Hook<ul><li>原理：Mach-O动态绑定机制，懒加载</li><li>代表技术：fishhook</li></ul></li></ol><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://image.bdwms.com/b0903bcb-10cf-4748-8b89-3592ccc866a5.png" alt="img"></h4><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>移动端领域的 AOP 技术主要还是运用在以下的一些方面：</p><ul><li>隐私保护</li><li>办公泄密</li><li>端行为监控</li><li>安全漏洞</li><li>……</li></ul><p>主要解决的问题是：</p><ol><li>对APP内部不同身份的代码模块的身份和行为做识别和管控</li><li>对APP内部的调用行为实现详细的内视和追溯</li></ol><p>这也是为什么通过简单的埋点无法替代的，因为二三方的代码是不可控的，没有源码也就无法修改，所以这就需要各种 AOP 技术的介入。当然考虑到实际的工程化，各种 AOP 技术都有着自身的局限性，我们主要考虑以下方面：</p><ul><li><strong>稳定性</strong>：主要就是对各个版本，厂商 Android；iOS 版本的兼容性，这个是目前看来最为困难的点，排除掉了各种 inline hook 方案，因为都不够健壮。</li><li><strong>性能</strong>：一般静态 AOP 方案损耗比较少，因为字节码已经确定，动态方案如果需要运行时生成对象会损耗比较大，对于 OC 的方法交换没有生成字节码对象，只是函数指针的交换性能损失还可以接受，所以排除了大部门需要运行时动态生成对象的方案。</li><li><strong>灵活性</strong>：需要考虑到客户端 AOP 的特殊性，静态 AOP 方案发出后就无法更改更加危险，所以动态方案会更加灵活，这点上做了取舍。</li><li><strong>可用性</strong>：例如 xposed 需要 root，frida 也要注入进程这些都不能成为线上开发实际使用的</li><li><strong>覆盖度</strong>：几乎是每个方案，都无法全面覆盖所有切点，有些只能覆盖外部系统库（fishhook），有的只能覆盖特定的方法（java 代理模式），所以需要结合具体场景来做取舍。</li><li><strong>安全对抗</strong>：风控 SDK 可能检测 Hook，这个结合具体业务需要做适配</li><li><strong>排查问题难度</strong>：如果 aop 逻辑写的有问题，业务方排查起来会非常困难，这也是 aop 方案的固有问题。</li></ul><p>总结下来对于 Android 比较稳定的方案是：</p><ul><li>Java 层 ASM 字节码操作</li><li>Native 层 PLT Hook，例如 bhook 框架</li></ul><p>对于 iOS 比较稳定的方法：</p><ul><li>OC 层 Method Swizzle </li><li>Native 层 Fishook （但是没有 Android bhook库稳定与健壮，所以不推荐线上环境使用）</li></ul><p>以上也是能够在真正的亿级生产环境中上线的当前方案，更具体的不方便展开讨论，也是笔者自身实践所得出来的浅薄经验，希望对读者有所帮助。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://lsieun.github.io/java-asm-01/java-classfile-skim.html">Java Class 字节码参考资料</a></li><li><a href="https://www.cnblogs.com/crazymakercircle/p/16635330.html#autoid-h2-5-0-0">Java 字节码介绍</a></li><li><a href="https://weishu.me/2017/11/23/dexposed-on-art/">我为Dexposed续一秒——论ART上运行时 Method AOP实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/132699875">Android Native Hook技术你知道多少？</a></li><li><a href="https://github.com/bytedance/android-inline-hook/blob/main/README.zh-CN.md">ShadowHook inlinehook</a></li><li><a href="https://github.com/bytedance/bhook/blob/main/doc/overview.zh-CN.md">bhook plt hook</a></li><li><a href="https://xilankong.github.io/ios%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/2020/07/29/Xcode-build%E8%BF%87%E7%A8%8B%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88.html">Xcode build过程中都做了什么</a></li><li><a href="https://github.com/facebook/fishhook">fishhook</a></li><li>[<a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C 消息发送与转发机制原理</a></li><li><a href="https://toutiao.io/posts/98gybd/preview">iOS 界的毒瘤：Method Swizzling</a></li><li><a href="https://wereadteam.github.io/2016/06/30/Aspects/">面向切面编程之 Aspects 源码解析及应用</a></li><li><a href="https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3">JSPatch 实现原理详解</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>个人家庭影音系统2.0</title>
      <link href="home-video-system-v2/"/>
      <url>home-video-system-v2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于软路由打造的新一版家庭网络拓扑图</p></blockquote><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>接上文《<a href="https://bdwms.site/home-video-system/">个人家庭影音系统</a>》，在测试运行一段时间后遇上一些问题：</p><ol><li>wrt32x 路由器刷自编译的 openwrt 不够稳定，有时候需要重启路由器才能连接网络。</li><li>直接路由器裸接硬盘盒的管理方式稍显粗糙。</li><li>最重要的是路由器的天线给猫撞断了。</li></ol><p>本来笔者考虑的是否买一个路由器重新刷 openwrt，例如红米 AX6000。但是考虑到后续家庭的网络拓展以及自己动手的乐趣，最终决定上手软路由，基于软路由来打造整个家庭的网络拓扑。</p><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><p>通过在恩山论坛，v2ex，知乎等平台研究了几天，大致理清了整个软路由硬件的体系。购买软路由最为主要的就是挑选 CPU 型号，其中 CPU 又分为 x86 和 arm 架构，x86 架构的软路由更加通用并且可拓展性可玩性更好，arm 架构的 CPU 会更便宜，笔者根据自身需求选择 x86 架构的 CPU。目前市面上主流的 x86 软路由 CPU 型号为 J4125，N5105，以及比较新的 N100 等。对于笔者，由于选择的电信宽带暂时还是 300M 的，并且也并不准备在软路由上运行 Windows 虚拟机等过于复杂的操作，所以选择了 J4125 作为入门软路由的第一站。</p><img src="https://image.bdwms.com/EEE690B2-CC22-4AD2-AD7F-323B6802EE90.jpeg" alt="EEE690B2-CC22-4AD2-AD7F-323B6802EE90" style="zoom: 25%;" /><p>倍控这款 J4125 最主要的是有 4 个 2.5G 的网口，并配有 2 个 3.0 的 USB 口，这也是后面最为主要使用的。裸的 J4125 软路由需要自己搭配内存条以及固态硬盘，目前的内存和固态硬盘都十分便宜，这里在京东上选择了内存条为光威 3200 DDR4 8G * 2，其实这款最高内存频率只支持到 2666MHz，但是由于 J4125 比较吃内存颗粒，不是每个内存条都能点亮所以，最后 3200 点亮后不想再麻烦更换了。</p><img src="https://image.bdwms.com/59BC446E-506F-404D-A924-037ED607E718_1_102_o.jpeg" alt="59BC446E-506F-404D-A924-037ED607E718_1_102_o" style="zoom: 33%;" /><p>固态硬盘的话，这款支持 mSATA 和 2.5 寸的 SATA 固态同时安装，这里随便购买了金百达的 mSATA 240GB 固态作为软路由的系统盘，因为无论是目前临时使用硬盘盒还是之后添加 NAS，笔者都认为路由处理，数据存储等各种服务最好还是隔离，毕竟 ALL IN ONE 等于 ALL IN BOOM。</p><img src="https://image.bdwms.com/7A2038F3-AE4B-4DC9-B105-ED8305620AAD_1_105_c.jpeg" alt="7A2038F3-AE4B-4DC9-B105-ED8305620AAD_1_105_c" style="zoom: 67%;" /><p>拆机将内存和硬盘安装上，效果图大致如下：</p><img src="https://image.bdwms.com/IMG_0020.jpeg" alt="IMG_0020" style="zoom: 25%;" /><p>然后软路由如果想要支持 WiFi 连接需要一个信号发射器，那么之前使用的路由器用来当作 AP 再好不过了，笔者使用的是经典的红米 AC2100。整体的大致物理网络连接图如下：</p><p><img src="https://image.bdwms.com/physics_network.png" alt="physics_network"></p><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>对于软路由的有多种技术选型，例如简单的有直接物理机安装 OpenWrt，iKuai 等软路由操作系统、物理机安装 ikuai 虚拟机安装 OpenWrt、物理机安装虚拟机，虚拟机中运行操作系统等等部署方式。经过简单的调研这边考虑到可玩性、稳定性、可移植等因素，最终选择了虚拟机安装操作系统，其中常见的虚拟机 ESXi、PVE、unRaid：</p><ul><li>ESXi：是VMWare vSphere Hypervisor套件之下重要组件。前身是ESX，依赖Linux源码，后来抛弃Linux源码做成了ESXi。整个产品商用气息浓重，界面清晰易用，但硬件兼容性较差（主要面向服务器），没什么扩展性（毕竟不是linux）。</li><li>PVE：全称Proxmox Virtual Environment，是基于Debian的Linux系统，虚拟机内核为KVM。硬件兼容性优秀。界面功能不强，很多操作要靠命令行，但扩展能力几乎是无限的。</li><li>unRaid：其实是个NAS系统，是基于Slackware的Linux系统，虚拟机内核也是KVM。磁盘阵列管理非常有特色，灵活性很高。同时还有很不错的插件、Docker和虚拟机支持。</li></ul><p>具体的对比可参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/166352130">ESXi、PVE、unRaid对比</a>，笔者身为程序员肯定是选择可拓展性，可玩性更好的 PVE。</p><h3 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h3><p>之后就是 PVE 以及软路由系统的安装配置，具体参考这篇文章不再赘述：<a href="https://www.right.com.cn/forum/thread-8159418-1-1.html">保姆级J4125下安装pve&#x2F;爱快&#x2F;op</a> 或者教程视频参考：<a href="https://www.youtube.com/watch?v=LqZFKAJxcAQ">YouTube 视频</a></p><p>安装之后整个的网络配置，子网网段：192.168.31.xxx&#x2F;256</p><ul><li>PVE 虚拟机：192.168.31.2:8006</li><li>ikuai 主路由：192.168.31.3</li><li>OpenWrt 旁路由：192.168.31.5</li></ul><p>其中 ikuai 通过 DHCP 自动从天翼网关获取 IP，这里其实也可以用宽带账号 + 密码 PPPoE 拨号上网，这里暂时不想折腾要密码。</p><img src="https://image.bdwms.com/image-20230706002040310.png" alt="image-20230706002040310" style="zoom: 50%;" /><p>安装好的 OpenWrt 设置 Lan 口，将网关指向 ikuai 主路由：</p><img src="https://image.bdwms.com/image-20230706002527757.png" alt="image-20230706002527757" style="zoom:50%;" /><p>ikuai 主路由负责家庭的正常上网，OpenWrt 负责科学上网等各种特殊操作折腾而不会影响到主路由的正常使用，那么设备想要科学上网如何选择究竟走哪个网关，有一种解法是主路由和旁路由网关互指，就不需要改设置网关，但是这个操作很不优雅，并且旁路由问题可能会影响到主路由，这是不想要的。所以目前暂时还是通过设备手动指定网关，或者在 ikuai 的 DHCP 静态分配中指定网关。例如笔者的 Windows 系统是网线连接路由器，静态绑定 IP 后可以通过内网 WiFi 远程唤醒 WakeOnLan，这里就可以指定 Windows 网关到 OpenWrt 的地址 192.168.31.5。Windows 就会走 OpenWrt 的科学代理，再通过 ikuai 主路由连接到互联网了。</p><p><img src="https://image.bdwms.com/%E6%88%AA%E5%B1%8F2023-07-06%2000.32.07.png" alt="截屏2023-07-06 00.32.07"></p><p>至此整个家里的各种设备就应该可以正常联网了。</p><h3 id="服务拓展"><a href="#服务拓展" class="headerlink" title="服务拓展"></a>服务拓展</h3><p>接下来就是各种服务例如 Jellyfin 应该如何运行呢，同样有各种技术选型，对于笔者来说各种服务肯定优先运行在 docker 中，那么问题就是 docker 在 PVE 中如何安装呢，通过搜索资料大致集中方式如下：</p><ol><li>直接安装在 PVE 上</li><li>安装在 ikuai，OpenWrt 等路由系统的 Docker 中</li><li>安装在 lxc 上，模版选择 Ubuntu，Debian 等系统模版</li><li>安装在虚拟机上，用 Ubuntu，Debian 等系统镜像</li></ol><p>每个方案来大致讲解下：</p><p>对于方案一，直接安装在 PVE 虚拟机底座系统上就污染基础环境，十分不推荐。<br>对于方案二，将服务安装在路由系统上十分不优雅，路由系统故障可能导致其他服务不可用，所以也会有单点故障的问题，不可选。<br>对于方案三，LXC 的大致原理是利用 namespace, cgroup 等技术，轻量级的虚拟化技术。<br>对于方案四，虚拟机中安装更加隔离，安全性更好，但是消耗的资源相对较多一些，同样复杂一些，这是 PVE 官方推荐安装 docker 的方式。</p><p>综合考虑方案三，四都是可以的，安全性和资源消耗都暂时不是考虑的重点，所以这里笔者选择了教程比较多的使用 LXC 安装 docker 并部署 Jellyfin 的方式，具体步骤参考这个视频：<a href="https://www.bilibili.com/video/BV1Xx4y1G7MG/?spm_id_from=333.337.search-card.all.click&vd_source=024a9b691c992bd76b42706bc7b30e9e">免费开源影音服务Jellyfin部署，PVE下LXC套娃安装Debian Docker，核显硬解转码以N5105为例低功耗intel CPU核显通用</a></p><p>Jellyfin 服务跑在 Ubuntu22 的 LXC 容器安装的 docker 中，使用 portainer 来管理 Docker 并安装 N 大的中国定制版 Jellyfin。但是在实际使用的时候，因为 J4125 与 N5105 不同，所以有些步骤弄了半天没有开启例如低电压模式，暂时放弃测试局域网硬解效果还可以就不再折腾，毕竟音视频驱动不是笔者擅长的。</p><p>这里可以简单看下硬解的作用，主要是为了客户端无法支持的编码，或者外网带宽不够需要调整清晰度在服务端解码，如果此时使用软解那么整个软路由的 CPU 就会 100% 被挤爆，路由等其他服务也会受到影响，这也是为什么需要将 J4125 的集成显卡 600 分配直通给 LXC 容器，并透传给 docker 容器中。</p><p><img src="https://image.bdwms.com/image-20230706221651903.png" alt="image-20230706221651903"></p><p>最终部署好 Ubuntu lxc 容器在 192.168.31.41:9443 端口</p><p><img src="https://image.bdwms.com/image-20230706223504020.png" alt="image-20230706223504020"></p><p>并运行 Jellyfin 服务在 192.168.31.41:8096 上，通过 Chrome 浏览器播放 4k 的《星际穿越》，然后在 Ubuntu 中运行 intel_gpu_top 命令来观察显卡的运行情况，可以看到硬解已经成功开启。<img src="https://image.bdwms.com/image-20230706231009589.png" alt="image-20230706231009589"></p><p>然后可以看到网页上实时播放信息，视频的转码帧率 36 fps 还可以接受，到此为止显卡硬解直通 Jellyfin 的链路成功。</p><p><img src="https://image.bdwms.com/%E6%88%AA%E5%B1%8F2023-07-06%2023.12.32.png" alt="截屏2023-07-06 23.12.32"></p><p>然后如果可以的话，其实局域网内直接客户端解码最好，例如 iOS 选择 infuse 作为客户端。</p><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>最后可以看到我的整个家庭网络架构图如下：</p><p><img src="https://image.bdwms.com/physics_network_2.png" alt="physics_network_2"></p><p>整个网络拓扑图中基本已经能满足日常运行，更多可以改进的例如添加 NAS，交换机等再后续改造中进行升级。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.right.com.cn/forum/thread-8159418-1-1.html">保姆级J4125下安装pve&#x2F;爱快&#x2F;op</a></li><li><a href="https://www.v2ex.com/t/830945">v2ex pve 7 安装 docker 的最佳方式讨论</a></li><li><a href="https://zhuanlan.zhihu.com/p/166352130">ESXi、PVE、unRaid对比</a></li><li><a href="https://www.right.com.cn/forum/thread-6754687-1-1.html">(2023.4.14)SHELL脚本：一键给PVE增加温度和cpu频率显示，NVME，机械固态硬盘信息 </a></li><li><a href="https://www.bilibili.com/video/BV1Xx4y1G7MG/?spm_id_from=333.337.search-card.all.click&vd_source=024a9b691c992bd76b42706bc7b30e9e">免费开源影音服务Jellyfin部署，PVE下LXC套娃安装Debian Docker，核显硬解转码以N5105为例低功耗intel CPU核显通用</a></li><li><a href="https://www.chiphell.com/forum.php?mod=viewthread&tid=2375777&extra=&authorid=338165&page=1">[230414]Jellyfin中国特供版+Docker镜像，含驱动，免折腾开箱即用</a></li><li><a href="https://www.right.com.cn/forum/thread-8157780-1-1.html">给孔昊天同学的lxc下安装docker做个延伸：装jellyfin共享集显并挂载NAS</a></li><li><a href="https://www.itxiaoniao.net/archives/378/">USB硬盘挂载到PVE LXC容器使用&#x2F; Proxmox VE硬盘直通黑群晖</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一文了解大语言模型</title>
      <link href="a-novice-s-exploration-of-large-language-models/"/>
      <url>a-novice-s-exploration-of-large-language-models/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Creating safe AGI that benefits all of humanity</p></blockquote><p>2022 年末，OpenAI 推出的 ChatGPT 横空出世，其惊人的推理，对话能力仿佛让人看到真正的人工智能就要诞生。那么其背后的奥义原理是什么，大语言模型（Large Language Model）对我们有什么影响，我们又如何掌握并利用大语言模型的能力呢？在这篇文章中，笔者以一个 AI 零基础的程序员角度出发，简单阐述大语言模型的由来和原理。</p><h2 id="语言学以及-NLP"><a href="#语言学以及-NLP" class="headerlink" title="语言学以及 NLP"></a>语言学以及 NLP</h2><p>在探究 LLM 之前，笔者想要先讨论下其诞生的背景以及相关的领域知识。正如 LLM 的名称所示，大语言模型也是一种语言模型，而语言模型即 NLP 领域的终极目的是什么呢，这里引用维基百科的定义：</p><blockquote><p>Natural language processing (NLP) is an <a href="https://en.wikipedia.org/wiki/Interdisciplinary">interdisciplinary</a> subfield of <a href="https://en.wikipedia.org/wiki/Linguistics">linguistics</a>, <a href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, and <a href="https://en.wikipedia.org/wiki/Artificial_intelligence">artificial intelligence</a> concerned with the interactions between computers and human language, in particular how to program computers to process and analyze large amounts of <a href="https://en.wikipedia.org/wiki/Natural_language">natural language</a> data. The goal is a computer capable of “understanding” the contents of documents, including the <a href="https://en.wikipedia.org/wiki/Context_(language_use)">contextual</a> nuances of the language within them. The technology can then accurately extract information and insights contained in the documents as well as categorize and organize the documents themselves.</p></blockquote><p>其中最为重要的就是「understanding」，对于如何理解人类语言内容主要有两条道路或者说方法，即「基于统计的经验主义与基于规则的理性主义」:</p><ul><li>理性主义（符号主义）：NLP 领域企图完全解构人类的语言文字的所有细节，以期建立起一套理论，就像数学一样，能够精准描述我们在语言文字中显式、隐式包含的信息，更多的从语言学的角度去进行分析处理。。</li><li>经验主义（连接主义）：给机器灌输一些文本信息后，机器能够自己抽取其中的特征信息，学会语言文字背后的「知识」，更多从统计学的角度去体现。</li></ul><p>而最近五年中随着算力（GPU）的提升，以及各种 NLP 模型的诞生与演进，基于经验主义的 NLP 大放异彩，由此诞生了 LLM 这个令人惊诧的东西。神经网络，深度学习等各方面工程化的发展，让算法工程师更多的从效果角度出发优化，暂时没有统一的指导思想，也因此诞生了我们似乎暂时无法完全理解的成果。那么在我们了解了 NLP 的最基础背景后，我们回到 NLP 领域一个最朴素也是最重要的问题：<strong>给你一组文本内容，预测下一个出现的词可能是什么</strong>？</p><h2 id="统计语言模型：N-gram-Language-Model"><a href="#统计语言模型：N-gram-Language-Model" class="headerlink" title="统计语言模型：N-gram Language Model"></a>统计语言模型：N-gram Language Model</h2><p>将文本中的词按照一定的顺序进行组合，形成一个序列，下一个词出现的概率只依赖于它前面 n-1 个词，然后用这个序列来预测下一个词，这也叫做 <strong>N 元文法</strong>。N-gram模型是基于统计的，它通过计算训练语料库中的n-gram出现的频率来预测下一个词。比如，假设我们有以下句子：</p><ol><li>“The cat sat on the mat”</li><li>“The cat ate the mouse”</li><li>“The mouse sat on the mat”</li></ol><p>对于2-gram模型（bigram），我们可以计算以下的条件概率：</p><ul><li>P(“sat” | “The cat”) &#x3D; 1 &#x2F; 2</li><li>P(“ate” | “The cat”) &#x3D; 1 &#x2F; 2</li><li>P(“on” | “cat sat”) &#x3D; 1</li><li>P(“the” | “sat on”) &#x3D; 1</li></ul><p>所以输入为 “The cat”，预测下一个单词是 “sat” 或者 “ate”，他们的概率都是 1&#x2F;2。非常明显我们可以看出这种语言模型的缺陷：</p><ul><li>N 比较大时，训练数据中找不到足够的 n-gram 实例。</li><li>只能依赖前 N-1 个词。</li><li>每个词之间其实是有一定关联的，n-gram 模型没有体现出来。</li></ul><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>神经网络作为一种机器学习方法，在很多方面解决了基于统计学的语言模型问题，这里简单介绍下神经网络的原理：</p><h3 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h3><p>神经网络的基本计算单元，也被称作<strong>节点(node)<strong>或者单元(unit)。它可以接受来自其他神经元的输入或者是外部的数据，然后计算一个输出。每个输入值都有一个</strong>权重(weight)</strong>,权重的大小取决于这个输入相比于其他输入值的重要性。然后在神经元上执行一个特定的函数 <strong>f</strong>, 定义如下图所示，这个函数会该神经元的所有输入值以及其权重进行一个操作。 </p><p><img src="https://image.bdwms.com/e16a7218-c12d-40b4-9f1a-51407ba38912-20230705142119368-20230705144637212-20230709133153611.png" alt="img"> </p><p>f 是非线形函数给神经网络引入非线形，例如 Sigmoid: 输出范围是[0,1]，b 是偏置值bias： <img src="https://image.bdwms.com/531e8987-4ca1-4e48-aa66-b3c71298a153-20230705142119409-20230705144637246-20230709133153630.png" alt="img"></p><h3 id="前向神经网络"><a href="#前向神经网络" class="headerlink" title="前向神经网络"></a>前向神经网络</h3><p><img src="https://image.bdwms.com/09eace08-d8a4-45fb-b3f3-c954b6f20e43-20230705142119516-20230705144637324-20230709133153673.png" alt="img"></p><ol><li>输入神经元：位于输入层，主要是<strong>传递</strong>来自外界的<strong>信息</strong>进入神经网络中，比如图片信息，文本信息等，这些神经元不需要执行任何计算，只是作为传递信息，或者说是数据进入隐藏层。</li><li>隐藏神经元：位于隐藏层，隐藏层的神经元不与外界有直接的连接，它都是通过前面的输入层和后面的输出层与外界有间接的联系，因此称之为隐藏层，上图只是有1个网络层，但实际上隐藏层的数量是可以有很多的，远多于1个，当然也可以没有，那就是只有输入层和输出层的情况了。隐藏层的神经元会<strong>执行计算</strong>，将输入层的输入信息通过计算进行转换，然后输出到输出层。</li><li>输出神经元：位于输出层，输出神经元就是将来自隐藏层的信息输出到外界中，也就是<strong>输出</strong>最终的<strong>结果</strong>，如分类结果等。</li></ol><p>多层神经网络：拥有多个隐藏层</p><p><img src="https://image.bdwms.com/272c57bf-4eb4-456a-8485-97de82748c54-20230705142119568-20230705144637580-20230709133153834.png" alt="img"></p><h3 id="计算损失"><a href="#计算损失" class="headerlink" title="计算损失"></a>计算损失</h3><p>当数据传播到输出层后，我们会计算神经网络的输出与真实标签之间的差异（这也是为什么我们需要人工打标的训练数据集）。这个差异叫做损失，损失函数可以是平方误差、交叉熵等等。例如平方差：</p><p>L &#x3D; 0.5*(y - t)^2</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>根据损失来更新神经网络的权重和偏置，以使得损失最小化。这个过程叫做反向传播。在反向传播中，我们首先计算损失关于每个参数的偏导数（梯度），然后将参数沿着梯度的反方向更新，这样可以使得损失下降。这个过程通常使用梯度下降算法或者其变种来进行。</p><p>梯度下降：在数学中，梯度是一个向量，指向函数增长最快的方向。相反的方向则是函数下降最快的方向。因此，如果我们有一个需要最小化的目标函数（例如机器学习中的损失函数），我们可以使用梯度下降算法来一步步地移向函数值下降最快的方向，直到找到一个局部最小值（或在凸优化问题中，是全局最小值）。</p><p>梯度：∂L&#x2F;∂w L为误差，w为权重</p><p>梯度下降：w :&#x3D; w - η * ∂L&#x2F;∂w</p><h3 id="更新权重参数反复迭代"><a href="#更新权重参数反复迭代" class="headerlink" title="更新权重参数反复迭代"></a>更新权重参数反复迭代</h3><p>得到调整后的权重后，我们继续训练达到我们想要的效果，或者达到预设的迭代次数</p><h3 id="一个最简单的例子："><a href="#一个最简单的例子：" class="headerlink" title="一个最简单的例子："></a>一个最简单的例子：</h3><p>一个单层感知器，它只有一个输入节点和一个输出节点。</p><table><thead><tr><th>输入 (x)</th><th>权重 (w)</th><th>目标输出 (y)</th><th>预测输出 (y_hat)</th><th>损失</th><th>∂损失&#x2F;∂w</th><th>新的权重 (w_new)</th></tr></thead><tbody><tr><td>0.5</td><td>0.6</td><td>0.8</td><td>0.3</td><td>0.25</td><td>-0.5</td><td>0.65</td></tr></tbody></table><ol><li><p>输入 x &#x3D; 0.5 , 权重 w &#x3D; 0.6, 真实目标是 0.8，f(x) &#x3D; wx</p></li><li><p>网络输出为 y_hat &#x3D; 0.5 * 0.6 &#x3D; 0.3</p></li><li><p>损失函数是均方误差损失函数，即 (y - y_hat)^2。所以我们的损失 L &#x3D; (0.8 - 0.3)^2 &#x3D; 0.25。</p></li><li><p>我们可以计算损失函数关于权重的梯度链式法则展开，即 ∂L&#x2F;∂w &#x3D; 2 * (y_hat - y) * x &#x3D; 2 * (0.3 - 0.8) * 0.5 &#x3D; -0.5。</p></li><li><p>∂L&#x2F;∂w &#x3D; ∂L&#x2F;∂y_hat * ∂y_hat&#x2F;∂w</p></li><li><p>对于∂L&#x2F;∂y_hat，因为L &#x3D; (y - y_hat)^2，所以∂L&#x2F;∂y_hat &#x3D; 2*(y_hat - y)。</p></li><li><p>对于∂y_hat&#x2F;∂w，因为y_hat &#x3D; w * x，所以∂y_hat&#x2F;∂w &#x3D; x。</p></li><li><p>学习率（比如 0.1）来更新我们的权重，即 w_new &#x3D; w - 学习率 * ∂L&#x2F;∂w &#x3D; 0.6 - 0.1 * (-0.5) &#x3D; 0.65。</p></li></ol><p>这个表格中，”损失”是我们计算出的误差值，”∂损失&#x2F;∂w”是我们计算出的偏导数（也就是损失函数关于权重的梯度），”新的权重 (w_new)”是我们更新后的权重值。通过这样的不断迭代技能逼近于正确的权重 w，使得整个模型的输出更加符合打标数据结果。</p><h2 id="Word-Embedding-和-Word2vec"><a href="#Word-Embedding-和-Word2vec" class="headerlink" title="Word Embedding 和 Word2vec"></a>Word Embedding 和 Word2vec</h2><p>回头看一步，计算机能够处理的都是 01 序列这样的二进制流，那么我们怎么让计算机理解语言呢？最简单的就是给文本标号，从而将文本转换成数字，数字就是计算机方便处理操作的形式了。</p><p><img src="https://image.bdwms.com/d8a177a4-0f7c-42f4-a0e8-afa9d4804844-20230705142119620-20230705144637713-20230709133153856.png" alt="img"></p><h3 id="one-hot-编码"><a href="#one-hot-编码" class="headerlink" title="one-hot 编码"></a>one-hot 编码</h3><p>最简单的就是将事物与序号进行一一对应，这就是 onehot 编码，在二进制中表示如下图：</p><p><img src="https://image.bdwms.com/5c50913e-fd2e-4a92-9b47-bbbb1d2d1366-20230705142119698-20230705144637816-20230709133153879.png" alt="img"></p><h3 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h3><p>one-hot 编码有明显的缺陷，比如他没有考虑到两个词之间的含义关联，它们可能相似或者相反，这都没有体现出来；并且每个词都使用一位来表示，会造成维度爆炸的困难。而对于词嵌入：Word Embedding，就会进行考虑两个词之间的关系，并转换为数学意义，词义越近，空间中也越接近，如下图所示：</p><p><img src="https://image.bdwms.com/2260340d-fd1a-44ec-ba8b-270553fd27ac-20230705142119781-20230705144638110-20230709133153919.png" alt="img"></p><p>详细 word2vec 的数学原理可见：<a href="https://www.cnblogs.com/peghoty/p/3857839.html">https://www.cnblogs.com/peghoty/p/3857839.html</a></p><p><img src="https://image.bdwms.com/d437bd4f-4a48-4eb9-a11d-aa6f032c24ff-20230705142119855-20230705144638293-20230709133153950.png" alt="img"></p><p><img src="https://image.bdwms.com/347e4e4f-1532-4ce9-ac55-474dd2ed12c2-20230705142119955-20230705144638374-20230709133154013.png" alt="img"></p><p>词嵌入通过扣掉一个词或者扣掉词附近的词两种方式，利用神经网络来计算出合适的词向量（权重矩阵），从而更高的表达了不同词之间的关系，进行「降低维度」减少复杂度的操作。</p><p>但是词嵌入也有一些缺点：</p><ul><li>词顺序：“我爱你”，“你爱我”，对周围上下文词进行了平等处理，导致两个词向量肯能很相近，但是语义很不同。</li><li>一词多义：“我喜欢吃苹果”，“我喜欢苹果”，苹果只有一个词向量表示。</li></ul><h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><p>卷积神经网络（CNN）主要运用在视觉处理的方向中，参考了人类视力是如何识别物体的，跟本文的语言模型没有那么关联，这里不做过多的阐述，具体原理可以参考：<a href="https://www.cnblogs.com/wj-1314/p/9754072.html">深入学习卷积神经网络（CNN）的原理知识</a>。这里值得注意的是由于图片的训练集显然是不需要人工打标的，一个正常符合要求的图片就可以给模型训练，所以 CNN 的资料裤是远远多于 NLP 领域的训练资料，这也是后续 NLP 要解决的问题。</p><h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><p>循环神经网络（RNN）主要应用在 NLP 中。例如为了填好下面的空，取前面任何一个词都不合适，我们不但需要知道前面所有的词，还需要知道词之间的顺序。</p><p><img src="https://image.bdwms.com/42684521-3e02-4534-943a-14c9d2534d3c-20230705142120038-20230705144638708-20230709133154044.png" alt="img"></p><p>每次都会将前一次的输出结果，带到下一次的隐藏层中，一起训练：</p><p><img src="https://image.bdwms.com/708b3ebf-d209-42df-b646-a882fa501d8c-20230705142120114-20230705144638832-20230709133154106.png" alt="img"></p><p>前面的输出都对未来的输出产生影响：</p><p><img src="https://image.bdwms.com/8a84cf14-9a7f-476e-8ff1-be5abff3d3d6-20230705142120166-20230705144638892-20230709133154134.png" alt="img"></p><p>RNN 的缺点：RNN 只能记忆短期的；训练起来慢成本大</p><p><img src="https://image.bdwms.com/98fece4a-5fba-4a81-8332-87280101e0f5-20230705142120206-20230705144639151-20230709133154197.png" alt="img"></p><p>针对 RNN 进行改进的 lstm ：针对长序列中的重要信息保留，忽略不重要的信息。</p><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>来到 2017 年最终要的谷歌发布了 Transformer 模型，此后的语言模型基本都基于这一套体系来建立起来，其中最为主要的两个方面就是 Encoder-Decoder 模型，以及自注意力机制，这边我们简单阐述，详细解析见：<a href="https://www.zhihu.com/column/c_1210720016188190720">Transformer 零基础解析教程</a></p><h3 id="Encoder-Decoder模型"><a href="#Encoder-Decoder模型" class="headerlink" title="Encoder-Decoder模型"></a>Encoder-Decoder模型</h3><p>举个具体的例子，我们以翻译给定的输入句子 x 为例，通过Encoder-Decoder框架，最后生成目标句子 Y 。其中 X 和 Y 分别由单词序列构成</p><p>原始句子 X&#x3D;(x1,x2,⋯,xm)</p><p>翻译的目标句子 Y&#x3D;(y1,y2,⋯,yn)</p><p>Encoder任务就是对输入句子 X 进行编码，将输入句子通过非线性变换转化为中间语义表示 C ：</p><p>C&#x3D;F(x1,x2,⋯,xm)</p><p>Decoder任务就是根据句子X 的<strong>中间语义表示 C</strong> 和之前<strong>已经生成的历史信息 y1,y2,⋯,yi−1</strong> 来生成 i 时刻要生成的单词 yi 。</p><p>yi&#x3D;G(C,y1,y2,⋯,yi−1)</p><p>每个 yi 都依次这么产生，最终看起来就是整个系统根据输入句子 X 生成了目标句子 Y 。</p><p>Encoder-Decoder是通用的计算框架，Encoder, Decoder具体用什么模型，都可以自己选择。</p><p><img src="https://image.bdwms.com/f9ee4fbf-272c-4ba2-a906-a639fb5f9a90-20230705142120270-20230705144639279-20230709133154216.png" alt="img"></p><h3 id="自注意力机制"><a href="#自注意力机制" class="headerlink" title="自注意力机制"></a><strong>自注意力机制</strong></h3><p>对于一句话，其中的每个词之间都会有一定的关联，例如：<strong>I love cats because they are cute</strong></p><p><strong>cats 和 they 是有一定的关联的</strong></p><p>自注意力机制的工作原理是，它为输入序列中的每一个元素分配一个权重，这个权重取决于该元素与序列中其他元素的关系。这样，模型就可以更好地理解元素之间的依赖关系，从而更好地处理序列数据。</p><p>一段自然语言中，其实暗含了：为了得到关于某方面信息 Q，可以通过关注某些信息 K，进而得到某些信息（V）作为结果。</p><p>Q 就是 query 检索&#x2F;查询，K、V 分别是 key、value。所以类似于我们在图书检索系统里搜索「NLP书籍」（这是 Q），得到了一本叫《自然语言处理实战》的电子书，书名就是 key，这本电子书就是 value。只是对于自然语言的理解，我们认为任何一段内容里，都自身暗含了很多潜在 Q-K-V 的关联。这是整体受到信息检索领域里 query-key-value 的启发的。</p><ol><li><p>计算Query、Key和Value：首先，我们将输入的词向量（设为X）分别与三个权重矩阵W_q（Query权重矩阵）、W_k（Key权重矩阵）、W_v（Value权重矩阵）相乘，得到Query、Key和Value。计算公式如下：</p><p>Query &#x3D; X * W_q<br>Key &#x3D; X * W_k<br>Value &#x3D; X * W_v</p></li><li><p>计算注意力权重：接着，我们计算每个词的Query与所有词的Key的点积，然后通过softmax函数将点积的结果转换为概率分布，这个概率分布就是我们所说的注意力权重，反映了当前词与其他词在语义上的关联程度。计算公式如下：</p><p>注意力权重 &#x3D; softmax(Query * Key的转置)</p></li><li><p>计算输出：最后，我们将注意力权重与Value做加权求和，得到最后的输出。计算公式如下：</p><p>输出 &#x3D; 注意力权重 * Value</p></li><li><p>新的词向量根据损失函数和梯度下降等方法来进行更新 W_q, W_k, W_v 向量</p></li></ol><p>最终得到了一组最终的词向量，他们之间的关系更加符合他们之间语义的关联</p><p>Transformer模型：</p><p><img src="https://image.bdwms.com/23db0a52-2a63-4267-905d-d502d3bf1b9e-20230705142120336-20230705144639398-20230709133154264.png" alt="img"></p><h3 id="位置向量"><a href="#位置向量" class="headerlink" title="位置向量"></a>位置向量</h3><p>因为是没有像 rnn 那样的时间序列一样，而是可以并发的训练得到词向量，所以自注意力计算时没有考虑位置的因素，所以在词嵌入向量中添加位置向量，然后再代入训练中，就能保留位置信息。</p><h2 id="GPT-1"><a href="#GPT-1" class="headerlink" title="GPT-1"></a>GPT-1</h2><p>因为标注数据的代价巨大，NLP 中没有 CV 中那么多好的训练样本，所以在 GPT-1 中只使用 Decoder 来做自监督学习，基于自注意力机制，来进行预训练，从而学习到更深层次的语法和语义信息。比如给出一篇文章，他本身是没有打标的但是有一个天然的词语顺序，通过自注意力等处理，可以来获得每个词的合理词向量，其中包含了一定的语义。</p><p>之后GPT-1 接着使用了有标注的数据进行有监督的微调使得模型能够更好地适应下游任务。这样能够做到更高的通用迁移。GPT-1 的目标是学习到一个通用的自然语言表征，并在之后 通过简单调节适应很大范围上的任务。</p><p><img src="https://image.bdwms.com/b2fe8c88-7766-4c51-9a21-874ab2ac013a-20230705142120412-20230705144639790-20230709133154291.png" alt="img"></p><h2 id="Bert"><a href="#Bert" class="headerlink" title="Bert"></a>Bert</h2><p>和 GPT 不同的是 Bert 只使用了 Transformer 的编码器。Transformer 的编码器就像完形填空，在预测每个词时，是知道前后（过去和未来）的文本内容的；但是 Transformer 的解码器仅知道前面的文本（过去）来预测词，相当于在预测未来。</p><p>对于 GPT：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I -&gt; I accessed</span><br><span class="line">I accessed -&gt; I access the</span><br><span class="line">I accessed the -&gt; I accessed the bank</span><br><span class="line">I accessed the bank -&gt; I accessed the bank account</span><br></pre></td></tr></table></figure><p>对于 Bert，进行类似完形填空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I accessed the [MASK] account -&gt; [MASK]=bank</span><br></pre></td></tr></table></figure><h3 id="GPT-2"><a href="#GPT-2" class="headerlink" title="GPT-2"></a>GPT-2</h3><p>更大的数据集，以及一些优化，证明了其没有微调的情况下通过无监督学习也可以效果很好</p><h3 id="GPT-3"><a href="#GPT-3" class="headerlink" title="GPT-3"></a>GPT-3</h3><p>更大的模型参数，更大的数据集，暂时无法解释为什么这么效果这么好</p><h3 id="Prompt（In-Context-Learning）-和-思维链（Chain-of-Thought）"><a href="#Prompt（In-Context-Learning）-和-思维链（Chain-of-Thought）" class="headerlink" title="Prompt（In-Context Learning） 和 思维链（Chain-of-Thought）"></a>Prompt（In-Context Learning） 和 思维链（Chain-of-Thought）</h3><p>大模型的两个突出特征：ICL 和 CoT</p><p>一个预训练模型，在处理下游任务时，不微调模型参数，只需要在输入时加一些示例，就能有 SOTA 的表现，这就是模型的上下文学习（In-Context Learning，ICL）能力：</p><table><thead><tr><th>x</th><th>本周末周边自驾两天一夜，最推荐的地方？</th></tr></thead><tbody><tr><td>f(x)</td><td>我的所在地是&lt;杭州&gt;，请对下面这个问题给出 5 个不同的答案并且每个答案都带一条简短的理由：本周末周边自驾两天一夜，最推荐的地方？</td></tr><tr><td>y</td><td>南浔古镇，有保存完好的明清时期建筑；莫干山，远离城市喧嚣亲近大自然享受慢节奏的民宿生活；千岛湖，一边吃美味鱼宴一边赏着湖光山色水清鱼跃绝美的自然风光；乌镇，江南水乡特色韵味古镇建筑有着深厚的文化积淀；普陀山，佛教圣地有着浓厚的宗教氛围素有“海上名山”之称。</td></tr><tr><td>g(y)</td><td>1、对 y 中几条结果，查询天气、最新交通管制措施、游客接待政策等等（假设因此剔除了南浔古镇、千岛湖）；2、剔除用户已去过的目的地（假设用户已授权模型访问其旅游平台账户，剔除了普陀山）；3、对 y 的结果进行优化并保留推荐值最高的结果「莫干山 ……」并输出：莫干山，&lt;推荐亮点&gt;，&lt;天气&gt;，&lt;交通情况&gt;，&lt;推荐美食&gt;，&lt;推荐酒店&#x2F;民宿&gt;，&lt;推荐自驾路线&gt;。</td></tr></tbody></table><p>f(x) 就是 Prompt Engineering</p><p><img src="https://image.bdwms.com/fd309922-9702-465d-8437-55cced24a709-20230705142120457-20230705144639841-20230709133154326.png" alt="img"></p><p>思维链：Let’s think step by step</p><p><img src="https://image.bdwms.com/8515f1ed-e07a-4f97-8cc3-5fed440ec066-20230705142120571-20230705144640314-20230709133154367.png" alt="img"></p><h3 id="InstructGPT"><a href="#InstructGPT" class="headerlink" title="InstructGPT"></a>InstructGPT</h3><p>人工反馈的强化学习（Reinforcement Learning with Human Feedback)</p><p><img src="https://image.bdwms.com/ece353d9-3ad6-453d-845b-0dc656c720e6-20230705142120726-20230705144640809-20230709133154424.png" alt="img"></p><ol><li>第一步监督学习微调出一个模型A</li><li>第二步训练一个奖励模型B</li><li>第三步用奖励模型B通过强化学习训练第一步的模型A</li></ol><h3 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>和 InstructionGPT 训练数据和方法有有些区别，并且是对话式的</p><h3 id="PLam2"><a href="#PLam2" class="headerlink" title="PLam2"></a>PLam2</h3><p>谷歌的 LLM 也是基于 Transformer ，翻了论文基本没什么具体内容，主要强调的是训练数据不一样，更加基于人类价值观，更少的参数带来更高的性能 , Sec-PLam ，样本用安全相关的东西来训练的</p><ul><li>VirusTotal Code Insight 用 Sec-Plam 来解释哪些脚本存在威胁</li><li>Mandiant Breach Analytics for Chronicle利用 Google Cloud 和 Mandiant Threat Intelligence 自动提醒您环境中的活动漏洞。</li></ul><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>到这里为止，我们可以看到语言模型在最近几年的主要发展，在谷歌公开的 Transformer 模型基础上，OpenAI 进行不断的优化，更大的模型规模与参数，更优质与庞大的训练资料，让 LLM 从量变产生了质变，涌现出的能力为后来人指明了大语言模型方向的可能性。</p><p>但是我们也可以看到机器学习，深度学习越来越向工程化发展，很多时候并没有一个完备的数学理论作为基础，很多算法工程师进行模型设计时甚至无法说明为什么，很多通过实验来进行说明，模型的可解释性发展并没有跟上模型能力的发展，这在笔者看来也是一种遗憾，希望能够在未来我们能够不仅仅让模型「理解」我们，同时我们也能够「理解」模型。</p><p>最后，笔者坚信 AI 一定是未来提高生产力的必经之路，让我们期盼这科幻的未来吧！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.mikecaptain.com/2023/01/22/captain-aigc-1-transformer/">人工智能 LLM 革命前夜：一文读懂横扫自然语言处理的 Transformer 模型</a></p></li><li><p><a href="https://www.mikecaptain.com/2023/03/06/captain-aigc-2-llm/">人工智能 LLM 革命破晓：一文读懂当下超大语言模型发展现状</a></p></li><li><p><a href="https://m.douban.com/book/subject/25746399/">《统计自然语言处理》</a></p></li><li><p><a href="https://easyai.tech/ai-definition/word-embedding/">Word Embedding</a></p></li><li><p><a href="https://www.cnblogs.com/peghoty/p/3857839.html">word2vec 的数学原理</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/68624851">一文了解神经网络的基本原理</a></p></li><li><p><a href="https://www.cnblogs.com/wj-1314/p/9754072.html">深入学习卷积神经网络（CNN）的原理知识</a></p></li><li><p><a href="https://easyai.tech/ai-definition/rnn/">循环神经网络 – Recurrent Neural Network | RNN</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/40761721">反向传播算法的推理</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2022-成长之年</title>
      <link href="2022-summary/"/>
      <url>2022-summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2022，成长</p></blockquote><p>2022年，bdwms经历了很多，也成长了很多。</p><p>「成长」，是对过去一年的总结。成长在于很多方面，不仅仅局限在能力上的提高，更为重要的是心态平和健康以及思想上更加清晰明了。在面对更多不一样的事情，接触之前未曾感受的情感时，去感受，思考并抉择。成长在我的理解中是对自我价值的肯定与美好事物的追求，也因此我认可我的「成长」。</p><h2 id="关于目标"><a href="#关于目标" class="headerlink" title="关于目标"></a>关于目标</h2><p>在2022年度的 OKR 中，我总结了之前的经验将自己的目标设置的更为明确，并在一定程度上可以量化，同时选择性放弃非核心目标，将 O 目标聚焦于重点几个项目。在年初的 OKR 设计中，我主要设立几个方面，包括：</p><ul><li>杭州 E 类人才</li><li>熟练掌握移动端攻防技术</li><li>身体健康</li><li>了解理财知识并实践</li><li>形成一套知识流动体系（围绕日语）</li></ul><p>可以看到有的目标并不是很具象，并且伴随着实践，也可以发现内容更为明晰的目标，完成的效果也更好。22年主要也是从生活，工作，个人几个角度出发去设计自己的年度 OKR，并且不断的做修正于反馈。以「拿到杭州 E 类人才」为例，在22年初因为疫情导致考试取消，整个学习节奏也被打乱，综合评估下来后放弃了最后一个日语的 OKR，以保证整个与外界因素最为关联的 OKR 不被延误，最终也是花费了将近3个月的时间通过了软考高级。</p><p><img src="https://image.bdwms.com/FmqdhsY9IkY-es-oyzSjxJXGm7gd"></p><p>在 2022 年的阅读中，数量有一定程度的下降，时间不充裕以及内容深度都是原因，同时本年度的阅读计划尝试使用「主题阅读」的方法，想要通过更加成体系化的方式来构建自己的知识库。</p><p><img src="https://image.bdwms.com/FuIcRYAMnK60h288Zca6emH2kGD1"></p><p>整个阅读主要涉及的主题就是以技术和经济学为主，在技术领域选择了本职工作的移动端安全与自己感兴趣的区块链为主，同时因为软考还大量阅读了关于软件工程以及工程管理的内容，对于整个工作有了新的理解，这里在在后面展开来说。关于经济学，也是我比较感兴趣的部分，程序员作为工科职业十分缺乏这一部分的知识，这也会导致自己沦为单纯工具人的角色，这一部分我会单独一篇文章作为总结。</p><p>针对今年的 OKR，反思看来在大的方向上是正确的，但是在实践中遇到了很多问题，比如被工作内耗了大量精力，处理关系时不够成熟的无谓消耗等等因素。也因此暴露出很多自身没有发现的隐患，遭遇众多未曾面对的困难挫折，这也是我对「成长」的理解，发现问题是今年的主旋律，也是我长远规划中的第一步。成长不代表今天一定要比昨天更好，成长也可能是对从前的反思与深挖，对自身问题的深究与彻底理解。</p><h2 id="关于三观"><a href="#关于三观" class="headerlink" title="关于三观"></a>关于三观</h2><p>「人是一颗会思考的芦苇」，所以我总是觉得不应该浑浑噩噩的度过时间，总是需要一些飘在天上不那么现实的东西提醒自己，别忘记了自己是谁，想要什么，所以我准备从一些「虚」的方面开始，回顾过去一年经历对个人三观的影响，更加清晰的看看自己，看看这个世界。</p><h3 id="世界观"><a href="#世界观" class="headerlink" title="世界观"></a>世界观</h3><p><img src="https://image.bdwms.com/FtCJM9272XMzOss0PLWzF4u-f8w_"></p><p>「理解世界的方式，包括我们如何看待世界的本质，世界的起源和结构，以及我们在其中的地位。世界观是我们理解事物的基本原理和方法」</p><p>从我个人的角度来看，更加倾向于世界是唯物主义的，因为基于唯心主义来说明世界上其他的事物都是基于精神思想产生的固然可以一定程度上自洽，例如「我思故我在」。但是通过唯物主义的观察，实验去理解和解释世界目前看来也同样是自洽的，而偏向于唯物主义可以更加驱动我个人去探索与了解未知，产生驱动力与自我认可。通过精神至上去解释并慰藉某些困难并不能说服我，所以总结下来个人是唯物主义的。</p><p>衍生到计算机的领域，在我看来就是对这个世界部分事物的信息化提取与关系映射，对于人脑来说，计算系统的量级是巨大的，但是相对于整个世界来说却又是渺小或者说被包含的。人们通过对事物运行规律的观察，提取，总结与实践，完成一次唯物世界观下的逻辑自洽，而计算机就是一个经典而又简单的代表，信息化系统相较于其他唯物主义实践巧妙在于其足够的「简单」，在硬件不出故障（或者容错率在 n 个 9 的保障下），输入经过处理得到的输出是具有「可预见性」的。</p><p>因此信息化基于实体，也影响实体，通过各种决策途径产生不同的结果。作为计算机从业人员，较为幸运的在第三次工业革命中参与变革，需要较为小的生产资料，主要改变生产关系，提高生产效率，从而制造价值。我们采用理性与科学的态度去观察事物的发展，去抽象提炼用户关注的重点，基于计算机去处理数据，产生最终想要的结果。世界是物质的，计算机也是物质的，它站在各个学科的肩膀上，基于着数学，物理，材料，通信等学科的发展，厚积薄发才产生了当今如此磅礴的能量，所以我们更应该学会敬畏与合理的利用计算机，抓住机会，去创造一些有趣的东西。</p><p>总结一下，我尊重世界是物质的，愿意怀着敬畏去科学理性的认识世界并寻找创造一些美好的事物。</p><h3 id="人生观"><a href="#人生观" class="headerlink" title="人生观"></a>人生观</h3><p><img src="https://image.bdwms.com/FpWQSu5uVOzRm4zdjeLc0WJlyekB"></p><p>「对人生的理解和态度，包括我们认为一个好的生活是什么样的，我们的生活目标是什么，以及我们如何实现这些目标。人生观涵盖了我们对于生命、死亡、成功、失败等主题的看法」</p><p>生活的意义和目标是什么？在我看来生活可以没有绝对的意义，但是一定需要一个前进的目标，这样才能像大航海一样有趣，开始于出生之地，终结于永恒的寂静，在这一段过程中要做的就是去破开迷雾，登岛寻宝。我们所追寻和重视的是指引我们的星辰，所以一定要常常提醒自己莫忘本心，这也是在正式迈入社会后需要重视的，毕竟太多人被生活锤得眼冒金星，晕头转向的度过每一天。</p><p>那么仔细回想，将自己在乎的逐一筛选，我认为最为重要的是生命与健康。因为我是坚定的唯物主义者，所以我认为一切意志活动，一切欲望与追求都是建立在拥有一个健康的身体和心灵。年轻人常常放纵不重视自己的身体健康，透支在许多眼前的事情，但是就像掉落的牙齿不会再重新长回来一样，浪费的生命永远无法追回，所以别太劳累了。</p><p>生活的价值体现在哪些方面？我个人着重于创造美与体验乐趣，在现代社会中处处存在比较与竞争，有时太过去注重比较的结果，但是占据绝大多数时间的过程却被忽略，我更希望能够在每一时刻都能去享受，一定程度上的失败或者成功都只是波函数的上下起伏，只要我没有停下，那么就只是继续罢了。我们伴随时间在成长，并经历着不同的事情，人与人之间应该共同经历了某些事情而有了羁绊，于是便有了独一无二的一份关系，「百年修的同船渡」大概就是这个道理，所以我想更应该珍惜与尊重过往的经历，认认真真过好当下的日子，想做什么就做什么，无论是舒舒服服的躺着还是咬紧牙去努力都是可以的，生活没有意义，生活就是意义。</p><p>再念想思考一下，人与人之间相逢，好似流星相遇，过去一年遇到很多会发光的人，我很开心能够如此幸运去感受不一样的情感，去参与很多事情，无论是好是坏。不过天下没有不散的宴席，人终有一别，有些朋友伴随着生活工作的变迁渐渐走远，甚至走去了遥远的地方，但我希望大家都能够幸福快乐，唯有祝福珍惜。</p><p>人生百态，好好珍惜。</p><h3 id="价值观"><a href="#价值观" class="headerlink" title="价值观"></a>价值观</h3><p><img src="https://image.bdwms.com/Fu6tXwfZJZlbCPnbkvKT_P_8ey8x"></p><p>「这是我们对好与坏，对正义与不正义的基本判断。价值观影响我们如何评价自己和他人的行为，以及我们在道德和伦理问题上的立场」</p><p>一个事物本身并不具有价值高低，当人们站在自己的立场上有了个人倾向后，价值才凸显出来。我们做的每个决定，都基于了自己的价值取向，个人优先还是集体利益，成功与失败的定义，道德和伦理等等都建立于此之上。那么对于我来说，什么是有价值的，对谁有价值呢？</p><p>首先明确的，价值的定义一定是从个人视角出发，但是也一定会考虑到集体，毕竟人是社会生物，所以在做选择时考虑到个人利益优先的同时，也需要尽可能的让整体朝向一个好的方面发展。所以我认为「做大蛋糕」时价值高的，局限于「分蛋糕」是价值低的，「创造好的事物」是价值高的，「重复无意义的」是价值低的，「长期的」是价值高的，「短视的」是价值低的。回顾看来工作生活中更要去重视自己认为「价值高的」事物，它可不是公司又或者是谁给你身上安排的任务，这也是我们有时做事能够精神饱满的终极奥义吧。</p><p>阿里巴巴有着自己的价值观，那是对公司有意义，有「价值」的，但是个人来说还是要拥有自己的判断，去明白什么是自己的追求，莫忘本心，不要放弃自己去做这一行的最初目的，这样子才不会遇到困难时感到迷茫。</p><h2 id="关于成长"><a href="#关于成长" class="headerlink" title="关于成长"></a>关于成长</h2><p><img src="https://image.bdwms.com/WechatIMG63.jpeg" alt="WechatIMG63"></p><p>过去一年零零碎碎的一些思考，挑选了几个自己感觉比较重要的谈谈</p><h3 id="放轻松"><a href="#放轻松" class="headerlink" title="放轻松"></a>放轻松</h3><p>「生死无大事」，今年对此感悟更加深刻，一个唯物的现实主义者还是坚信生命是第一重要的，每个人来到这个世界只有短短的几十年，若是不能好好珍惜所经历的事情那也太过可惜了。所以自己的生活一定要以身体和心理健康为第一要义，长期损害健康的行为一定不要做，并且遇到的各种 xx 事情也别放在心上，带上过重的负担去生活反而会浪费自己的快乐能量。</p><p>但是我也想告诉每个人，如果真的遇到什么问题，请一定要向自己的家人朋友或者专业人士求助，不要害怕不要拖延自己的问题，每每想到因为这些小小的理由或者阻碍带给人们的障碍与不幸，我就感到难过与可惜，我也希望能在社会发展的道路上能看到更多的幸福，有机会的话也能做出自己的一点努力。</p><h3 id="像经营公司一样经营自己"><a href="#像经营公司一样经营自己" class="headerlink" title="像经营公司一样经营自己"></a>像经营公司一样经营自己</h3><p>今年读了一本程序员中比较有名的书《软技能—代码之外的生存指南》，整本书大概描述了一个程序员在工作中除了编程外值得注意的，包括人际关系，身体健康。但是其中我记忆最为深刻的是这句话：像经营公司一样经营自己。这让我有那么一些震惊，虽然之前一直都了解作为资本压榨下的劳动者，生产的再多价值也会被资本掠夺，那么通过更多埋头苦干获得的收益实在低到可怕。但是我一直没有得到一个准确的定义该去如何改变自己的心态，大致了解了这一章节的内容后，帮助我理清了一部分的思路。</p><p>什么是像经营一家公司一样经营自己。我想主要有几个方面可以来比喻：</p><ol><li>利益优先：公司以公司利益优先，那么个人也应该以个人利益优先，在面对不可调和矛盾是这样，在处于温水煮青蛙的环境中也需要注意，不能干了苦活累活没有成长，这是性价比极其低并应该尽力避免的情况。</li><li>专注产品：需要像打磨一件产品一样打磨自己，销售自己。你的目标市场在哪里，目标客户是谁，你的优点是什么，与其他人相比你的竞争点在哪里，整个的生命周期是怎么样的。</li><li>……</li></ol><h3 id="做一个分享型的人"><a href="#做一个分享型的人" class="headerlink" title="做一个分享型的人"></a>做一个分享型的人</h3><p>在经历了两年的工作生活，回忆思索了下什么样的事情会让我充满激情感到快乐。我的答案是：分享。在自己对外输出能力，分享快乐时我花费精力与时间时快乐的，并且充满效率，自己的文章能够被别人引用，解答别人的疑惑时是充满自豪感的。我也认同开源精神，虽然很多人说程序员是傻子不会设置门槛，但是我想正是因为开源社区，共享精神才推动了整个软件行业的飞速发展，通过协作促进生产力的大爆炸这正是我认可的「做蛋糕」行为，所以我坚定并希望在未来的三年内能成为一个分享型的人，通过自身带动别人，乃至一个社区。</p><h3 id="站在别人的立场思考问题"><a href="#站在别人的立场思考问题" class="headerlink" title="站在别人的立场思考问题"></a>站在别人的立场思考问题</h3><p>这件事情说起来容易，做起来难，因为站在别人的角度思考问题意味着需要临时性的「杀死自己」，抛开固有经验和情感去带入别人对我来说还是非常困难的，虽然我能够非常轻松的感知别人大致的情感，但是去更加深入的带入确实难的。但是我知道这也是我应该并且想要去更深化的一方面，去更好的体验去思考，有助于我和我身边的人，这点我正在努力。</p><h3 id="好记性不如烂笔头"><a href="#好记性不如烂笔头" class="headerlink" title="好记性不如烂笔头"></a>好记性不如烂笔头</h3><p>最后为什么有这一条？因为很多我灵光一现的想法因为没有记录忘记了……</p><p>还有太多的零碎感悟与想法在一点一点改变我的性格和行为模式，我希望在下一年中能够更加系统化的记录并展现出来，明年见。</p><h2 id="尚未结束的最后"><a href="#尚未结束的最后" class="headerlink" title="尚未结束的最后"></a>尚未结束的最后</h2><p>尚未结束的最后，尚未结束的冲动，还想再多看看这个该死的世界！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经济学小白的自我修养</title>
      <link href="an-economic-journey-in-2022/"/>
      <url>an-economic-journey-in-2022/</url>
      
        <content type="html"><![CDATA[<blockquote></blockquote><p>经济学是一门深奥复杂的学科，普通人很难深入的理解并掌握其中的复杂理论。但是笔者认为每一个人都应该形成一套属于自己的「经济学世界观」，其并不需要也不可能完全正确，这一套理论最核心的目标是能够在总体框架上自圆其说 ，并能在生活中给予一定的指导，从而避免仅凭直觉去抉择。在笔者的观念中，生活就是一场有趣的游戏，追求结果的同时更应享受过程，而如何了解规则参与游戏就是及其重要的，进一步衍生出形成自己的价值消费观也就理所当然了。</p><h2 id="宏观了解：经济学原理"><a href="#宏观了解：经济学原理" class="headerlink" title="宏观了解：经济学原理"></a>宏观了解：经济学原理</h2><p>因为精力有限，关于经济学基础理论，笔者还是选择了最常见的入门教材，大致阅读并学习了曼昆的《经济学原理》微观、宏观两册，回顾了马克思主义经济学，并衍生阅读了部分米什金的《货币金融学》，算作对于经济学理论的浅尝辄止。</p><p>曼昆的《经济学原理》主要从微观（单个市场中的生产，消费个价格等方面）和宏观（国民收入，通货膨胀，财政等方面）两部分出发，从个人生活中直接涉及的经济行为拓展到国家社会层面的经济活动，结合一些简单的数学推导来形成并证明</p><h2 id="社会观察：一些在中国的实践"><a href="#社会观察：一些在中国的实践" class="headerlink" title="社会观察：一些在中国的实践"></a>社会观察：一些在中国的实践</h2><h2 id="个人实践：如何"><a href="#个人实践：如何" class="headerlink" title="个人实践：如何"></a>个人实践：如何</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> 经济学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>信息项目管理师资管考试通关指北</title>
      <link href="information-technology-project-management-professional/"/>
      <url>information-technology-project-management-professional/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于软考通关的总结</p></blockquote><p>承接上文《<a href="https://bdwms.site/information-database-talent/">自建情报库-人才篇</a>》关于杭州人才的调研，笔者在 2022 年度的一个重要 OKR 就是通过信息项目管理师资格考试，也就是俗称的软考高级。因为疫情反复导致上半年的考试取消，笔者经过在工作中见缝插针的学习，最终在 11 月的考试中顺利通过考试。在软考学习中，笔者除了回忆起应试教育的枯燥重复，也与自己的工作两相对照进行了一定程度的深化思考，反思了自己与身边组织关系的缺陷和优点，也对项目管理以及软件工程有了更进一步的理解，这一份的总结暂时放在下一篇文章中与读者分享，本文还是对整个软考进行功利化的总结。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>考试时间：每年 5，11月左右考试，相应的 2，7月开始报名。</li><li>备考时间：短则 2 个月，长则 3 到 4 个月，每天花费 1-2 小时，周末每天 4 到 6 小时不等</li><li>考试题型：三门考试，每门 75 分，45 分及格，要求三门考试同时及格。每年通过率在 10% 到 20%，但是有大量弃考人员。<ul><li>上午：150 分钟综合知识。选择题，包含知识记忆类，计算类以及 5 题英文题，熟悉知识点并刷题后很好通过。</li><li>下午第一门：90 分钟案例分析。一般为 3 题，每一题给一个案例进行分析，问题可能包括改错，知识点记忆类，以及计算题。熟悉知识点并刷题，同时注意答题拿分技巧后也不难通过。</li><li>下午第二门：120 分钟论文。往年给两个题目然后考生自行挑选一题进行撰写，但是从 2022 年开始都是只给一个题目，导致难度上升不少。熟悉知识点，结合自身项目经历进行撰写，重点注意论文结构（类似八股文），以及论文子问题（这里导致了不能直接默写准备好的论文，需要具体问题具体讨论）。三门中难度最大，灵活度最高，但是体现复习好知识点，准备好论文结构，再结合一点运气，一般也能通过。</li></ul></li></ul><h2 id="考试准备"><a href="#考试准备" class="headerlink" title="考试准备"></a>考试准备</h2><h3 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h3><p>笔者买了一堆书，但是发现基本都没什么用，直接淘宝100元购买的网课「西方老师」，知识点主要是通过 PPT 和网课资料大纲学习，看遇到不懂的再去看视频，这样可以节约大量时间。</p><p><img src="https://image.bdwms.com/Fj6e_3IoasGDoCkpiE2vLE2hPFrJ"></p><p>软考重点知识点为「十大管理」，其余还包括信息化与信息系统，合同，配置，安全等管理过程，以及延伸出来的计算题专题和论文专题。</p><p><img src="https://image.bdwms.com/FjdtumgQTuTH_U4zPQmyR5jFt7Xn"></p><h3 id="学习周期"><a href="#学习周期" class="headerlink" title="学习周期"></a>学习周期</h3><ul><li>第一轮：过知识点。因为疫情原因 22 年上半年考试取消，所以笔者知识点分两次过完的，加起来可能一个月左右。对于程序员很多概念都是已经知道的，所以学习起来很快，重点需要关注的是十大管理，把其中不懂的知识点啃掉就行，其他的可以浏览过就行，不要浪费时间过度纠结。</li><li>第二轮：开始刷题。边刷题边熟悉知识点，主要刷选择和计算题。选择题刷了网课的题目书，大概 1000 题左右，重点关注第一部分信息化，以及十大管理的题目内容。计算题跟着网课过一遍基本的类型套路，记住计算题的公式，然后就是刷题，历年真题一定要刷完，一定要自己亲自动手算出来！不要以为会了就可以，一定要自己手算出来答案。</li><li>第三轮：背书。先背五个过程组与十大管理的关系，然后背十大管理的输入，输出，工具与技术，这块要滚瓜烂熟，，背诵要达到给出一个过程名就能说出 80%到 90%的输入输出和工具。十大管理背熟后就是去结合具体题目去理解各个过程的关系，刷案例分析题，这里可以参考大纲和教学视频中的拿分技巧，把真题刷完，常见问题要学会套模板回答。</li><li>第四轮：作文。基础知识打牢背熟的情况下，作文准备其实很快，提前一周的一个周末就可以，但是推荐程序员多练练字，毕竟平常都是敲键盘。作文准备一定不要自己想当然，要按照套路来写，具体可以看教学视频，然后可以提前准备好论文，但是写的时候不要照搬，因为会有灵活的子问题，笔者考试前准备了十大管理中的大半，并且手写的唯一一篇正好压中了题目，最后压线过，作文这里最为侥幸。总结下来还是要多准备，多看高分作文怎么写的，自己提前按照教学准本。<br><a href="https://www.yuque.com/bdwms/utu176/kpneeg?singleDoc">论文备考准备</a></li><li>第五轮：冲刺复习。笔者其实就是不断复习十大管理，与计算题公式，然后刷刷计算题保持手感，作文已经提前准备好了。</li></ul><h2 id="考中体验"><a href="#考中体验" class="headerlink" title="考中体验"></a>考中体验</h2><p>因为 2022 上半年考试取消，导致下半年人数比较多，笔者考场缺考的人数可能只有四分之一，大多数年龄感觉在三十岁左右，考试时候一定要带好身份证，准考证， 笔者考场就有遇到没带身份证不让考试的考生。</p><p>上午选择题考完还有很多时间，笔者大致估算了有把握的题目已经能够及格。下午案例分析比往年题目难一点，题量比较大，计算题也稍微绕一点，写完还剩十分钟左右，感觉上都做出来，7成把握能过。下午作文拿到题目为质量管理，正好押中考前当晚唯一手写的一篇题目，也是辅导机构押题命中，到后还剩30分钟左右，其中一个子问题比较偏没有太大把握，但是觉得总体还是符合预期，但是字迹潦草，考后觉得这是扣分点。</p><p>一整天考试后，综合评估下来自己通过考试概率为七到八成，还是算比较有把握的。</p><h2 id="考后总结"><a href="#考后总结" class="headerlink" title="考后总结"></a>考后总结</h2><p>最终经过一个多月等待出成绩后，通过了本次 2022 下半年度的信息项目管理师资格考试。综合知识和案例分析没有什么偏差，论文还是较为惊险，所以后续读者在准备的时候还是需要多多用心提前准备好论文，才能更加稳定通过考试。</p><p><img src="https://image.bdwms.com/FtB7lUfX5_dX10wKdRm_RWv8MYRY"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人月神话</title>
      <link href="the-mythical-man-month/"/>
      <url>the-mythical-man-month/</url>
      
        <content type="html"><![CDATA[<blockquote><p>人月神话</p></blockquote><h2 id="软考总结"><a href="#软考总结" class="headerlink" title="软考总结"></a>软考总结</h2><p>备考时间：3个月左右</p><p>备考资料：西方老师</p><p>选择，问答，论文</p><p><img src="https://image.bdwms.com/Fnl9A1qVuwZJw_S200BKTiS3oZdL"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈区块链（二）-以太坊基础</title>
      <link href="block-chain-2-eth-basic/"/>
      <url>block-chain-2-eth-basic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>The foundation for our digital future</p></blockquote><p>比特币作为第一个可靠的去中心化方案，将区块链技术首次运用在金融货币领域中。此后，人们试图将区块链技术应用于其他领域，2013年 Vitalik Buterin 发布了以太坊白皮书，提出了赋予区块链可编程能力，从而作为复杂商业逻辑运算的基础。白皮书中描述了基本协议栈与智能合约的框架，在语言层面实现了图灵完备，让以太坊真正具有了可编程能力，也让区块链世界进一步拓展。</p><p>以太坊继承了比特币的核心思想，例如分布式去中心化，无须信任系统，不可篡改等特性，围绕着如何更好更广阔利用区块链技术进行发展。以太坊中涉及的技术面非常广，在本文中主要围绕着两个核心技术「智能合约」和「POS」进行讲解，带领读者初步了解以太坊实现的原理以及以太坊的愿景所在。</p><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>20 世纪 90 年代，Nick Szabo 首次提出了智能合约的理念，这是一种旨在以信息化方式传播、验证或执行合同的计算机协议。但是由于缺少可信的执行环境，智能合约并没有被应用到实际产业之中。随着区块链的诞生，人们认识到其独有的特性天生为智能合约提供了可信的运行环境，而以太坊就是第一个成熟将两者结合起来的项目。</p><h3 id="图灵完备和-EVM"><a href="#图灵完备和-EVM" class="headerlink" title="图灵完备和 EVM"></a>图灵完备和 EVM</h3><p>对于比特币，我们之前知道他的转账过程 UTXO 其实简化来看就是一个入栈出栈的过程，它不支持循环语句，从而避免产生循环交易等恶意攻击，但这样比特币也不是 <a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7">图灵完备</a> 的。以太坊支持了循环等操作，并能够在自定义的虚拟机中运行，由此成为图灵完备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y(S, T)= S&#x27;</span><br></pre></td></tr></table></figure><p>给定一个旧的有效状态 S 和一组新的有效交易 T，以太坊状态转换函数 Y 产生新的有效输出状态 S’，因此以太坊不仅仅是一个分布式账本，而是更像一个分布式状态机。</p><p>正如 Java 程序通过编译为字节码后运行在 JVM 虚拟机上从而抹平不同硬件的区别，统一执行环境。以太坊也类似创建了一个虚拟机 EVM 来对智能合约的代码进行运行，EVM 基于堆栈，定义了各种基本操作码从而执行智能合约的逻辑。</p><p><img src="https://image.bdwms.com/FtZmoMXjSEnpgr1ekri6TNza_YIF"></p><h3 id="Gas-机制"><a href="#Gas-机制" class="headerlink" title="Gas 机制"></a>Gas 机制</h3><p>智能合约的每次计算都会消耗 Gas, 每次计算都需要收费，这样可以防止不良参与者对网络造成垃圾信息。 为了防止代码中出现无意或恶意的无限循环或其他计算浪费，要求每个交易对代码可以执行的计算步骤设置一个限制。</p><p>发起智能合约调用方会设置一个最大 Gas 限度，调用智能合约会消耗 Gas，如果顺利执行完，未使用完的 Gas 会退回给提交方：<code>max fee - (base fee + tip)）</code>，如果调用产生异常或者最大 Gas 不够的话，执行失败，这些Gas会奖励给矿工。</p><h3 id="智能合约的过程"><a href="#智能合约的过程" class="headerlink" title="智能合约的过程"></a>智能合约的过程</h3><ol><li>智能合约对外也是一个账户的形式。存储有余额，智能合约的代码，以及该账户的状态数据。</li><li>部署智能合约：发起一笔不指定任何人的交易，其中包含了 Gas 费用和编译好的智能合约字节码，这就创建了一个合约账户（一般根据创建者的地址和nonce来决定合约地址）</li><li>调用智能合约：向智能合约地址发起一笔交易，带上调用参数，和费用 Gas等信息</li><li>执行智能合约：智能合约地址收到交易，解码传参执行函数，进行状态转换，执行完后扣除相应的 Gas。</li><li>同步结果：状态转换的结果会全网同步并验证，确保一致后记录到区块中，并更新状态数据</li></ol><p>基于区块链中的去中心化，透明，不可否认的特性，形成了智能合约的可信运行环境，催化了区块链应用技术的进一步发展。</p><h2 id="从-POW-到-POS"><a href="#从-POW-到-POS" class="headerlink" title="从 POW 到 POS"></a>从 POW 到 POS</h2><h3 id="回顾POW"><a href="#回顾POW" class="headerlink" title="回顾POW"></a>回顾POW</h3><p>关于比特币的核心算法 POW 在上文 <a href="https://bdwms.site/block-chain-part-one/">浅谈区块链（一）—比特币</a> 中已经进行了详细解释，这里不再赘述，简单看下 POW 的优缺点</p><table><thead><tr><th>POW 的优点</th><th>POW 的缺点</th></tr></thead><tbody><tr><td>算法简单</td><td>耗电，浪费能源</td></tr><tr><td>容易验证</td><td>矿池聚集算力，形成垄断</td></tr><tr><td>攻击成本大（51%攻击）</td><td>为了避免分叉概率过大，无法降低难度，也就是无法降低出块速率，也就是无法提高<strong>交易频率</strong>。</td></tr></tbody></table><h3 id="POS-与币龄"><a href="#POS-与币龄" class="headerlink" title="POS 与币龄"></a>POS 与币龄</h3><p>POS：Proof of Stake 股权证明</p><p>我们知道 POW 挖矿的基本原理是，暴力寻找一个 nonce，使得 <code>Hash (block_header) &lt; Target</code> 成立，对于全网的所有矿工的 Target 都一样，所以就是比每个矿工的算力，算了越强挖出矿的可能性也越高。</p><p>而对于 POS 公式可以简单理解类似为：<code>Hash(block_header) &lt; Target * CoinAge</code>，而 CoinAge &#x3D; 持有币数量 * 持有币的时间，举个例子：</p><p>全网目标值 4396，A 矿工币龄为 15，B 矿工币龄为 240，那么两个矿工的计算公式分别为：</p><ul><li>A: Hash(block_header) &lt; 0x0000FFFF</li><li>B: Hash(block_header) &lt; 0x000FFFFF</li></ul><p>B 直接少了个 0 ，所以 B 获得记账出块的概率肯定要比 A 大，从竞速计算到概率的计算，这显然节省了大量的能源。所以我们有了基本的方法去决定谁来记账出块，并获得记账的奖励。</p><h3 id="Nothing-at-Stake-和-Casper-算法"><a href="#Nothing-at-Stake-和-Casper-算法" class="headerlink" title="Nothing at Stake 和 Casper 算法"></a>Nothing at Stake 和 Casper 算法</h3><p>在 POW 中最长链决定了哪些区块是被确认的，在 POS 中新的区块经过广播后，经过验证人投票验证，获得投票量超过 2&#x2F;3 质押总量（不是投票人数量），则验证通过后，区块就得到了确认。</p><p>但是基础的 POS 没有例如 POW 那样有大量的挖矿成本（大量的Hash运算），那么当一个验证者遇到分叉（由于网络，恶意传播等）时，因为没有什么挖矿成本，那么他就可以同时在多个链上进行挖矿&#x2F;投票验证来保证其获得最大的利益，造成链的系统混乱也就是 Nothing at Stack 问题，以及非常容易产生的 <a href="https://k.sina.com.cn/article_6487081523_182a9023302000i5sm.html?from=tech">双花问题</a> :</p><p><img src="https://image.bdwms.com/FoI1zVDkihg5rEPHjyOilccu7oNH"></p><p>为了解决这个无成本攻击的问题，以太坊设计了 Casper 算法来进行处理。简单来看就是通过质押资产来参加挖矿，当验证者挖矿投票时有恶意行为和消极行为就会进行处罚。</p><p>Casper的两条铁律是：</p><ul><li>验证者不得发布同属与同一个高的的两个不同投票。</li><li>验证不能在已投票的区间内再次投票。</li></ul><p>当不超过 1&#x2F;3 的总押金的的验证者违反这两个条件之一，就能得到Casper ffg的两个特性：</p><ul><li>不可能确认两个冲突的的检查点</li><li>保证了合理的活性</li></ul><p>当违反这两个铁律，那么违规验证着就会被罚没所有的押金（具体实现会有所不同，比如是根据全网恶意节点的数量来做处罚大小的调整），押金的价值是远远大于挖矿的收益的，从而避免了无成本攻击的问题。</p><p>具体证明：<a href="https://zhuanlan.zhihu.com/p/577753178">Casper the Friendly Finality Gadget</a> 和 <a href="https://v.qq.com/x/page/f07704nx4iq.html">详解Casper FFG共识算法</a></p><blockquote><p>设 a[m]（有合理的直接孩子 a[m + 1]）和 b[n]（有合理的直接孩子 b[n + 1]）是不同的最终检查点，如图 3 所示。现在假设 a[m]和 b[n] 冲突，并且不失一般性 h(a[m]) &lt; h(b[n])（如果 h(a[m]) &#x3D; h(b[n])，则很明显 1&#x2F;3 验证者违反了条件I【译者注：这里解释一下：投票要求 2&#x2F;3 多数才能定下 a 或者 b，既然现在两个都被确定了，说明总共有 4&#x2F;3 的投票，那么必然有 1&#x2F;3 的验证者投了重票】）。设 r→b [1]→b [2]→···→b [n] 为检查点链，使得存在绝对多数链 r→b [1] ,… b [i]→b [i + 1] ,… b [n]→b [n + 1]。 我们知道没有 h(b[i]) 等于 h(a [m]) 或 h(a[m + 1])，因为这违反了属性（iv）。 令 j 为使得 h(b[j]) &gt; h(a [m + 1]) 的最小整数，那么有 h(b[j -1]) &lt; h(a[m])。 然而，这意味着存在从具有小于 h(a[m]) 的纪元数的检查点到具有大于 h(a[m + 1]) 的纪元数的检查点的超大多数链接，这与从 a[m] 到 a[m + 1] 的绝对多数链不兼容。【译者注，也即违反了条件2】</p></blockquote><p>检查点的投票过程类似于：</p><ol><li>r 根节点默认合理 justified 的，然后 r 到 b1之间的验证者投票，总量超过 2&#x2F;3，b1 之间的变为合理的。</li><li>同理 b2 得到 b1 到 b2 之间的验证者超 2&#x2F;3 投票，则 b2 变为合理的，同时 b1，以及 b1 到 b2 之间的节点变为确认的（也就是不可否认的，除非有超过 1&#x2F;3 总量的恶意攻击）</li></ol><img src="https://image.bdwms.com/FoeyU1Lxcu6ZqTJraGt-JJ7sdjxg" style="zoom:50%;" /><p>当离线的投票人超过 1&#x2F;3，那么没办法投票超过 2&#x2F;3 没发最终确认，以太坊通过处罚减少离线的验证者的质押，逐渐让在线质押重新大于 2&#x2F;3</p><h3 id="分叉选择和-LMD-GHOST-算法"><a href="#分叉选择和-LMD-GHOST-算法" class="headerlink" title="分叉选择和 LMD-GHOST 算法"></a>分叉选择和 LMD-GHOST 算法</h3><p>Casper算法只是告诉了我们如何最终确认，但是没有告诉我们如何选择哪条链。对于网络延迟，或者有不诚实的区块创造提议这，则会产生分叉（同时以太坊的出块频率远远高于比特币，所以更容易产生分叉，如果依然采用最长连规则，那么必然需要有人放弃自己的利益），对于以太坊采用的是 GHOST 算法：</p><ul><li>对叔块进行一定的奖励来鼓励小分叉的矿工放弃，例如：W1 获得 B1 作为叔块的出块奖励 5 * 7 &#x2F;8</li><li>同时自己也获得了接受叔块的奖励，例如：W0 获得 C 的 5（挖矿）+ 接受两个叔块（5 * 1&#x2F;32）*2 + 交易费用</li></ul><p><img src="https://image.bdwms.com/FvIrFbBZQiBCG5hn33hCLpzMSBVP"></p><p>由此，小矿工也能获得利益，可以迅速让分叉合并回去，不在自己的分叉链上继续挖矿了。Ghost本身是在1.0使用。</p><p>在2.0后增加了 LMD，也就是验证者只接受最新的一条消息，也就是在 POS 中接受最重权重的链是权威链</p><p><img src="https://image.bdwms.com/Fux4ktsmAXhRC3AjruUH7KQ8GMfr"></p><h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>通过以上各种的算法设计，以太坊也逐渐从 POW 挖矿算法迁移到更具未来可行性的 POS 算法，让以太坊智能合约生态更加繁荣，为了将以太坊带入人们的主流视野以造福全人类，以太坊团队努力让以太坊变得更可扩展、更安全和更可持续。各种新技术也在融入以太坊中，分片存储、零知识证明、协议去中心化等等技术得在探索中不断发展，所以对于致力于建设去中心化世界的极客们，未来依然有着无限的可能！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/577753178">Casper the Friendly Finality Gadget</a></li><li><a href="https://v.qq.com/x/page/f07704nx4iq.html">详解Casper FFG共识算法</a></li><li><a href="https://arxiv.org/pdf/2003.03052.pdf">Combining GHOST and Casper</a></li><li><a href="https://developer.aliyun.com/article/679583">以太坊 GHOST协议</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈区块链（一）—比特币</title>
      <link href="block-chain-1-bitcoin/"/>
      <url>block-chain-1-bitcoin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>The Times 03&#x2F;Jan&#x2F;2009 Chancellor on brink of second bailout for banks.</p></blockquote><p>2008 年金融危机的海啸席卷全球，同年 11 月，化名中本聪的「神秘人」发表了论文《比特币：一种点对点式的电子现金系统》（<em>Bitcoin: A Peer-to-Peer Electronic Cash System</em>），并</p><p>在次年挖出了第一个区块同时获得了 50 比特币的奖励。这一创世区块中，中本聪写下了本文的开头「2009 年 1 月 3 日，财政大臣正处于第二轮银行紧急援助的边缘」，这也是当日《泰晤士报》的头版文章标题。</p><p>一个新的时代就此诞生，而笔者将通过这篇文章从最基本的货币交易切入，围绕着比特币的重要特性，最终深入去中心化的思想。本文尽量从设计的角度出发，精简出区块链的核心理念，避免让读者过度纠结于实现细节或可以作为参考资料的前置知识。那么现在就让我们进入一个神奇的共识世界！</p><h2 id="货币之困"><a href="#货币之困" class="headerlink" title="货币之困"></a>货币之困</h2><p>在深入比特币前，我们还是先讨论下纸币和传统电子货币（例如支付宝上的交易），笔者在这抛出几个问题供读者思考：</p><ol><li>如何相信交易的货币是真实的，而不是伪造的？</li><li>如何确保一个人持有的纸币&#x2F;数字货币，只能在一个交易中被使用，而不同时支付两笔交易呢（俗称「双花」问题）？</li><li>如何确保我持有的货币，不会被其他人冒认，被声明属于其他人呢？</li></ol><p>我们分类进行讨论</p><h3 id="传统纸币"><a href="#传统纸币" class="headerlink" title="传统纸币"></a>传统纸币</h3><p>对于最简单的纸币交易模型，Alice 将自己拥有的 100 元纸币面对面支付给 Bob：</p><p><img src="https://image.bdwms.com/FkvIKMpdaWlh66sP6qExcUkFY170"></p><ol><li>通常会使用水印，凹印等印刷技术来进行防伪。</li><li>纸币交易的物理特性保证了同一张纸币只能转移给一个人。</li><li>物理意义的持有存储保证了纸币不会被他人冒认。</li></ol><h3 id="传统电子货币"><a href="#传统电子货币" class="headerlink" title="传统电子货币"></a>传统电子货币</h3><p>对于传统的数字货币，存在一个中心化的支付系统用来管理交易，Alice 和 Bob 各自在中心交易系统上拥有 MA 和 MB 的存款储蓄，Alice 向 Bob 发起一笔交易，但实际动作是由中心系统 X 来完成的：</p><p><img src="https://image.bdwms.com/Fs7Bj1mCjCKsZQWLeGfQONRTd6cg"></p><p>显而易见，可信的中心交易系统是最为重要的</p><ol><li>货币的真实性由中心系统 X 来保证。</li><li>双花问题由中心系统 X 保证，Alice 发起多笔交易时由 X 校验其账号余额是否足够。</li><li>一般由 X 进行对交易的身份校验，确保交易是由 Alice 发起的（例如密码，人脸验证等）。</li></ol><h3 id="区块链货币"><a href="#区块链货币" class="headerlink" title="区块链货币"></a>区块链货币</h3><p>对于基于区块链的电子货币，其交易模型又发生了巨大的改变：</p><p><img src="https://image.bdwms.com/Ftey4xCq5yvhrdIT35zyw5il4QJO"></p><p>每一个区块链账户的拥有者都持有一个账本，其中记录了所有参与者的合法交易，当 Alice 向 Bob 发起一笔 100 元的转账时，Alice，Bob，Charlie 三个参与者的账户同时记录了这笔交易。在这样一个去中心化的交易模型中，没有一个必须的可信第三方参与，这就避免了中心交易所对交易的篡改，审计。人人都是参与者，人人都是监督者，每个人「确实」的拥有属于自己的财富，这也是区块链设计哲学的基本出发点之一。</p><p>那么如何回答之前提到的三个问题，如何保证每个人账户的一致性，如何确保交易的合理性，等等在中心化交易中可以轻松解决的问题，都需要重新设计来谋求真正的「人人可信」，带着这些疑问让我们进入下一章。</p><h2 id="拜占庭问题"><a href="#拜占庭问题" class="headerlink" title="拜占庭问题"></a>拜占庭问题</h2><p>在分布式系统中有一个经典而有趣的问题：拜占庭将军攻城问题。简化条件来分析，有三个将军商量攻城，不能相互见面只能通过信使沟通，大于一半的将军选择攻城才会胜利，否则攻城就会失败。将军中可能出现叛徒，叛徒可以任意发出攻城或撤退的命令，甚至不发出命令。</p><p>例一：三个都是忠诚，其中一个发出撤退命令，另外两个发出攻击命令，最终三个将军都决定攻城，达成一致意见。</p><p><img src="https://image.bdwms.com/FkLf0VuQx_P8DpQ8Ic1SGmbOO96F"></p><p>例二：两个忠诚，一个叛徒。叛徒对其中一个发出进攻命令，另一个发出撤退命令，自己选择撤退，那么只有一个忠诚发起进攻导致了失败，没有达成一致。</p><p><img src="https://image.bdwms.com/FqQv8bPiayC48Wqh4mOwceH8IRwR"></p><p>这就是存在消息篡改或伪造（也称为拜占庭节点）的分布式场景中，如何达成系统最终共识一致的问题，将其复杂化也就是上文所说的在分布式场景中，多个用户如何对一份账本达成一致的问题。经过数学推导，可以得知当叛徒大于等于三分之一时将永远无法达成共识，具体推导可以阅读：<a href="https://zhuanlan.zhihu.com/p/36000412">拜占庭问题阈值3f+1推导</a>，这也是各类拜占庭算法实现的大前提。</p><p>关于分布式协议有众多的场景和算法，针对是否存在拜占庭节点我们可以大致分为两类：</p><p><img src="https://image.bdwms.com/FlS6Lg0Pws2u-xezTkkmxpeTQqwo"></p><p>经过对现实世界中复杂问题的抽象，我们可以精简出算法实现的目标，并针对具体的应用场景进行设计，接下来我们就针对比特币的基础 POW 共识算法进行分析，来让读者体会到中本聪的精妙设计。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在谈及比特币之前，笔者假设读者已经拥有了一定的密码学和网络知识基础，比特币正是基于这些基础工具组合设计出来的，这里笔者不展开具体的技术细节，有需要的读者自行点击链接阅读或者 Google 搜索。</p><ol><li><p><a href="https://halfrost.com/asymmetric_encryption/">非对称加密</a></p></li><li><p><a href="https://halfrost.com/digital_signature/">数字签名</a></p></li><li><p><a href="https://halfrost.com/one_way_hash/">Hash函数</a></p></li><li><p><a href="https://juejin.cn/post/7126790340970807326">P2P网络</a>（例如迅雷，BT下载）</p></li><li><p>区块链的基本结构：每个人维护一个「账本」，「账本」结构由一个一个区块构成的有序链表，每一个区块都记录了一系列交易，并且，每个区块都指向前一个区块（通过前一个区块的Hash值），从而形成一个链条。</p><p><img src="https://image.bdwms.com/FpzT0o2HReUdY7wgEVHgJA5XzFd_"></p></li></ol><h2 id="去中心化交易"><a href="#去中心化交易" class="headerlink" title="去中心化交易"></a>去中心化交易</h2><p>我们先简单看一次比特币（去中心化）的交易过程：</p><ol><li><p>小明想要转账 10000 元给小红</p><p><img src="https://image.bdwms.com/Fu4Os_FkBcbOUK_P5ZMBd5yTMVri"></p></li><li><p>首先小明创建一对非对称密钥，并通过 P2P 网络将其公钥进行广播</p><p><img src="https://image.bdwms.com/FoYr-4tdnSwMKl1Z_eCstp4u5tff"></p></li><li><p>小明使用自己的私钥对「小明付款给小红1万元」这句话签名，并通过P2P协议广播出去，任何人都可通过小明的公钥验证这句话确实是小明发出的，并且这个消息不会被篡改。</p><p><img src="https://image.bdwms.com/FpJqMKWgsA9VcKYjSA6zovBMvvCY"></p></li><li><p>收到通知的参与节点在自己的账本中记录下这笔交易。此时有的请求是正常的交易，但有的交易确是双花的，两部分参与者可能记录了双花中的任意一笔，这就是导致了整个系统的账本不能达成一致，那么究竟该怎么决定账本的统一更新呢？这就交由比特币中最为核心的共识算法。</p></li></ol><p>我们稍微回顾一下目前为止，比特币通过数字签名（例如 ESDSA）解决了</p><ol><li>信息发送的身份追溯，也就是由谁发起的这笔交易；</li><li>信息的私密性；</li><li>不可伪造的签名；</li></ol><p>那么剩下的就是如何让大家达成一致的共识问题，避免双花等账本不一致的问题。</p><h2 id="共识算法-POW"><a href="#共识算法-POW" class="headerlink" title="共识算法 POW"></a>共识算法 POW</h2><h3 id="工作量"><a href="#工作量" class="headerlink" title="工作量"></a>工作量</h3><p>POW 中文名为工作量证明算法，举个简单的例子：通过改变随机数 nonce，能够获得不同的 hash 值，首位为 0 的可能性时 1&#x2F;16，所以大致得到一个首位为 0 的hash值需要算 16 次，前置 0 越多，越难算出来，比特币设置在 0 到 2 的 256 次方进行调整难度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hash256(&quot;Hello1&quot;) = ffb7a43d629d363026b3309586233ab7ffc1054c4f56f43a92f0054870e7ddc9</span><br><span class="line">hash256(&quot;Hello2&quot;) = e085bf19353eb3bd1021661a17cee97181b0b369d8e16c10ffb7b01287a77173</span><br><span class="line">hash256(&quot;Hello3&quot;) = c5061965d37b8ed989529bf42eaf8a90c28fa00c3853c7eec586aa8b3922d404</span><br><span class="line">hash256(&quot;Hello4&quot;) = 42c3104987afc18677179a4a1a984dbfc77e183b414bc6efb00c43b41b213537</span><br><span class="line">hash256(&quot;Hello5&quot;) = 652dcd7b75d499bcdc61d0c4eda96012e3830557de01426da5b01e214b95cd7a</span><br><span class="line">hash256(&quot;Hello6&quot;) = 4cc0fbe28abb820085f390d66880ece06297d74d13a6ddbbab3b664582a7a582</span><br><span class="line">hash256(&quot;Hello7&quot;) = c3eef05b531b56e79ca38e5f46e6c04f21b0078212a1d8c3500aa38366d9786d</span><br><span class="line">hash256(&quot;Hello8&quot;) = cf17d3f38036206cfce464cdcb44d9ccea3f005b7059cff1322c0dd8bf398830</span><br><span class="line">hash256(&quot;Hello9&quot;) = 1f22981824c821d4e83246e71f207d0e49ad57755889874d43def42af693a077</span><br><span class="line">hash256(&quot;Hello10&quot;) = 8a1e475d67cfbcea4bcf72d1eee65f15680515f65294c68b203725a9113fa6bf</span><br><span class="line">hash256(&quot;Hello11&quot;) = 769987b3833f082e31476db0f645f60635fa774d2b92bf0bab00e0a539a2dede</span><br><span class="line">hash256(&quot;Hello12&quot;) = c2acd1bb160b1d1e66d769a403e596b174ffab9a39aa7c44d1e670feaa67ab2d</span><br><span class="line">hash256(&quot;Hello13&quot;) = dab8b9746f1c0bcf5750e0d878fc17940db446638a477070cf8dca8c3643618a</span><br><span class="line">hash256(&quot;Hello14&quot;) = 51a575773fccbb5278929c08e788c1ce87e5f44ab356b8760776fd816357f6ff</span><br><span class="line">hash256(&quot;Hello15&quot;) = 0442e1c38b810f5d3c022fc2820b1d7999149460b83dc680abdebc9c7bd65cae</span><br></pre></td></tr></table></figure><h3 id="挖矿与收益"><a href="#挖矿与收益" class="headerlink" title="挖矿与收益"></a>挖矿与收益</h3><p>有了这么一个如何表示工作量的前提，那么我们可以描述一个熟知的名词——「挖矿」。比特币设置一个 target 目标，要求 hash 值小于 target 为挖矿成功，矿工通过改变随机值来暴力遍历找到合适的 nonce（这个过程根据全网算力调整，平均为10分钟算出一个）。</p><p>挖出一个区块，可以奖励给矿工一定量的 btc（交易小费 + 基础奖励），这个奖励通过交易的方式 coinbase，交易输出地址是矿工自己的公钥地址，矿工将这笔交易写在第一个交易。奖励的定义如下：</p><ul><li>交易小费：根据交易数据大小按照一定公式进行计算。</li><li>基础奖励：2016年12.5个，每四年减半，2140年挖完2100万个 btc。</li></ul><p>目前矿工的收益主要还是来自基础奖励，当2140年挖完最后一块 btc 时，挖矿的收益将只有交易小费构成。</p><p><img src="https://image.bdwms.com/Fhp1wLV_n3-XmSWgoCVf2AB3AyJ8"></p><h3 id="组装区块"><a href="#组装区块" class="headerlink" title="组装区块"></a>组装区块</h3><p>矿工在挖矿时会将广播收到的「有效交易信息」进行组装，一般使用二叉哈希树的形式来快速验证交易是否存在。成功挖出区块后会将交易信息，目标值 target，nonce 随机数，前一个区块的 hash 等数据组成一个新的区块。</p><p><img src="https://image.bdwms.com/Fkl7yXaGv6HWBmO-DSB7quu1ZbzK"></p><h3 id="广播区块"><a href="#广播区块" class="headerlink" title="广播区块"></a>广播区块</h3><p>挖出区块的矿工会通过 P2P 网络立刻进行广播，其他节点验证通过后，会放弃本轮自己的挖矿，并将收到的成功区块更新到自己的本地账本中，下图中其他节点都将绿色区块更新到自己的最新账本上。</p><p><img src="https://image.bdwms.com/Ftm-sRRnFYaVtChftoDtEIRxQ5LR"></p><h3 id="分叉问题"><a href="#分叉问题" class="headerlink" title="分叉问题"></a>分叉问题</h3><p>显而易见，我们看到可能存在在同一轮挖矿竞赛中，出现两个甚至多个节点都算出 nonce 满足并进行广播，因为网络延迟等因素，不同部分的节点收到的区块可能不同，那么究竟是按照哪个区块为准呢？比特币节点总是以「最长」的链为正确的，下面举例进行说明：</p><ol><li><p>在这一轮挖矿中基础区块时五角星，有两个节点同时算出来区块，结果分别是正三角和倒三角，广播给其他节点：</p><img src="https://image.bdwms.com/FmUGS7z60gIwPRYAjk0nEumGWlHE" style="zoom:50%;" /></li><li><p>此时节点产生分叉，有的节点先收到正三角，有的先收到倒三角，但是节点将两个块都保存记录下来。</p><img src="https://image.bdwms.com/Fn_b7Y4OmT2zEnesCAIlDJbus0cn" style="zoom:50%;" /></li><li><p>分区域计算：先收到正三角的节点以正三角为基准计算下一个区块，先收到倒三角的区块以倒三角为基准作为区块。此时有一个以正三角的节点算出了下一个区块棱形，并进行广播。</p><img src="https://image.bdwms.com/Fhtvnego0ACGIeiaiMMUKDVxGcKI" style="zoom:50%;" /></li><li><p>分支合并：菱形被广播出去，倒三角的节点比较两个分叉的工作量，正三角-棱形分支工作量  &gt; 倒三角。替换主链为正三角-棱形分支，将倒三角认为为次链，除非倒三角后面的链接长度反超，才会被更新回去。但是因为挖矿计算的难度，当计算了6个区块后的深度，几乎是不可能被修改的，因为全网的总计算量不够来修改。</p><img src="https://image.bdwms.com/FuVOHGAdupWDvuc1QS65YtgaXCRH" style="zoom:50%;" /></li></ol><p>同时计算出同一个区块可能每天出现，但是两次分叉的情况因为算力问题可能几周才会出现一次。因此比特币就是通过 <strong>降低了区块产生的频率（交易确认的频率），来减少分叉数据不一致的可能性；通过工作量的难度，避免了交易被否认</strong>。从分布式 CAP 原理来看就是牺牲了一定的一致性 C，保证了可用性 A 和分区容错性 P，有兴趣的读者可以深入了解一下 CAP 相关的知识。</p><p>通过以上的一些列操作，这就保证了整个比特币系统的稳定统一性，避免了双花等交易共识不一致问题，只要符合拜占庭容错恶意节点不要超过 1&#x2F;3，那么整个系统的账本总能保持一致安全的活性，支持系统内交易的正常进行。</p><h2 id="衍生安全问题"><a href="#衍生安全问题" class="headerlink" title="衍生安全问题"></a>衍生安全问题</h2><p>关于区块链的安全攻击问题不是本文的重点，暂时列举几个常见的例子，后续的文章中会进行更加详细的阐述：</p><ol><li>密钥泄漏：私钥被窃取。</li><li>51%攻击：掌握大量算力，创建一个高度更高的链来覆盖原来的链</li><li>中心化交易中心受到攻击。</li><li>……</li></ol><h2 id="回顾总结"><a href="#回顾总结" class="headerlink" title="回顾总结"></a>回顾总结</h2><p>通过前文对比特币核心思想和算法的分析解释，我们可以看出中本聪对未来金融，乃至世界的前瞻看法，「人人可信，去中心化，共识机制，不可篡改，分布式……」等自由的核心理念透出了其中的设计哲学。基于区块链，每个人都可以切实的拥有属于自己应该拥有的，而不必须交由第三方进行保管，往后的以太坊， Web3.0 等等新概念都是基于这些基础的设计思想诞生的。</p><p>笔者常常认为一个优秀的架构更像是一件艺术品，当阅读并理解比特币后，更加惊叹其中的瑰丽思想与巧妙设计，区块链的世界已经为我们打开！</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021-独立之年</title>
      <link href="2021-summary/"/>
      <url>2021-summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2021，独立</p></blockquote><p>时间飞逝而过，bdwms度过了22岁迷茫的一年。</p><p>「独立」，这是年初定下的关键词。这一年的我第一次迈入社会，第一次直面自己的内心，经历了痛苦挫折，也遇到了很多美好，有跌落谷底的时候，也有感到快乐的瞬间。在杭州的深夜，我将一些所思所感写下。</p><h2 id="理性的回顾"><a href="#理性的回顾" class="headerlink" title="理性的回顾"></a>理性的回顾</h2><p>为什么2021年的总结是在4月初？理由很简单就是我的生日以及阿里巴巴的财年恰好都是在3月末。因此在21年3月的时候为自己定下了个人的年度OKR。整个的OKR计划，执行与复盘主要依赖于语雀，中间穿插使用过其他的工具，例如Trello用于Scrum管理，松鼠APP用于记账，同时重点参考了draven的<a href="https://draveness.me/few-words-time-management/">《如何管理自己的时间资产》</a>。</p><p><img src="https://image.bdwms.com/FkMUaJBVPc_z72EULpsBfKJpF-7h"></p><p>整个OKR的完成情况如下，其中有很多小O在执行过程中直接选择了放弃，例如日语与折纸，同时还有一些下半年的新规划并没有更新进入，综合评估下来总的完成情况可以给自己评60-70分左右，在明显状态不好的过去一年能够有这样的完成度，还是较为满意的：</p><p><img src="https://image.bdwms.com/FkwNygUOnar71YZuyMnpG2LqmbY7"></p><p>过去一年内的信息流输入主要依赖于博客、网课、知乎以及一些书籍。</p><p>一些敬仰的大神博客：</p><ul><li><a href="https://draveness.me/">draveness-面向信仰编程</a></li><li><a href="https://halfrost.com/">halfrost-冰霜之地</a></li><li><a href="https://www.jianshu.com/u/38eb16b24cb9">西部小笼包</a></li><li><a href="https://www.desgard.com/">一片瓜田</a></li><li>……</li></ul><p>原本的读书规划是在30本左右，最终虽然数量基本达到，但是技术书籍占比还是过高，并且阅读质量并不算高。伴随工作后的读书兴趣与能力下降，整体的阅读体验并不佳，希望可以在明年更加专注提升效率。</p><p><a href="https://www.yuque.com/docs/share/7ce66c9f-b2bb-4283-90a1-19c894cf5b96#cCBy">2021年度读书计划</a>：</p><p><img src="https://image.bdwms.com/Fu7-TYaAxaBWRxb1UZQ4K8olP7xL"></p><p>这一年的信息流输出主要还是博客，原先计划是完成24篇博客，平均两周一篇，最终实际只有14篇，并且技术类博客占比较低，总结下来还是对于一篇高质量的博客需要投入的时间要求高，自身的知识积累与能力转化并不足够。在21年想要按照系列去写博客，想了一些系列例如自建情报库，城市猎人等等，其中最满意的还是自建情报库系列，希望明年可以多多写文章，并拥有自己的公众号。</p><p><img src="https://image.bdwms.com/FnvQ3AddBXGWZWyr_8oDuZytyFFE"></p><p>除此之外，我还在21年点了一些小技能，没有非常精通，但为生活增添了不少乐趣。21年学习着做饭，从真难吃逐渐到能养活自己，希望未来可以成为一个大厨，bdwms的<a href="https://www.yuque.com/docs/share/bc92522a-2c9a-4548-a700-dfbbc9d8b45f#DpkO">黑暗料理</a>：</p><p><img src="https://image.bdwms.com/FkdYbrQAL72RFaDUOn-lclO7Tk0e"></p><p>简单学习着摄影，记录一些小美好，摄影小法师的小角落：<a href="https://500px.com.cn/bdwms">https://500px.com.cn/bdwms</a></p><p><img src="https://image.bdwms.com/Fgq7M5V34polss6Zg9AJNT93tjiz"></p><p>以及一些其他零零碎碎的尝试：骑车，折纸，滑雪，sketch……</p><p>理性的总结暂时到此为止，接下来聊聊些感性的吧。</p><h2 id="抑郁"><a href="#抑郁" class="headerlink" title="抑郁"></a>抑郁</h2><p>先谈一谈抑郁的事情。20年12月来到阿里巴巴，初来乍到的不适应，工作的压力，性格的缺陷等多方面因素让我那个阶段状态急剧下滑，身体上体现在脱发，腰痛，飞蚊症等问题，同时期精神状态也出现了强迫，抑郁的倾向。记得最严重的时候，早上6点睁开眼就感到悲伤，对着我的猫无声流泪，不过也幸好有猫崽子相伴才让我有了一丝动力。</p><img src="https://image.bdwms.com/FlTk7dXNOLu8-62MPWte4Yma4_4q" style="zoom:33%;" /><p>9月和弟弟坐在西湖边，我说我感到痛苦与孤独，在弟弟的建议下第一次去看了心理医生，当老师告诉我轻度抑郁的时候，竟然有一丝欣慰与释然。曾经我一直认为倾诉痛苦是不好的，就像抽烟一样会影响到别人，同时因为过高的情绪敏感度接受到大量的嘈杂信息，导致脑子一直在超频的运转。和老师交流了十几次，逐渐学习着去更多的关注自己，接受自己。悲伤，抑郁，愤怒，嫉妒……这些都是我，不能逃避这些情绪，渐渐的，我学会虽然痛苦但依然正视感知自己的情绪。</p><p>10月初，我孤身一人飞往了广州，思考一些很重要的问题。我走在广州的街头，执著自己存在的意义，在这千万人的城市中感受着「存在孤独」，两年前的我走在北京的大街上，激动着互联网的发展拉近了人与人之间的距离，但是在广州却想到最后一站的距离是互联网暂时无法跨过的鸿沟。我们生来孤独，社会化的生物依然有着孤立化的另一面，但这并不可怕。凌晨一点，我坐在珠江边上吹着晚风，听着街头艺人的歌声，抬头仰望的大厦灯光好似星光，沉浸在一种玄妙的感觉中。</p><p><img src="https://image.bdwms.com/FtJIlTvcxbasf7shdj63YgrZ8kU9"></p><p>慢慢的，我学习着如何感知情感，如何表达情感，老师恭喜我不再是一个机器人，我也知道剩下的都留给时间，而我也只需要时间去一点一点成长，成长为一个美好的人。</p><p>「在隆冬，我终于知道，我身上有一个不可战胜的夏天」</p><h2 id="美"><a href="#美" class="headerlink" title="美"></a>美</h2><p>这一年，我尝试了很多新奇的事情，摄影，做饭，骑车等等，对于什么是美，如何感受美有了困惑与好奇，想简单表达下自己观点。</p><p>「美是秩序中的一点无序」</p><p><img src="https://image.bdwms.com/FtDNfDW02Yg5zyopY5XnlZeWF19N"></p><p>美是基于秩序的。当有了好与坏的分别，多与少的对比，美才产生了意义。今年看完了一本收藏了很久的书《禅与摩托车维修艺术》，「要证明一个东西的存在，可以把它从环境中抽离出来，如果原先的环境无法正常运作，那么它就存在。如果我们能证明没有良质的世界运作不正常，那么我们就能证明良质是存在的。第一个受伤的就是艺术。如果艺术无所谓好坏之分，那么艺术也就不存在了。接下来消失的是运动。足球、棒球、各种游戏都会消失，因为分数已经丧失了意义，只是空洞的统计」。</p><p>所以美不能诞生于完全的混乱中，人是衡量万物的尺度，人本身就是基本符合秩序的，书中初期的「良质」也就是在我理解的美的另一种表达方式。同样在计算机世界中，由抽象出来的0与1进行排序组成，代表了人对自然世界的简化理解，对秩序规则的一种描述。从个体的角度来看，互联网化的社会包含的信息量庞大到无法理解，但是从整个自然界来看，计算机的发展其实是对其进行抽象简化，从而提取出对人类有「意义」的信息片段。</p><p><img src="https://image.bdwms.com/FpcoPag6fS0O1fJX8IOvAGmiCARp"></p><p>但是美同样也是产生于无序中的。当全量的信息都是可知的，已知条件足够进行相应的理性推理时，事物本身就只保留了「朴质」，变得乏味与无趣。「良质就是同时意识到主客观存在时所发生的事件」，这个瞬间是结合了主观与客观的，「“过去”只存在于我们的记忆之中，“未来”则存在于我们的计划之中，而只有“现在”才是惟一的真实」。美是偶然，是瞬间，是平淡生活中的一抹不平凡，是历经磨难后的转折点，是我所追寻的星辰与火苗。</p><p><img src="https://image.bdwms.com/FmIBXVF1xXuUp-x-uL-Hc7gZdcBA"></p><p>音乐是有序的，它有基本的乐理去约束，音乐是无序的，每个人表达的情感是不同的；厨艺是有序的，它有基本的流程去制作，厨艺是无序的，个人的口味是不同的；计算机更是有序的，我们提前约定了各种规范，但同样它也是无序的，无论是从开发者的不稳定性，还是从硬件本身的异常，都体现了它无序的一面。我们追寻的就是有序与无序的结合，「古典」与「浪漫」，「嬉皮」与「严谨」，「科技」与「人性」等等对立双方的平衡融合，乃至完全不属于对立两者的终极，也就是作者波西格所说的「良质」，中国哲学的「道」。</p><h2 id="技术，产品与人"><a href="#技术，产品与人" class="headerlink" title="技术，产品与人"></a>技术，产品与人</h2><p>这一年我认识了很多产品经理朋友，他们有着与技术人员十分不同的视角，而我也认为这是程序员在个人发展过程应该学习理解的一个重要思想。在互联网的发展中，流水线化，标准化促使程序员尽量模块化自己的能力，从而能够提高整体的效率，我们更加类似战国时的铁匠，专心服务于手中的锤子去锻炼精粹兵器，而不需要去思考如何使用。</p><p>科技是突破人类的极限，而技术更多的是应该服务于实业的发展。很多时候技术人员容易误入「难度的快感」，认为复杂困难的就是有用有效的，两者可能是正相关的，但并不是必然的，我们应该时刻保持清醒，留意项目的重难点，从一个有价值的项目中去反向的挖掘技术存在的意义。</p><p><img src="https://image.bdwms.com/Fj5KKt272PT3SvBAOuy-TgyahmSz"></p><p>程序员不仅仅是与机器交互的，更应该是学会处理人与人之间的关系，因为程序是对社会的简化，很多时候我们需要平衡好自身技术成长与人际交往。知世故却不世故，历圆滑而弥天真，善自嘲而不嘲人，处江湖而远江湖，这正是我希望在阿里巴巴能够达到的平衡状态。优秀的产品正是通过技术表达出人的诉求，产品经理的职责正式去作为设计师，掌舵人去决定如何满足人的需求，而程序员更多时候是作为实践者，但伴随成长，我希望能够摆脱掉角色的定义，将自己的能力专注于「完成」一个事情，无论是采用何种手段去解决问题，满足需求，实现产品。</p><p>这一年的我技术栈反复重铸，从Web安全到二进制安全， iOS，Android，Java，OC，C++……虽然都是浅尝辄止，但是也越来越明白自己应该专注哪些，将更多的精力花费在哪个地方。我希望有朝一日我可以铸成一把利剑，荆轲刺秦王！</p><h2 id="爱"><a href="#爱" class="headerlink" title="爱"></a>爱</h2><p>爱与被爱是一种本能，但如何爱与被爱则是一种能力。我一直认为自己并不擅长于去感受爱，去真正意义上的表达爱，情绪的感知能力很强，但第一反应的共情本能并不强烈，也因此我更多的是经过第二思考去抉择。但是我认为我是优秀的，野兽服从于本能，而智人拥有思考去克制自我，我或许无法做到本能的自信，本能的同情，本能的炽爱，但是我可以一点一点的感受每一件事情的温度，去尝试理解每个人的想法，去疏导排解去克制去重新再来，我由衷的为自己骄傲寻找到一个属于我自己的「爱」的方式。</p><p><img src="https://image.bdwms.com/FrVzhXaXab6NETdp00_piJW575jm"></p><p>爱具体的人，不要爱抽象的人，爱生活，不要爱生活的意义。从未想到在这一年的最尾端，我能如此幸运的遇到一个人， 能够一同去旅行，听音乐，看书，去分享生活的美好。</p><p><img src="https://image.bdwms.com/FqN9RvpAKHou3qbXWZ4t0i591_nb"></p><p>祝福我们可以一起成长，成为交心的队友，成为挑战生活的对手，成为相互喜欢的那个人。</p><p><img src="https://image.bdwms.com/Ft8exiTwHgU_vGvTSg4ujAbxyz4L"></p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>最后的最后，22岁的最后一刻，我暂时停笔……</p><p>继续吧，</p><p>苦难不值得感谢与怀念，我感谢的是助我走过低谷的种种</p><p>感谢我的父母，依旧是我最后的港湾</p><p>感谢弟弟和肖君等等帮助过我的老朋友们，在凌晨四点依然在陪伴我</p><p>感谢来到杭州后认识的许许多多的新朋友们，在你们身上我感受到了向阳而生的力量</p><p>感谢在我最痛苦时期指引我的老师，让我一点点找回自己</p><p>感谢某个人</p><p>最后感谢自己，从未选择过放弃，从未放弃过自己</p><p>23岁，我将更加美好</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>隐私合规—浅谈污点分析的应用</title>
      <link href="privacy-with-taint-analysis/"/>
      <url>privacy-with-taint-analysis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>利用污点分析的思想，将漏洞挖掘的方法应用于隐私合规扫描。</p></blockquote><p>伴随近年来监管，用户，厂商等多方对隐私合规问题的逐渐重视，各APP需要梳理其隐私相关行为，按照合规要求进行整改。然后问题在于，大型APP很难完全整理出隐私相关的调用链路，所以本篇文章从静态扫描的角度来分析如何排查完整隐私调用链路，以半自动化污点分析工具Jandroid为例，来说明污点分析在隐私合规中的实际应用。</p><h2 id="隐私合规"><a href="#隐私合规" class="headerlink" title="隐私合规"></a>隐私合规</h2><p>2021年开始，从十四五规划中可以看出，在安全领域隐私治理，反数据垄断成为新提出的重点方向。《个人信息保护法》，《数据安全法》等相关法律条令相继颁布并落地，监管加大对各APP的监察力度，多次指令下架多款APP，同时苹果，华为，小米等手机厂商对各自应用商店的上架要求也更为严格，由此可以总结出隐私合规四大趋势：</p><ul><li>个人信息保护法律健全完善</li><li>监管常态化巡检与专项治理</li><li>用户隐私感知能力重点关注</li><li>厂商审计监察标准逐步提升</li></ul><h2 id="污点分析"><a href="#污点分析" class="headerlink" title="污点分析"></a>污点分析</h2><p>简单介绍污点分析思想：</p><blockquote><p>污点分析可以抽象成一个三元组<code>&lt;sources,sinks,sanitizers&gt;</code>的形式,其中,<code>source</code> 即污点源,代表直接引入不受信任的数据或者机密数据到系统中;<code>sink</code> 即污点汇聚点,代表直接产生安全敏感操作(违反数据完整性)或者泄露隐私数据到外界(违反数据保密性);<code>sanitizer</code> 即无害处理,代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害.污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理,而直接传播到污点汇聚点.如果不能,说明系统是信息流安全的;否则,说明系统产生了隐私数据泄露或危险数据操作等安全问题.</p></blockquote><p>污点分析主要又分为静态污点分析和动态污点分析</p><ul><li>静态污点传播分析(简称静态污点分析)是指在不运行且不修改代码的前提下,通过分析程序变量间的数据依赖关系来检测数据能否从污点源传播到污点汇聚点。</li><li>动态污点传播分析(简称动态污点分析)是指在程序运行过程中,通过实时监控程序的污点数据在系统程序中的传播来检测数据能否从污点源传播到污点汇聚点。</li></ul><p>在本篇文章中主要介绍静态污点分析的应用，Jandroid基于androguard的函数调用关系，应用结构分析，是F-Secure LABS团队开发的用于半自动化逻辑漏洞挖掘工具，同时Jandroid也可以应用于隐私合规，静态代码分析出隐私API链路分析，从而帮助开发者排除整改违规隐私调用。</p><h2 id="Jandroid源码分析"><a href="#Jandroid源码分析" class="headerlink" title="Jandroid源码分析"></a>Jandroid源码分析</h2><p>首先新建一个Android项目作为例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.webviewdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.webkit.WebView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        wrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wrap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> (WebView) findViewById(R.id.webview);</span><br><span class="line">        webView.loadUrl(<span class="string">&quot;https://baidu.com/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置下项目环境，编译好的apk文件方apps目录，jandroid.py是主程序</p><p><img src="https://image.bdwms.com/FttcbJUHl_O3temvPCoHbdCeRIH_"></p><p><img src="https://image.bdwms.com/FmfFaqPEvJhOyfTee1RGJ7R_fCtB"></p><p>分析函数为WebView.loadUrl，反向推演出调用链路。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;METADATA&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;NAME&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JSbridgeBrowsable&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;CODEPARAMS&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;TRACE&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;TRACEFROM&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;method&gt;:Landroid/webkit/WebView;-&gt;loadUrl(Ljava/lang/String;)V&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;TRACETO&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;method&gt;:Lcom/example/webviewdemo/MainActivity;-&gt;wrap()V&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;TRACELENGTHMAX&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;RETURN&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;tracepath&gt; AS @tracepath_browsablejsbridge&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;GRAPH&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@tracepath_browsablejsbridge WITH &lt;method&gt;:&lt;desc&gt;:&lt;class&gt; AS attribute=nodename&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>开始断点调试来分析Jandroid的运行流程：</p><ol><li>直接进入到fn_analyse_apps函数，之前是参数解析，验证，是否从手机拉取APP等</li></ol>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create two process queues: one for sending data to,</span></span><br><span class="line"><span class="comment">#  and one for receiving data from, worker processes.</span></span><br><span class="line">process_send_queue = JoinableQueue()</span><br><span class="line">process_receive_queue = JoinableQueue()</span><br></pre></td></tr></table></figure><p>  创建两个队列来作为生产者和消费者进行对dex的处理，包括对队列的停止消息发送，异常处理</p><ol start="2"><li><p>跟进到fn_perform_analysis，根据template生成bug object对每个app，进行一些初始化处理</p></li><li><p>fn_per_bug_analysis根据参数是CODEPARAMS还是MANIFESTPARAMS进行分别处理</p></li><li><p>fn_handle_code_analysis记录满足bug elements的数量</p></li><li><p>fn_perform_code_analysis处理是否满足整个搜索链路</p></li><li><p>fn_determine_action根据SEARCH还是TRACE</p></li><li><p>fn_perform_code_trace处理trace有多少个满足</p></li><li><p>fn_process_individual_trace_list_item中来分析处理trace_from，trace_to</p></li><li><p>fn_trace_through_code拆解出来class, method, decs，然后进入正式的搜索</p></li><li><p>fn_trace_reverse拿到starting point</p></li><li><p>fn_get_calls_to_method中找到符合sig的方法，然后从这个方法搜索xref_from，也就是调用这个方法的交叉引用</p></li></ol>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First get all methods that match the given signature.</span></span><br><span class="line">method_objs = self.fn_get_methods(</span><br><span class="line">    class_part,</span><br><span class="line">    method_part,</span><br><span class="line">    desc_part</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now check the xref_from (i.e., calls to) for the method(s).</span></span><br><span class="line">calling_methods = []</span><br><span class="line"><span class="keyword">for</span> method_obj <span class="keyword">in</span> method_objs:</span><br><span class="line">    <span class="keyword">for</span> xref_from_elem <span class="keyword">in</span> method_obj.get_xref_from():</span><br><span class="line">        <span class="comment"># The xref_from_elem is a tuple where the second element</span></span><br><span class="line">        <span class="comment">#  is the EncodedMethod object.</span></span><br><span class="line">        method_name = xref_from_elem[<span class="number">1</span>].get_name()</span><br><span class="line">        <span class="comment"># If we don&#x27;t want anything with user interaction.</span></span><br><span class="line">        <span class="keyword">if</span> self.keep_user_interaction == <span class="literal">False</span>:</span><br><span class="line">            is_user_interaction = \</span><br><span class="line">                self.fn_check_for_user_interaction_element(</span><br><span class="line">                    method_name</span><br><span class="line">                )</span><br><span class="line">            <span class="comment"># If the method is to do with user interaction,</span></span><br><span class="line">            <span class="comment">#  don&#x27;t include it.</span></span><br><span class="line">            <span class="keyword">if</span> is_user_interaction == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> xref_from_elem[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> calling_methods:</span><br><span class="line">            calling_methods.append(xref_from_elem[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> calling_methods</span><br></pre></td></tr></table></figure><p>   然后同时搜索trace_from要搜索的类的子类中搜索</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Include subclasses.</span></span><br><span class="line">all_subclasses = []</span><br><span class="line">all_subclasses.extend(</span><br><span class="line">    self.inst_analysis_utils.fn_find_subclasses(class_part)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> subclass <span class="keyword">in</span> all_subclasses:</span><br><span class="line">    starting_points.extend(</span><br><span class="line">        self.inst_analysis_utils.fn_get_calls_to_method(</span><br><span class="line">            subclass,</span><br><span class="line">            method_part,</span><br><span class="line">            desc_part</span><br><span class="line">        )</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>   然后还有一些不是直接调用的方法，例如OnCreate</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># We want to also add the original method to the search as it might not be directly called, for example OnCreate.</span></span><br><span class="line"><span class="keyword">if</span> desc_part != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">    desc_part = re.escape(desc_part)</span><br><span class="line">class_part = re.escape(class_part)</span><br><span class="line">method_part = re.escape(method_part)</span><br><span class="line"></span><br><span class="line">mathcing_methods = self.androguard_dx.find_methods(</span><br><span class="line">    class_part,</span><br><span class="line">    method_part,</span><br><span class="line">    desc_part)</span><br><span class="line"><span class="keyword">for</span> method <span class="keyword">in</span> mathcing_methods:</span><br><span class="line">    starting_points.append(method.get_method())</span><br></pre></td></tr></table></figure><ol start="12"><li><p>fn_analyse_trace_point进行具体的分</p></li><li><p>fn_trace_reverse搜索starting point在xref_from里面的是否在trace_to里面，如果不是继续往上递归搜索xref_from的结果</p></li><li><p>如果匹配到链路，那么这次搜索成功，一路向上返回。</p></li><li><p>最终可以生成一个图的结果来看。可以看到调用链路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrap:()V:Lcom/example/webviewdemo/MainActivity;  -&gt; loadUrl:(Ljava/lang/String;)V:Landroid/webkit/WebView;</span><br></pre></td></tr></table></figure><p><img src="https://image.bdwms.com/FgjHuprp0C-e1qqnb7_6r1Dl0WRg"></p><p><img src="https://image.bdwms.com/FiOMs1TSnb4TbycXBC6xHliP1X5-"></p></li></ol><p>其中最为核心的就是利用Androguard搜索xref_from，然后看调用这个函数的是否有匹配链路的，没有就继续往上搜索，同时要注意处理一些特殊情况例如子类，特殊函数OnCreate等，就这样利用交叉引用搜索出整个的调用链路。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fn_get_methods</span>(<span class="params">self, class_part, method_part, desc_part</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Gets all methods that satisfy a certain signature.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param class_part: name of the method class as string</span></span><br><span class="line"><span class="string">    :param method_part: name of the method as string</span></span><br><span class="line"><span class="string">    :param desc_part: descriptor as string</span></span><br><span class="line"><span class="string">    :returns: list of Androguard MethodAnalysis objects</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    method_objs = []</span><br><span class="line">    <span class="keyword">if</span> desc_part != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">        desc_part = re.escape(desc_part)</span><br><span class="line">    class_part = re.escape(class_part)</span><br><span class="line">    method_part = re.escape(method_part)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> method <span class="keyword">in</span> self.androguard_dx.find_methods(</span><br><span class="line">        class_part,</span><br><span class="line">        method_part,</span><br><span class="line">        desc_part</span><br><span class="line">    ):</span><br><span class="line">        method_objs.append(method)</span><br><span class="line">    <span class="keyword">return</span> method_objs</span><br></pre></td></tr></table></figure><p>Androguard的源码分析暂时不在本文中展开。交叉引用的概念可以参考：<a href="https://androguard.readthedocs.io/en/latest/intro/xrefs.html">https://androguard.readthedocs.io/en/latest/intro/xrefs.html</a></p><p>经过上述复杂的调用链路，完成了一次静态污点分析的调用链路排查，通过这样的思想和方法我们就可以完成对相关隐私API链路的调用，梳理出来大部分调用链路，但是这样子的静态分析必然是无法覆盖全面的调用链路的，例如动态调用代码，反射等一些比较特殊的处理都是很难利用静态扫码完整回溯出来的，同时缺乏运行时的信息也是很难完整还原真实的APP隐私行为。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>静态扫描作为隐私治理的一种手段，以较低的成本对APP隐私水位有了大致的感知能力。通过借鉴漏洞分析中的污点分析思想，将其应用在隐私治理中，这也是非常有效和常用的，值得我们去更多挖掘类似的方法，之后会对iOS的静态扫描做同样的分析。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://ch3nye.top/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">污点分析笔记</a></li><li><a href="http://www.npc.gov.cn/npc/c30834/202108/a8c4e3672c74491a80b53a172bb753fe.shtml">个人信息保护法</a></li><li><a href="https://androguard.readthedocs.io/en/latest/">Androguard手册</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> SecDev </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自建情报库-人才篇</title>
      <link href="information-database-talent/"/>
      <url>information-database-talent/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自建情报库系列是一套信息收集方法论，目的是为了帮助毕业生建立必备的知识情报体系，从而更好地迈入社会。本系列将会从住房，政策，经济，医疗等方面进行概括性的叙述，形成一条完整的知识链路，作为之后付诸行动的个人信息门户。</p></blockquote><p>「我们站在城市的十字路口，期待的不过是一个家」</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>笔者是一个喜欢做计划的人，虽然暂时没有决定定居在哪个城市，但是为了将来的留杭可能同样需要提前考虑，因此对于在杭购房以及相关的政策都需要进行研究，以备不时之需。</p><p>从全国的角度来看，杭州楼市的炒作热度仅此于深圳，一手房严重倒挂二手房，并且目前国家对于二手房的贷款利率继续上调，从基本面分析都是在提醒着非刚需人群不要去接盘二手房。为此笔者决定重心放在研究一手房市场，随着国家调控的逐渐升级，对于楼市政策呈现维稳，收缩的态度，在限制炒房的直接手段上连续出台了多项规定，但其中也「误伤」到一些群体，在杭州市2021.08.05颁布了新政策后，对于应届生来说直接失去手中的房票，但经过笔者仔细研究，发现这未必不是机会。</p><p>综上，需求就是应届生如何在限制政策下最快最好地购房。</p><h2 id="背景分析"><a href="#背景分析" class="headerlink" title="背景分析"></a>背景分析</h2><h3 id="购房政策"><a href="#购房政策" class="headerlink" title="购房政策"></a>购房政策</h3><p>笔者根据最新的2021.08.05的杭州市楼市新政进行总结：</p><p><img src="https://image.bdwms.com/FkQ8HkjuZ5Qhyxv2C3AS4Px8uxRq"></p><p>从普通应届生的角度总结，基本条件为<strong>落户+两年社保</strong>拥有一手房摇号资格以及二手房购买资格，但是由于社保年限过低对于红、粉盘的优先顺位极低，因此必须退步为普通盘或者寻求其他突破手段。</p><h3 id="人才政策"><a href="#人才政策" class="headerlink" title="人才政策"></a>人才政策</h3><p>杭州市为了吸引人才，对于人才有政策福利偏向，从这个角度可以进行可行性研究，具体的人才政策不在这里赘述，可以参考<a href="https://rc.hzrs.hangzhou.gov.cn/articles/detail/6679.html">《杭州市高层次人才分类目录（2019年修订版）》</a>。杭州市分为ABCDE五个级别的人才，福利和难度依次降低。</p><p>关于杭州人才福利，简单概括为：</p><ol><li>安居计划：各个楼盘提供不超过20%比例作为人才的摇号池。当人才没有超过20%的数量等于直接免摇号，当人才池没有摇中号进入无房户摇号池，再不中进入普通摇号池，也就是说可以摇三次。</li><li>购房补贴：D类开始有100w补贴，逐级增长。</li><li>租房补贴：每个区有不同的租房补贴（余杭区E类人才此类福利暂停）。</li><li>返税福利： 杭州对A-E类人才补贴个人所得税，针对年入100万以上的人才，个人所得税超过应纳税所得额15%部分，按照A-E类分别奖励100%、95%、90%、85%</li><li>车牌福利：参考具体政策</li><li>子女入学：参考具体政策</li><li>……</li></ol><p>重点关注第一条，E类人才同样享有20%优先房源的政策，对于普通应届生也是最简单的。</p><h2 id="实现途径"><a href="#实现途径" class="headerlink" title="实现途径"></a>实现途径</h2><p>从官方给出的E类人才定义以及公示的人才认定结果，经过筛选针对互联网从业者最可行的三条路径为：</p><ol><li>博士学历。</li><li>上年度纳税 5 亿元（含）以上制造业或纳税5亿元国家级高新技术企业的其他人才，上年度工资性收入在 50 万元（含）以上的其他人才。</li><li>取得副高级专业技术职务任职资格（含高级社会工作师、高级政工师），获得以下专业技术成果之一的人才：获区、县（市）级以上奖励，承担设区市级以上课题、科研项目，取得授权专利（前 3 位完成人），制定地方标准、行业标准或国家标准（前 3 位完成人），出版著作，编写教材，在国内外核心期刊发表过学术论文（前 2 位作者）。</li></ol><p>针对第二、三进行进一步的解读：</p><h3 id="收入"><a href="#收入" class="headerlink" title="收入"></a>收入</h3><ol><li><p>上年度纳税 5 亿元（含）以上制造业或纳税5亿元国家级高新技术企业</p><p>必须签约公司为此类纳税超过5亿的公司，在杭州基本上就是阿里巴巴，网易，海康威视等，但是对于类似阿里巴巴集团为多公司分散控股的结构，并非所有人都是签约符合标准的企业，需要关注自己的劳动合同具体签约的公司。</p></li><li><p>上年度工资性收入在 50 万元（含）以上</p><p>税前工资性收入，不包含股票。从职级来看大概是阿里巴巴的普通7，高潜6，5。</p></li></ol><p>如果以上两个条件都符合的话，可以通过公司进行人才申请，一般都会有专员对接。</p><h3 id="职称"><a href="#职称" class="headerlink" title="职称"></a>职称</h3><ol><li><p>副高级专业技术职务任职资格（含高级社会工作师、高级政工师）</p><p>国家认证的职称体系，这里直接给出结论，互联网从业者考：信息系统项目管理师，具体可参考<a href="http://www.zjrjks.org/">浙江省软件考试网</a>。每年5月和11月份考试，通过率大致在10%～20%，但是实际上有一半是炮灰，难度没有想象中的那么大，但是同样需要付出一定的精力，需要认真对待。</p><p><img src="https://image.bdwms.com/FkiVG-EgAi5XQ9dOKH90-U091-oa"></p></li><li><p>获区、县（市）级以上奖励，承担设区市级以上课题、科研项目，取得授权专利（前 3 位完成人），制定地方标准、行业标准或国家标准（前 3 位完成人），出版著作，编写教材，在国内外核心期刊发表过学术论文（前 2 位作者）。</p><p>对于应届生最简单的就是三类：</p><ul><li>专利（前三位署名）</li><li>核心期刊（前两位署名）</li><li>软件著作权（前三位署名）</li></ul><p>这三个在校期间都是比较容易拿的，如果都没有的话进入公司，申请专利和软著是比较简单的，专利流程在一年左右，软著会更简单，这里较为敏感不在文章中展开。</p></li></ol><p>综上从职称的角度来看相较于收入是更加快速的，但是需要花费额外的精力，同时这个标准是整个评价体系中最为简单的，可能未来会被打补丁，如果有需求的一定不要拖延。</p><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><ol><li><p>软考真的可以认定为副高职称么？</p><p>经过笔者和实际通过人确定，是可以的。</p></li><li><p>核心期刊的范围是什么？</p><p><img src="https://image.bdwms.com/FoJjKGdEk92Hy2mdXwsO0QxXjJzX"></p></li><li><p>软著可以认定么？</p><p><img src="https://image.bdwms.com/FuaZ4E3dLcBY0gHYSxeDy9JnXbTd"></p></li></ol><p>更多问题可以直接咨询文件表中人才认定的相关部门。</p><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>因为更多资料涉及公司内部，所以这里只是简略版，但是笔者的想法是，如果想要做好一件事情，就需要全力以赴地去准备，以最积极的态度去面对困难，在不可能中寻找出一丝可能性。</p><p>最后祝愿每个人都能收获幸福，包括笔者自己。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://rc.hzrs.hangzhou.gov.cn/articles/detail/6679.html">杭州市高层次人才分类目录（2019年修订版）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 情报库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静夜思（二十）-碎碎念</title>
      <link href="night-thoughts-20/"/>
      <url>night-thoughts-20/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在每一个深夜苦苦思索</p></blockquote><p>delete</p><p>——2021.09.30</p><p>delete</p><p>——2021.10.01</p><p>delete</p><p>——2021.10.02</p><p><del>只是感觉有点可惜，可能会错过很多吧，常常幻想此时的我会更好又该如何呢，我在努力，希望可以，嗯，就这样，未来见。</del></p><p>睡醒又重新想了下，尚未发生的不用去猜，坚定的做自己想做的就可以了，就这样。</p><p>——2021.10.03</p><p>君子如玉，质硬而不荆，色暖而不妖，想要成为这样的人。</p><p>最近一直循环梁博的歌，真是太有魅力了的人了，永远的一身黑色，充满了少年感，边缘，独立，干净，坚持，懂得自己想要什么，我实在太太太太喜欢了！梁博的歌太适合自己一个人开车的时候听了，我的todo list又增加了一个。</p><p>在广州想了好几天，有些问题有了些头绪，有的问题还是没有想明白，暂时就这样吧，回杭后整理重新调整下今年的OKR，希望下半年可以更好吧，遇到有意思的人，有意思的事情，就这样吧，bdwms依旧在路上，继续追寻一切美好。</p><p>——2021.10.04</p><p>嗯，请再给我一点时间。</p><p>——2021.10.05</p><p>想的很多，做的不够多，bdwms的碎碎念就到此为止了，以及下半年会多写写技术博客，之后的扯淡和总结就留到今年结束吧～</p>]]></content>
      
      
      <categories>
          
          <category> 静夜思 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静夜思（十九）-追寻一切美好</title>
      <link href="night-thoughts-19/"/>
      <url>night-thoughts-19/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在每一个深夜苦苦思索</p></blockquote><p>这是一篇很长的总结与思考。</p><p>我将自己沉浸在回忆中，记录下脑海中不断浮现的词汇：</p><p>「流星，太阳，戾气，善良，温暖，责任，自卑，抑郁，自闭，自责，迷茫，抉择，期许，普通，梦想，懒惰，命运，妥协，坚持，孤独，生命，美好，社会，交流，麻木，自大，偏见，贪婪，本心，意义，生理，环境，虚无，快乐，奋斗，焦虑，愤怒，亲情，友情，爱情，比较，浅薄，躲避，失败，成功，语言……」</p><p>我在深夜中回忆着曾经的一年，四年，乃至全部的二十余年时间。将这些零碎的记忆挖掘出，整理成了这些词汇，我想用它们串联起我的生命，希望能对我的计算有所帮助。</p><h2 id="痛苦与自卑"><a href="#痛苦与自卑" class="headerlink" title="痛苦与自卑"></a>痛苦与自卑</h2><p>毫无疑问我的十八岁是痛苦的。曾经的我一度否认自己的痛苦，害怕承认自己的懦弱，自卑，孤僻等等一切负面，然后这却让我越陷越深。总是想要避开人群，不让自己的灰色能量影响到别人，于是进行自我隔离，生理和心理都是如此。仔细想想从高三开始就很少从心底感到快乐，越来越少和人交流。</p><p>再仔细深究痛苦和自卑的由来，无非不过家庭环境，成长经历，自我选择这几种因素，但是似乎也并没有什么大挫折，可能是缺乏陪伴和理解，以及常常钻牛角尖让自己的性格和状态逐渐滑坡，不断的负反馈导致了最终的结果。明明知道自我否定是不对的，但依然沉溺于悲伤去逃避。</p><p>我也曾尝试过自救，希望高考后能去念心理学，想要去北师大念心理学，不过可惜高考的发挥也是一般，毕竟状态这么差去考试结局也是想当然的，最后用排除法去了一所从来没有听过名字的学校。不过算是不幸中之大幸，在成都竟然找到了新的自己。</p><p>写下这一段并不是为了博取什么同情，只是现在的我知道，只有正视自己的抑郁，不再否认它，才能更好的生活。</p><p>是的，我曾经很痛苦，普通而又真实的痛苦。</p><h2 id="接受自我"><a href="#接受自我" class="headerlink" title="接受自我"></a>接受自我</h2><p>第一件重要的事就是接受自我。那时候的自己绕着学校跑步，可能也是身体最好的时候（笑），天天泡在图书馆自闭式学习，有时也会强迫自己去参加活动，志愿者，演讲等等。明明不怎么喜欢和人过于接近，却还要带着笑脸去沟通，最后甚至成为了青年志愿者协会的负责人，真是有点佩服自己的忍耐力。</p><p>我知道自己不是个自觉的人，在一个环境下就会随波逐流，于是我总是努力将自己扔出自己的舒适圈，去融入到新的地方。感谢这一点小倔强，让自己能够很幸运遇到很多牛人，加入了两个工作室微光和CNSS。在CNSS里面当然是垫底人群，看着很多优秀的人，他们有的从小学就玩计算机，有的是天赋异禀型选手，有的是能够为了热爱的东西付出超出想象的精力，很高兴自己能够从发这些人身上学习到很多，也是因此才能真正迈入互联网这个行业。还有就是在微光工作室的时期，那时候我们什么都没有，几个人被招新进来就是放养，没有人告诉我们应该去做什么，去学习什么，遇到问题怎么解决，应该选择什么样的方向，甚至连座位都是蹭别人的。我们只能自力更生，踩坑摸黑，其中的困难不想再赘述，但是很感谢有那么一群人陪伴我成长，也是让我解开心结的重要助力，感谢。</p><p>人们说接受自己的平庸才会成长，但是我想接受平庸并非懦弱放弃，而是学会敬畏，明白自己所知有限，所行有界，因此既不傲慢自大去想掌控一切，同时切记妄自菲薄。我非常喜欢《头脑特工队》，快乐还是悲伤同样重要，何必害怕去展露悲伤，想笑就笑，想哭就哭，只要尊重别人，不影响到他人，我又何必在乎什么不重要的事情呢。大学四年，我想我逐渐补全了自己的性格缺陷，不再会与人接触感到厌恶，不再总是将错误归结于自己，不再将自己封闭内心高墙中。我渐渐学会了如何取悦自己，如何为自己寻找快乐，如何自爱。</p><p>可能依旧还有很多事情我不懂，很多错误我会犯，很多人我会错过，但是我已经学会了如何爱自己，学会接受自我，请再给我一点时间去努力。</p><h2 id="未来有一个人在等待"><a href="#未来有一个人在等待" class="headerlink" title="未来有一个人在等待"></a>未来有一个人在等待</h2><p>大一的时候，我想过未来我会成为一个什么样的人，又会遇到什么样的人。「未来有一个人在等待」，四年来都是我博客的标题，我相信着自己会遇到一个美好的人，一个简单幼稚的信念一直支撑着我。再回头看看自己写下的承诺，感到青涩但是我并不羞耻，我很开心我一直没有忘记我想要的是什么，实现途中可能有挫折，但是大方向一直未变过。</p><blockquote><p>我为什么要努力？<br>因为，我希望在未来的自己有能力去守护自己所爱，去寻找灵魂失去的那部分，想做那个最坚硬的盾。</p><p>我想当我遇到那个我心爱的姑娘时，自己足够的优秀去追求她，不会被现实的物质阻碍，不会因为没钱没房而没有能力去给她一个真正的承诺。我知道爱我的她也许愿意和我一起承担现实的压力，但是身为一个有担当的男人我不愿她吃一点苦。我想，在我尚未遇到她的时间里，变得足够强大，有能力给她一个最起码物质上富足的家，我畏惧在未来，我们会哭泣着因为生活的窘迫而分离，我害怕明日平庸的我无法与她般配。我努力，我来为她搭好一个家。</p><p>我想当面对亲人遭受疾病的侵袭时，不用因为没有钱而无法提供最好的医疗条件，我不想那些爱我的人遭受病魔的折磨时却束手无策。我见过死亡，那是沉重的，那是轻飘飘的，我永远记得那一张纸厚的破布盖在那个无名女子身上，蓝色的衣角，赤裸的双足，沉重的车轮，今日回想，感到凉意万分，我不会去选择忘记，我要将这种感觉牢记在心中，提醒着我生命的脆弱与可贵。我希望未来的自己足够强大，强大到能与病魔扳手腕，强大到能从死神手中夺回属于自己的爱。我努力，我来为他们驱走所有的疾苦。</p><p>我想在我再次独自面对孤独抑郁时，有能力去拯救自己。我想当我精神空虚时，最起码物质充足（笑），我能了解自己为什么会难过，能不仅仅是沉溺着迷于悲伤的自我安慰中，能够通过阅读思考提升自己的辨识能力。</p><p>——17.11.23</p></blockquote><p>我为自己寻找到了性格中所欠缺的部分，一直没有忘记真正想要的是什么。曾经以为未来的那个人是个具象的她，但是随着我的思考和成长，那个她逐渐在我的脑海中丰满了起来，她本应该就是我，是我所希望成为的一个人，善良，负责，智慧，坚强……这些我所追寻的品质就是未来的她，在未来等待着我。</p><h2 id="迷茫与幸运"><a href="#迷茫与幸运" class="headerlink" title="迷茫与幸运"></a>迷茫与幸运</h2><p>四年来，迷茫总是不断在我的生活中出现，有时很羡慕一些同学可以无忧无虑的享受大学生活，对于我来说从大二结束，就开始奔赴各地去实习了，在学校的时间总是短暂和充实的。工作室的几个人就像是被打着催熟剂一样，在学校，实习，还是正式工作都反复思考着未来，我们互相质问很多东西，担忧很多东西，同样也憧憬很多东西，我知道各自都有想法，有时候还经常被当作混了几年的老油条子（笑，表面镇定，内心还是非常紧张的。</p><p>关于未来的选择，总结下来无非读研，出国，就业三条路，在我们学院很少人直接就业，我也不知道自己的选择是否一定正确。我不想继续读研，因为我知道读研并不能缓解我的焦虑，无论是从能力，还是心理来说可能提升并不大，三年下来也许只是一张文凭。同样我对互联网行业在中国保持着悲观的态度，同样是当年大热的土木工程，从零八年大建设到一三一四年没落，连短短十年的时间都没有，对于互联网这个年轻的行业来说，从一五年逐渐掀起的浪潮至今也有六七年了，我已经没有时间再用三年去赌一个未来，所以这条路在我这里行不通。</p><p>对于出国，去加拿大的两个月的确是我大学中难得的快乐时光。自由与轻松是主旋律，这里没有高度内卷，人均资源的丰富，发达国家的先进的确让人觉得是个适宜居住的好地方，但是跳脱出这样的心情，很遗憾地表示这里并非我的归处，当地人的友好更多还是礼貌，对于亚洲黄种人的歧视还是隐藏在深处，同样个人对家乡的眷恋也让我无法抉择去出国。再美好的东西，不是自己的，也没法强求。</p><p>就业当然也不是完美的选择，我知道中国互联网的发展畸形，但是对于这个充满魅力的世界我实在无法放弃。互联网可能是我第一个热爱的东西，尤记得第一次实习，在长亭科技的时候，可以专心于技术，见到了phithon p牛p师傅，遇到了我的mentor，遇到了各路黑客大神。可以想象么，一个从未亲自前往的世界，通过互联网就可以触手可及，信息不再闭塞被少部分人占有，一个渺小的个体没有大量的生产资本就可以创造巨大的价值。我认为我很幸运可以参与到这样一场社会变革，高考填写志愿时排除了理科，医生，老师等等，一心想做一些实事，很幸运捡漏来了成电，能让自己走上互联网的路。</p><h2 id="保持愤怒，保持激情"><a href="#保持愤怒，保持激情" class="headerlink" title="保持愤怒，保持激情"></a>保持愤怒，保持激情</h2><p>随着年龄的增长，有时会突然发现自己对很多事物丧失了好奇心，「魔术帽中的兔子」不能再令我感到惊奇。这是一件很可怕的事情，当习惯于每天的重复劳动，习惯于一些不公平的事，习惯自己的固化，那么我想我的生命就开始打了折扣，一年中属于自己的时光到底还剩几天，说的话有什么意义，做的事情有什么价值。</p><p>所以我很羡慕那些拥有自己热爱的朋友，他们正是我生活路上最该学习的榜样。大学四年可能我暂时仅仅学会了满足自己的内心，跳出固定的视角来看自己确实不够有趣，在可预见的将来我也会对自己感到枯燥乏味，所以我打算在未来的几年内寻找尝试各种可能性，付出精力去发掘内心的激情。在我看来，人一生如果有一两件值得奋斗，保持快乐的事情就已经是十分幸运了，那目前来看互联网算是我一个热爱的，我也会继续努力去培养下一个。</p><p>至于愤怒，则是一种不妥协，错误的事情永远不会承认其合理，存在并非合理，当我面对不公平，不正义的事情时依旧能说不，用自己的思考去对抗麻木不仁。社会是灰色的，但这不是我放弃是非观念的理由。智慧解决问题的前提是有一颗坚定的心，如果当某天我冷漠不已，那么我一定会痛恨自己。保持愤怒，永远对错的说不。</p><h2 id="关于爱"><a href="#关于爱" class="headerlink" title="关于爱"></a>关于爱</h2><p>关于爱，必须承认我是个初学者。我想的是爱别人首先需要爱自己，也因此很长一段时间一直拒绝别人，因为害怕伤害别人，那时还不会爱自己，没有精力去照顾别人。但是我依然坚定自己的信念，我会保持自己最大的尊重。</p><p>过去很长时间都是一个人，一个人看电影，一个人去旅游，一个人去音乐节，一个人去医院……但是却很少感到孤独，我在思考一个问题，两个人在一起的原因和目的是什么，很难给出一个准确的答案，我只能暂时归纳于几点生理限制，社会责任，精神需求。对于爱，我真的很笨，很迟钝，或许在未来的很长一段时间我还是会处于这种状态，像个傻瓜一样一个人吧。目前看来，我只知道去让自己变得更加优秀，更加积极的去准备未来可能发生的一切，可能还远远不够，但是我会坚持的。</p><p>加油去学会爱吧，想要成为一个懂得爱的成年人。</p><h2 id="物质和精神"><a href="#物质和精神" class="headerlink" title="物质和精神"></a>物质和精神</h2><p>我自认为是一个「积极的悲观者」，面对物质需求总是抱着悲观态度，却还是积极的去准备，当然现实可能既没有那么坏，也没有那么好。我认为大部分的精神需求都是建立在物质需求的基础之上的，当然两者是相互作用的，所以我一直对很多事情怀着否认的态度，例如异地恋，例如家庭背景差距过大的婚姻等等这样的例子。以我的观点，一个健康的循环是物质充盈和精神饱满同时匹配的，当两者错位过多，只会造成悲剧的结果。</p><p>当然我并不是指物质完全决定精神，好比家人一直劝我早点在杭州落户买房，我内心当然知道尽早上车的好处，也的确去实践调查过一番，但是在思来想去很难对这座城市有驻足的念想，这里没有我所爱的人，没有我成长的经历，没有我值得留念的。行动上积极打算，内心却悲观展望，可能这就是我吧，也希望在未来，能遇到对的人，希望这座城市能有让我留下的理由。</p><p>对于现实和理想，我想用最理性的方式去解决问题，坚定不移地去用计划去支撑理想。如何平衡好物质追求与精神追求可能是我这几年里最为困难的事了，在互联网这个精彩到令人眼花缭乱的世界，希望自己依旧能保持一份清明。</p><h2 id="责任与善良"><a href="#责任与善良" class="headerlink" title="责任与善良"></a>责任与善良</h2><p>关于未来十年，我能想到最重要的两个关键词就是责任和善良。</p><p>我想要成为一个负责任的人，能够在面对困难时挺身而出，做个别人能够信赖的人。我能够为自己的言行负责，能够为自己许下的诺言负责，能够为他人托付的信任负责。说一不二，坚韧果决，我选择的责任一定会用尽全力完成。这就是我希望在我三十岁时能够达到的状态。当然，这很困难，无论是从能力与物质基础出发，还是从内心理念来说，都是需要长期的培养才可能形成的品质，漫漫长征路上为自己逐年规划更加细节的目标，在未来的每一年里都能够逐渐的成长。</p><p>另一个关键词就是善良，我总说妈妈是个自来熟，热心肠的人，妈妈也告诉我从未见过面的外婆那时候也是被外人称赞的大好人，所以我当然也想要成为一个好人，成为一个善良的人。「我认为你选择大雄是完全正确的，那个年轻人会为别人的幸福而高兴，为别人的不幸而伤心。这对于一个人来说是最重要的事情」，和大雄一样，我同样希望能够成为一个有同理心的人，在每一次抉择时都能够无愧自己的内心，去选择善良。这个世界已经够黑暗了，我希望自己能保留那一份善意，留给需要的人。</p><p>这就是我的十年愿景，从步入社会的那一天给自己许下的誓言，期待着未来的我吧。</p><h2 id="追寻一切美好"><a href="#追寻一切美好" class="headerlink" title="追寻一切美好"></a>追寻一切美好</h2><p>最后的最后，我回忆了过去的经历，那些依然能在我脑海中闪过的画面总是那么美好：</p><p>是深夜学校的枫叶大道上，一个人仰望星空的感受；</p><p>是离开加拿大的班车上，掠过我眼前的难舍画面；</p><p>是和弟弟在工作室通宵奋斗，一起乱唱的rap；</p><p>是在草莓音乐节，狂欢蹦跳的快乐；</p><p>是夕阳下的西安古城墙，我独自思索的宁静；</p><p>是重庆江边，耳机中Radwimps的《告白》；</p><p>是北京天安门前，只有我一人时的震撼；</p><p>是厦门旅行时的彷徨；</p><p>是杭州河边的不甘心；</p><p>是成都小酒馆的最后一聚，出租车上的《送战友》；</p><p>是向朋友家人哭泣，落下的泪水；</p><p>是我感受到成长的快乐；</p><p>是我对遇到更美好的世界，遇到你的憧憬；</p><p>……</p><p>十四亿分之一，浩瀚与渺小两相交映，我的人生仿佛一道流星划过，不知是否能成为一瞬的微光，点亮你我。</p><p>我将怀抱希望继续前进，去追寻一切的美好。</p><p>再会！</p>]]></content>
      
      
      <categories>
          
          <category> 静夜思 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人家庭影音系统</title>
      <link href="home-video-system/"/>
      <url>home-video-system/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于OpenWrt以及闲置硬件打造一个简易版的家庭影音管理系统。</p></blockquote><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>笔者有收藏电影，MV，音频，照片的需求，在体量还比较小的时候，依赖文件命名分层来进行管理还是足够的。但是当量级达到TB后，简单的文件夹管理已经不够了，存在下面几个问题：</p><ul><li>文件夹层级过深，电影等打标元数据复杂。</li><li>缺乏预览图片，类型打标搜索等能力，数据可视化困难。</li><li>难以随时浏览，必须启动电脑来做数据入口。</li></ul><p>为此，针对以上问题，笔者总结了几点需求：</p><ul><li>自动化打标，分类。</li><li>数据可视化，提供预览能力。</li><li>局域网内随时可访问（暂时没有广域网需求）。</li></ul><p>经过调研，最简单的方案是比较成熟的群辉，但是最近市场硬盘太贵，决定还是自己DIY，依赖已有的能力去搭建一个局域网网络环境。</p><h2 id="基本条件"><a href="#基本条件" class="headerlink" title="基本条件"></a>基本条件</h2><ul><li>路由器：Linksys wrt32x，支持千兆网络，一个USB3.0接口，一个USB2.0接口</li><li>硬盘：闲置的希捷酷鱼4T，并补充了一个绿联硬盘盒</li><li>笔记本：闲置暗夜精灵3，大学用的游戏本，现在主要来做拓展功能</li><li>网络：移动百兆宽带</li></ul><p>路由器是之前双十一半价700入手，一直只是作为普通路由器使用，这次决定进行升级改造，基于OpenWrt加外挂硬盘，并配合docker来进行支持服务，能够拥有更高的可玩性。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="固件编译"><a href="#固件编译" class="headerlink" title="固件编译"></a>固件编译</h3><p>OpenWrt版本选择<a href="https://github.com/coolsnowwolf/lede">lean</a>大的版本，维护良好，插件众多，并开源易定制化，本次采用本地编译的方式。</p><ol><li><p>Ubuntu20.04 vmware安装</p></li><li><p>配置qv2ray代理，配置好v2ray-core等依赖环境，确保能够稳定科学上网。</p></li><li><p>安装proxychains-ng来作为命令行代理，注意设置配置文件中不代理本地IP。</p></li><li><p>配置Golang最新版本，并设置GOPROXY代理，某些插件可能依赖go库（很奇怪proxychains没有代理到go mod，只能单独配置下GOPROXY代理）</p></li><li><p><a href="https://github.com/coolsnowwolf/lede">https://github.com/coolsnowwolf/lede</a> 按介绍进行编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/coolsnowwolf/lede.git</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch python3 python2.7 unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib antlr3 gperf wget curl swig rsync <span class="built_in">realpath</span></span><br><span class="line"><span class="built_in">cd</span> lede</span><br><span class="line">./scripts/feeds update -a &amp;&amp; ./scripts/feeds install -a</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p><img src="https://image.bdwms.com/FtM5HdZJhnesauWZfY2byUPWIusR"></p></li><li><p>根据<a href="https://ssr.tools/1366%E9%80%89%E6%8B%A9%E7%9B%B8%E5%BA%94%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%AC%94%E8%80%85%E7%9A%84%E6%98%AFwrt32x%E3%80%82">https://ssr.tools/1366选择相应的配置，笔者的是wrt32x。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Target System : Marvell EBU Armada</span><br><span class="line">Subtarget : Marvell Armada 37x/38x/XP</span><br><span class="line">Target Profile : Linksys WRT32x</span><br></pre></td></tr></table></figure></li><li><p>第一次编译时不选择多余的插件，确保主模块能够顺利编译，首次编译可能需要2到3个小时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 make -j8 download V=s 使用代理下载依赖库</span><br><span class="line">make -j1 V=s 第一次使用单线程编译方便定位出错</span><br></pre></td></tr></table></figure><p>如果成功编译，输出的文件在bin&#x2F;target中。</p></li><li><p>第二次重新编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ./tmp &amp;&amp; rm -rf .config 删除原本的配置</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>以安装docker为例子选择所需的选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Target System : Marvell EBU Armada</span><br><span class="line">Subtarget : Marvell Armada 37x/38x/XP</span><br><span class="line">Target Profile : Linksys WRT32x</span><br><span class="line">Extra packages : automount autosamba ipv6helper</span><br><span class="line">LuCi-&gt;Collections :</span><br><span class="line">luci-lib-docker （luci与docker交互的api,dockerman需要使用的库）</span><br><span class="line">LuCi-&gt;Applications :  </span><br><span class="line">luci-app-docker （lean编写的docker界面，勾选后将会自动勾选dockerd服务端）</span><br><span class="line">Utilities :</span><br><span class="line">docker （docker命令行工具）</span><br><span class="line">dockerd (docker-ce，docker的服务端程序)</span><br></pre></td></tr></table></figure><p>第二次重新编译可以选择多线程编译，如果出错的话可以尝试用单线程编译定位错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j$(($(nproc) + 1)) V=s</span><br></pre></td></tr></table></figure><p>如果需要拉取更新后编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">./scripts/feeds update -a &amp;&amp; ./scripts/feeds install -a</span><br><span class="line">make defconfig</span><br><span class="line">make -j8 download</span><br><span class="line">make -j$(($(nproc) + 1)) V=s</span><br></pre></td></tr></table></figure></li></ol><h3 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h3><p>对于linksys wrt32x是拥有双分区来保证刷不死特性，具体不在这里赘述，</p><ol><li><p>将img固件从虚拟机中复制出来，如果不在原厂分区，切换到原厂固件分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/fw_printenv -n boot_part 当前分区号</span><br><span class="line">/usr/sbin/fw_setenv boot_part 1 &amp;&amp; reboot 切换分区</span><br><span class="line">/usr/sbin/fw_setenv boot_part 2 &amp;&amp; reboot</span><br></pre></td></tr></table></figure></li><li><p>moxeterm ssh连接然后将img固件上传并升级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysupgrade -n -v ***.img</span><br></pre></td></tr></table></figure></li><li><p>重新连接WiFi，ssh连接后lsblk查看硬盘信息，假如之前硬盘没有分区，利用cfdisk将硬盘划分为三个区，cfdisk分三个区分别给</p><ul><li>overlay(sda2:3G)：作为openwrt的软件层，存储各类工具软件，需要进行扩容。</li><li>docker(sda3:30G)：存储docker的根目录。</li><li>剩余容量存储挂载(sda4)：作为影音存储。</li></ul><p>然后Write进去并重启路由器。</p></li><li><p>格式化硬盘为ext4格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda2</span><br><span class="line">mkfs.ext4 /dev/sda3</span><br><span class="line">mkfs.ext4 /dev/sda4</span><br></pre></td></tr></table></figure></li><li><p>挂载刚刚的三个分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda2 /mnt/sda2</span><br><span class="line">mount /dev/sda3 /mnt/sda3</span><br><span class="line">mount /dev/sda4 /mnt/sda4</span><br></pre></td></tr></table></figure></li><li><p>备份overlay的配置，否则之后重启路由器后会丢失配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r /overlay/* /mnt/sda2</span><br></pre></td></tr></table></figure><p>   如果有upper和work说明正确</p></li><li><p>启用挂载点，在web界面挂载点中挂载overlay的sda2和docker的sda3</p></li><li><p>重启路由器，看系统-软件包是否扩容成功</p><p><img src="https://image.bdwms.com/FrzMbKeWyARBv3JpFPOXtp-mcRq5"></p></li><li><p>&#x2F;etc&#x2F;docker&#x2F;daemon.json更换docker国内源，在面板启动项中重启dockerd，或者&#x2F;etc&#x2F;init.d&#x2F;dockerd restart，重启,docker info查看是否成功</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://b2tx75ys.mirror.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://dockerhub.azk8s.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data-root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/opt/&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;log-level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;warn&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>使用&#x2F;etc&#x2F;docker-web启用portainer docker管理界面，其实就是命令，ip:9999就是portainer管理界面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always --name=&quot;portainer&quot; -p 9999:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce</span><br></pre></td></tr></table></figure><p><img src="https://image.bdwms.com/FhLfYTiVlYFA4CnCkzW8JQYz-YKT"></p></li><li><p>使用Jellyfin镜像作为影音管理系统，Jellyfin的使用不再赘述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull jellyfin/jellyfin:latest</span><br><span class="line">mkdir -p /dev/sda4/jellyfin/&#123;config,cache,media&#125;</span><br><span class="line">docker run -d --restart=always --name=&quot;myJellyfin&quot; -p 8096:8096 -v /mnt/sda4/jellyfin/config:/config -v /mnt/sda4/jellyfin/cache:/cache -v /mnt/sda4/jellyfin/media/:/media jellyfin/jellyfin:latest</span><br></pre></td></tr></table></figure></li><li><p>ip:8096就可以访问到Jellyfin，然后就可以进行常规的配置了</p></li><li><p>网络共享中可以将sda4分享出去，注意权限0777，修改invaliduser，并设置samba密码</p></li></ol><h3 id="网络唤醒"><a href="#网络唤醒" class="headerlink" title="网络唤醒"></a>网络唤醒</h3><ul><li>闲置笔记本惠普暗夜精灵3，两块移动硬盘</li><li>将笔记本作为主机合盖使用，节约空间</li></ul><p>所以基于以上条件使用wake on lan技术作为网络唤醒</p><ol><li>将BIOS系统升级到最新版本，操作参考惠普官网。</li><li>F10进入BIOS开启网络唤醒的选项。</li><li>进入win10的设备管理器，修改有线网卡驱动的选项，开启网络唤醒选项，确保魔术封包支持开启。</li><li>win10下载wake on lan软件，用于测试。</li><li>安卓端下载极致工具箱，配置mac地址，电脑坐在网络段，端口默认9。</li><li>安卓端发送测试包，wake on lan打开封包监控管理工具接受魔术封包，如果能够接受到，基本说明成功。</li><li>网线连接路由器Lan口和电脑网口，关机后后手机端发送网络唤醒请求，理论上可以唤醒成功。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://ssr.tools/1369">Lean Lede编译方法</a></p></li><li><p><a href="https://www.right.com.cn/forum/thread-1180536-1-1.html">WRT32X刷回原厂固件和第三方固件</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/29100706">网络唤醒全攻略(Wake On LAN)</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1Up4y1z7ua">在OpenWRT上安装Docker &amp; OpenWRT插件安装教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自建情报库-财务篇</title>
      <link href="information-database-finance/"/>
      <url>information-database-finance/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自建情报库系列是一套信息收集方法论，目的是为了帮助毕业生建立必备的知识情报体系，从而更好地迈入社会。本系列将会从住房，政策，经济，医疗等方面进行概括性的叙述，形成一条完整的知识链路，作为之后付诸行动的个人信息门户。</p></blockquote><p>“财务管理与其说是理财，不如说是理人。”</p><p>在正式工作之前笔者一直对泛金融类的方向抱有消极态度，高考志愿填报时因认为金融只是消耗分配价值，没有直接创造价值而放弃。但是随着时间流逝，更多的接触社会，却也有了一些不同的看法。在这个物欲横流的社会，毕业生很容易会为钱所困，这也是笔者正在经历并且想要解决的。形形色色的问题扑面而来 ，例如：</p><ul><li>越有钱就会越快乐么？</li><li>为什么我总是月光？</li><li>怎么过上想要的生活？</li><li>害怕35岁被开除怎么办？</li><li>……</li></ul><p>这些问题或多或少与钱相关，交织如麻下显得很复杂 ，因此笔者在这篇文章中准备以基本的理念为原点，逐渐向外拓展，力图勾勒出一个完整的理财印象，并最终能够解答以上的困惑。</p><h2 id="什么是理财"><a href="#什么是理财" class="headerlink" title="什么是理财"></a>什么是理财</h2><p>很多人将理财简单地定义成通过资产管理从而保证增值，但实际上资产管理仅仅是整个理财体系中的一部分。在笔者看来完整的理财包括：</p><ul><li>定义生活目标</li><li>摸清财务状况</li><li>建立理财体系</li><li>动态反馈调整</li></ul><p>从自身的条件出发（包括家庭环境，性格偏向，能力水平等），能够给出一个符合<a href="https://zh.wikipedia.org/wiki/SMART%E5%8E%9F%E5%88%99">SMART原则</a>的目标。之后开始全面摸清个人乃至整个家庭的财务状况，包括收入支出，资产负债等。有了这些基本数据后，就可以根据需求制定具体理财计划，包括现金流如何分配，选择怎样的理财产品，收益风险比如何取舍等等。最后，因为计划的不合理，市场环境的复杂，个人需求的更变各种因素影响下，每年的理财计划必然是需要做调整修正的。</p><p>在这些步骤中，笔者想要着重强调几点：</p><ul><li><p>复杂关联</p><p>理财不仅仅包括现金储蓄，还与投资，房产，保险，教育，养老等众多因素强相关，恰如一串珍珠项链，牵一发而动全身，这就要求从更加宏观的角度去考虑问题，切勿钻入牛角尖。</p></li><li><p>时间周期</p><p>理财具有生命周期性，在不同年龄段需要注意的重点不同。从22岁左右毕业，到30岁左右结婚生子，一直持续到65退休，个人的财务状况都是不断变化的，并且可能伴随着两个家庭的融合，所以会更加复杂，需要抱有动态的理念。这里读者可以关注下即将发布的第七次人口普查结果，判断自己处于哪一人生阶段，进而制定相应的计划。</p><p><img src="https://image.bdwms.com/FghabsMrI7OO9Txu399UTQdz_U-m"></p></li><li><p>非正比相关</p><p>在笔者的观察中，财富与幸福感并非严格意义上的正相关，在某一临界点前，财富的增长对幸福值具有显著的影响，但当超过临界范围后，影响因子就会呈下降态势。由此可以看出来，过度追求财富膨胀是不理智的，但同样幸运的是我们可以调整个人的临界点获取更多的幸福感。</p><p><img src="https://image.bdwms.com/FpSmNxQng1PkUqCfgaNV3JaC7i0V"></p></li></ul><h2 id="金钱观和财务目标"><a href="#金钱观和财务目标" class="headerlink" title="金钱观和财务目标"></a>金钱观和财务目标</h2><p>人物质生活的基础（生理），人与人之间的关系（社会），人内心的欲望驱动（心理），这三者一定程度上都可以通过“钱”这样东西来体现与衡量，因此笔者更愿意将财务管理中的“钱”称作“生活的一般等价物”。而金钱就像一个放大镜，它能帮你充分地展现出你本来的样子，为此更需要保持平常心去对待。</p><p>围绕着财务管理的生活目标同样可以通过时间进行划分。笔者自身初步设定的目标如下：</p><ul><li>一年计划：理清收入支出；划分完成资产负债；了解基金投资方式。</li><li>三年规划：了解主流理财方式；积累原始资金。</li><li>十年愿景：拥有一项稳定副业；被动收入与主动收入持平。</li></ul><p>更加具体的细节不在此展开，一年之后再做复盘。笔者本身抱着稳健的态度，也同样建议没有足够资本的年轻人应该稳扎稳打为主。</p><h2 id="财务状况和消费习惯"><a href="#财务状况和消费习惯" class="headerlink" title="财务状况和消费习惯"></a>财务状况和消费习惯</h2><p>笔者认为梳理财务状况，培养正确消费习惯是年轻人最先需要关注的，很多人月光的原因就是缺乏一个输入输出的规划，形成了不良的消费习惯。</p><p>简单执行三步：</p><ol><li>记账：第一步就是学会记账。无论是手工记账，还是使用APP，都是为了掌握自己每个月的收支金额，花费种类等等。笔者使用松鼠记账已经坚持4个多月，基本掌握了自己的必要支出（房租水电等），非必要支出（娱乐电子等），主动收入，被动收入。</li><li>预算：拥有一定时间维度的数据作为参考后，就可以做预算计划了。划分出必要的生活支出，削减非必要输出，分配可用现金等等。</li><li>储蓄：需要着重强调的是储蓄，因为年轻人可动用的现金流较少，想要积累到第一笔启动资金——“下金蛋的鹅”，那么长期储蓄就是最切合实际的，工资到账的第一时间就将一部分钱转移到指定账户。</li></ol><h2 id="常见投资与重点"><a href="#常见投资与重点" class="headerlink" title="常见投资与重点"></a>常见投资与重点</h2><p>年轻人投资第一要义——<strong>投资自我</strong>。在职业生涯的前期，因为缺乏足够的资本（本金与财务知识），收益回报是很低的，所以笔者不建议花费超过30%的精力在理财上，提升专业技能，积累原始资金，适当了解基本的投资方式才是合理的规划。为此在学习了解过投资知识后，可以根据自身的财务状况，分配一定数量的资金作为试水练手。注意，缺乏了解的投资就是赌博，而赌博必输。</p><p>一些常见的投资方式：</p><p><img src="https://image.bdwms.com/FpPGqyPsSWwJnlHr0dRYgD56Gbah"></p><ul><li>债券：代表一种债权，提前约定收益，收益较低，利息不受经营的影响，风险较小。</li><li>基金：代表一种委托关系，委托专业机构帮你理财，分为多种类型的基金，收益受专业机构的理财能力影响，一般而言，收益小于股票，大于债券，相对应，风险小于股票，大于债券。</li><li>股票：代表一种股权（拥有权），享受经营的分红，收益较高，同时承担经营的风险，风险较大。</li><li>保险：保险的目的是削峰，开始时基本的五险一金就足够了，后期随着家庭形成可以逐步安排各种商业保险。</li><li>房产：需要一定的原始资金，而年轻人一般第一套都是刚需房，这里同样不展开。</li></ul><p>更高风险的项目例如期货，外汇，实体投资暂时不建议涉足。笔者目前的目标就是在第一年中专注基金项目，充分了解基金，大致分配10%到20%的流动现金来试手，收益不设硬性指标，主要目的还是专注于知识的积累。</p><p>几个值得关注的特性：</p><ul><li><p>复利：通过长期投入精力与资金，以原始资本为起点，形成滚雪球式的增长，最终达到财务自由的目标。</p></li><li><p>资产与负债：能够带来现金流的资产，消耗现金流的是负债。但是负债也不一定是糟糕的，例如在国内购置优质房产。但我们最终的目的还是通过资产带来的正向现金流覆盖消费，完成财务自由。</p></li><li><p>风险与收益：风险与收益永远应该围绕自己的人生目标去制定，不做金钱的奴隶追求赌博的快感。</p></li></ul><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>在人们眼中钱本应该是一种再自然、再普通不过的东西了，将财务管理作为生活的工具才是钱的归处。笔者在这篇文章中没有过多地阐述理财投资的执行细节，自身经验知识的不足与个体的差异化是一部分原因，但更重要地还是想要强调以人为本的理念。</p><p>希望诸君都能通过财务管理收获幸福。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/SMART%E5%8E%9F%E5%88%99">SMART原则</a></li><li><a href="https://www.zhihu.com/question/19575803/answer/859738016">个人理财有哪些基本原理和方法？ - 兴哥的回答 - 知乎</a> </li><li><a href="https://book.douban.com/subject/1095634/">《小狗钱钱》</a></li><li><a href="https://book.douban.com/subject/1033778/">《富爸爸穷爸爸》</a></li><li><a href="https://book.douban.com/subject/4249967//">《财务自由之路》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 情报库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自建情报库-医疗篇</title>
      <link href="information-database-medical-health/"/>
      <url>information-database-medical-health/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自建情报库系列是一套信息收集方法论，目的是为了帮助毕业生建立必备的知识情报体系，从而更好地迈入社会。本系列将会从住房，政策，经济，医疗等方面进行概括性的叙述，形成一条完整的知识链路，作为之后付诸行动的个人信息门户。</p></blockquote><p>根据资料显示截止2019底，中国人均预期寿命为77.3岁，如果以本科毕业22岁开始计算，那么乐观情况下笔者还有两万天左右的时间。因此为了能够更好的为祖国健康工作五十年，了解一些基本的医疗健康常识是必须的。笔者在这篇文章中会从基本的医疗健康理念谈起，之后从正式就医和家庭健康两个方面进行展开，组织梳理出一个基本的知识结构，方便读者以及笔者本人自查自纠。</p><h2 id="基本理念"><a href="#基本理念" class="headerlink" title="基本理念"></a>基本理念</h2><p>思想指导行动，没有一个统一的基本思想，我们很难组织起能够长期坚持的实际行动。笔者在这里总结了个人认为最重要的三点：</p><ul><li><p>专业性</p><p>医疗相关问题具有极强的专业性特征，所以我们必须首先明确的就是<strong>谨遵医嘱</strong>，以医生的要求为第一指示，不自我诊断，不相信偏方，不“百度看病”。</p></li><li><p>及时性</p><p>及时性指的是当身体出现不适症状时，不拖延，不怀侥幸心理，宁可信其有不可信其无。及时到医院就诊，查清自身状况，避免将小病拖成大病的惨剧发生。</p></li><li><p>长期性</p><p>强健的身体与心理不是一蹴而就，需要的是个人长期坚持健康生活。例如进行规律锻炼，良好作息，定时检查等等多方面，长期地维护培养。</p></li></ul><h2 id="就医相关"><a href="#就医相关" class="headerlink" title="就医相关"></a>就医相关</h2><p>这一部分主要涉及到基本的医院常识，不同的就医形式是如何具体执行的。注意因为各个地区医院的具体规定不同，以下仅作简单参考，详细步骤请读者自行搜索查阅有关资料。</p><h3 id="医院类别"><a href="#医院类别" class="headerlink" title="医院类别"></a>医院类别</h3><p>中国实行三级医疗服务体系，各个等级分为甲、乙两等，三级甲等为最高级别。选择医院就医时可以参考医院等级，擅长项目，挂号难度等进行综合选择。除医院外，还有为数众多的基层卫生所等机构，截止2019年末，统计数据如下图：</p><p><img src="https://image.bdwms.com/Fg2v1G0pAWSNE0r8tMW46Wv1bhkq"></p><p>目前国内的医疗资源也是处于不充足不平衡的状态，顶级资源富集在一线城市，普通人依旧是很难获取到足够的关注，这也是需要我们长期关注的问题，这里暂不展开谈论。</p><h3 id="门诊指南"><a href="#门诊指南" class="headerlink" title="门诊指南"></a>门诊指南</h3><p>针对不同地区，不同级别的医院其门诊就诊方式可能有所不同，例如浙江省第一医院，坐落于互联网较为发达的杭州，其就诊流程已经大部分电子化，一定程度上简化了流程。基本流程为：<code>办卡（就诊卡）——&gt; 挂号 ——&gt; 取号 ——&gt; 就诊区报道 ——&gt; 就诊</code>。整个过程可能存在些许不同，如现在大部分三甲医院已经支持网上预约挂号。以浙大一院为例，门诊流程如下：</p><p><img src="https://image.bdwms.com/Fg6_9SAjJW-WAXU7akIl8nhtgIdx"></p><h3 id="急诊指南"><a href="#急诊指南" class="headerlink" title="急诊指南"></a>急诊指南</h3><p>急诊一般为紧急性状况准备，大型医院一般配有急诊，情况危急下可以先抢救，后办理手续。但是需要注意的是急诊能够处理的项目没有门诊全面，能够开具的药品也是有限的，所以非紧急情况还是应该预约门诊为先。同样以浙大一院为例，流程图如下：</p><p><img src="https://image.bdwms.com/FvMCQRdJ1ML4hf_eR6QfQRnvSl4T"></p><h3 id="医保相关"><a href="#医保相关" class="headerlink" title="医保相关"></a>医保相关</h3><p>城镇职工在企业工作，一般缴纳工资的2%作为医疗保险中的个人缴纳部分，同时公司需要缴纳相应工资的6%以上作为公司部分（根据不同城市的相关规定）。如果是无工作的城镇居民或者农村新农合，不同地区也要一定的缴费标准，之后政府会在此基础上补助每个人一定的财政补贴作为医保经费。缴纳医保后，公民持有医保卡就可以到指定医院就医并报销一定的费用，并且在购买指定药品也可以使用医保消费。综上医疗保险是政府对公民的一项福利补贴行为，公民应该积极守法缴纳医保。</p><p>此外，除了上述的国家医疗保险，还有花样繁多的商业医疗保险，但是笔者不建议年轻人花费过多的时间和金钱纠结于商业保险上，其价值回报大概率会低于实际付出。</p><h2 id="家庭健康"><a href="#家庭健康" class="headerlink" title="家庭健康"></a>家庭健康</h2><p>对于家庭健康护理，主要依赖于基本的医疗常识以及良好的生活习惯，需要抱以长期坚持的心态去维护。在此笔者主要围绕三块来叙述，当然更多的知识需要在日常生活中去积累，良好的习惯也需要长久培养并不断带来正反馈。</p><h3 id="常备药品"><a href="#常备药品" class="headerlink" title="常备药品"></a>常备药品</h3><p>目前线下药店购药十分方便，并且还有互联网一小时达送药服务，所以对于家庭常备药品，只需要准备几种基本的非处方药以防不时之需。同时在用药时一定要谨慎，谨遵医嘱，仔细阅读说明书，了解副作用。这里参考丁香园给出的建议：<a href="https://dxy.com/article/2275%E3%80%82">https://dxy.com/article/2275。</a></p><h3 id="急救常识"><a href="#急救常识" class="headerlink" title="急救常识"></a>急救常识</h3><p>对于一些急救常识，笔者建议可以做一定的了解，当遇到突发情况时还是应该第一时间拨打120，个人急救措施只是为急救医生争取时间。为此一下罗列了个人认为较为重要的方面：</p><ul><li><strong>心肺复苏</strong></li><li><strong>异物卡喉（海姆立克急救法）</strong></li><li><strong>外伤出血包扎</strong></li><li>烫伤</li><li>猫狗抓咬伤</li><li>酒精中毒</li><li>扭伤骨折</li><li>癫痫</li><li>……</li></ul><p>理论知识可以通过自行搜索进行了解，但是为了更好的实践，可以考取一个急救证。急救证分为两种，一类是通过急救中心，红十字会培训的普通急救证（一般费用为200元），另一类是美国AHA心脏协会认可的急救证（一般费用为800元），同样是由急救中心等机构进行培训，不过多了一些例如烫伤，癫痫等急救知识科普。笔者已经考取了AHA急救证，但是个人建议只需要考取200元的普通急救证就足够了。</p><p><img src="https://image.bdwms.com/FlrEmSwg2KCn75qgUqU_BxBU0gck"></p><h3 id="生活习惯"><a href="#生活习惯" class="headerlink" title="生活习惯"></a>生活习惯</h3><p>个人的生活习惯因人而异，但是依旧可以提炼出基本的准则，针对不同的方面我们都可以使用同一套方法论去分析形成一个闭环。大致步骤如下：</p><ol><li>设定目标</li><li>观察自己</li><li>制定计划</li><li>复盘调整</li></ol><p>笔者以个人作息调整为例，说明是如何调整作息到最适应范围。首先明确目标，笔者因为即将正式工作，需要从大学较为散漫的作息时间（上午11点醒，晚上两点睡）调整到能够支撑个人高精力工作的良好作息。</p><p>有了一个目标后，就需要分析目标，观察自身。如何定义高精力，笔者利用为期一个星期左右的时间，对自己办公效率进行打分，半个小时划分，进行合计并计算均值，结合睡眠时长，睡眠时间区域做关联（当然还有其他因素影响例如锻炼，生病等，但是这里暂时未做考量），最后得出结论，个人最少睡眠时间约在7.5至8个小时，最晚入睡时间应该为12:30。</p><p><img src="https://image.bdwms.com/FpqQG2lbr-OH9_-Xfe20oLmadx9M"></p><p>结束观察后，笔者确定了睡眠作息计划，12:30入睡，8:30起床，午休浅睡眠半小时，实际执行后个人工作效率确实得到一定提升。但是复盘过程中也能看到一些其他问题，例如12:30应该进入浅睡眠状态，而非上床，因为真正入睡还需要半个小时左右，综合考量，最后调整为12:00上床关闭手机。</p><p>以上就是笔者如何利用这样一套方法论去调整自己的作息的，读者有兴趣可以进行尝试。</p><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>生命可贵，年轻人切勿挥霍自己的身体资本！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://news.cctv.com/2020/10/29/ARTIJC6WtEbdNGTWZeWpJNuT201029.shtml">居民人均预期寿命4年提高1岁！看看你身边的这些健康变化</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%8C%BB%E9%99%A2%E7%AD%89%E7%BA%A7">中国医院等级</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%8C%BB%E7%96%97%E4%BF%9D%E9%9A%9C">中国医疗保障</a></li><li><a href="https://www.zhihu.com/question/27579766">生活中有哪些必须知道的急救知识-知乎</a></li><li><a href="https://www.zhihu.com/question/296374184">25 岁，有哪些健康的生活习惯值得养成？-知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 情报库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自建情报库-政策篇</title>
      <link href="information-database-policy/"/>
      <url>information-database-policy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自建情报库系列是一套信息收集方法论，目的是为了帮助毕业生建立必备的知识情报体系，从而更好地迈入社会。本系列将会从住房，政策，经济，医疗等方面进行概括性的叙述，形成一条完整的知识链路，作为之后付诸行动的个人信息门户。</p></blockquote><p>中国作为一个政策导向性极强的中央集权国家，金融，教育，医疗，互联网等等不同行业很大程度上都会受到政策因素的影响，从而决定其发展方向。例如笔者所在的网络安全行业，最致命的并非某些技术性漏洞，而是监管部门的监察。所以笔者认为初入社会的年轻人需要保持一定的政治敏感性，了解与自身相关的政策。</p><p>但是因为一些客观因素，本篇文章很难做到令读者全知全解，例如：</p><ul><li>笔者自身社会经验有限。</li><li>政治政策本身客观的复杂性，时效性。</li><li>个人角度（行业，地位，年龄段等）的不同，导致对政策的不同解读。</li></ul><p>所以在本篇文章，笔者想要从初入社会的年轻人这样一个角色，来尝试回答以下几个问题：</p><ol><li>基本的国家政治体系？</li><li>如何快速搜索到与自身相关的政策信息？</li><li>如何较为准确地解读某项政策？</li></ol><h2 id="政治体系"><a href="#政治体系" class="headerlink" title="政治体系"></a>政治体系</h2><p>了解最基本的政治体系有利于从宏观角度去剖析政策，例如整个国家的战略发展都可以从<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E6%B0%91%E7%BB%8F%E6%B5%8E%E5%92%8C%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%E4%BA%94%E5%B9%B4%E8%A7%84%E5%88%92">五年计划</a>中体现，作为个体更应该顺应时代的洪流去抉择自己的方向，避免因信息差而误入夕阳产业。当然，这里仅仅罗列一些最基本的常识，更多信息可参考官方文件以及课本。</p><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><ul><li>共和国主席（虚职），一般同时兼职中国共产党中央委员会总书记和军事委员会主席（实权职位）。</li><li>两会：中华人民共和国<strong>全国人民代表大会</strong>和中国人民政治协商会议，五年一届，每年一次，制定五年计划指导国家发展，同时全国人大作为中国的权力机关。</li></ul><h3 id="党组织"><a href="#党组织" class="headerlink" title="党组织"></a>党组织</h3><p><strong>中国共产党</strong>为执政党，中国共产党全国代表大会为其最高权力机构；在中国共产党全国代表大会闭会时，由中国共产党<strong>中央委员会</strong>领导党的工作；在中央委员会全体会议和中央政治局全体会议闭会期间，<strong>中央政治局常委会</strong>行使中央政治局的职权</p><h3 id="政治组成"><a href="#政治组成" class="headerlink" title="政治组成"></a>政治组成</h3><ul><li><p>权力机关：全国人民代表大会</p></li><li><p>行政机关：权力执行机关。国务院为最高级别，然后是各个下级政府。</p></li><li><p>监察机关：监督公职人员。</p></li><li><p>司法机关：</p><ul><li>人民法院：负责审判。</li><li>检察院：负责收集证据，起诉。</li><li>公安部：负责抓捕。</li></ul></li><li><p>军事委员会：领导全国武装力量。</p></li></ul><h2 id="如何搜索"><a href="#如何搜索" class="headerlink" title="如何搜索"></a>如何搜索</h2><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><p>政策搜索的重点笔者认为有这几点：</p><ol><li>准确性：准确性指的是对政策全貌精准描述，避免只通过几句话就下定论，这样极其容易造成理解偏颇。</li><li>时效性：政策具有明显的时效限制，一段时间内政策可能会多次变化加码，所以需要我们及时更新信息库。</li><li>关联性：政策出台往往是具有极强的关联性，从不同行业，地区多方面作用来达成目标，例如近年来鼓励生育就是从多个角度进行扶持。</li></ol><p>满足以上三点后，就需要甄别信息源，从而建立自己的信息库。</p><h3 id="信息源"><a href="#信息源" class="headerlink" title="信息源"></a>信息源</h3><ol><li><p>政府官网</p><ul><li><p>国家级：<a href="http://www.gov.cn/guowuyuan/">国务院</a></p></li><li><p>省级：例如：<a href="http://www.zj.gov.cn/">浙江省人民政府</a></p></li><li><p>市级：例如：<a href="http://www.hangzhou.gov.cn/">杭州市人民政府</a></p></li><li><p>具体相关政府网站：例如<a href="http://fgj.hangzhou.gov.cn/col/col1229243551/index.html">杭州市住房保障和房产管理局</a></p></li></ul></li><li><p>先进城市，试点城市：一些先进的城市可能作为政策试点，可以一定程度上参考观察。例如上海房价政策与杭州房价政策就有很大的参考关联。</p></li><li><p>网络平台</p><ul><li><a href="http://www.bailuzhiku.com/">白鹿智库</a></li><li><a href="https://www.chacewang.com/">查册网</a></li><li>…</li></ul><p>一般需要注册花钱，不建议。</p></li></ol><h2 id="如何解读"><a href="#如何解读" class="headerlink" title="如何解读"></a>如何解读</h2><p>理解政策文件是一项复杂庞大的工程，这要求阅读人员拥有足够的相关知识储备，基本的信息敏感度，以及充分的时间，为此笔者罗列了一下几个方式：</p><ol><li><p>政府官方解读</p><p>最为严谨和客观的评价解读方式，对于某项政策发布后，一般政府都会开展相应的政策解读会，例如国务院官网<a href="http://www.gov.cn/zhengce/jiedu/index.htm">政策解读模块</a>，同样对于下级政府机构都会对政策进行相应解读。</p></li><li><p>官方媒体解读</p><p>作为政府发言机构，其解读一般较为严谨，例如紫光阁，人民日报等。</p></li><li><p>网络媒体解读</p><p>质量参差不齐，仅供参考或娱乐，需要读者掌握一定的信息筛选能力。</p></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>以十四五规划为例，截取中间的一部分，笔者简单的进行搜索和解读。</p><p>首先明确目的，五年规划作为指导国家经济和社会发展的总纲领，对于个人成长具有极强的参考价值，其中点明了未来会重点发展的行业方向。回顾过往几轮的五年规划，能够发现其聚焦的重点正是那些飞速发展的行业。例如十二五期间聚焦转型升级提高产业核心竞争力、营造环境推动服务业大发展，关键词是移动互联网，云计算，大数据等。十三五期间聚焦实施创新驱动发展战略、拓展网络经济空间，关键词为互联网+，人工智能，4g等。</p><p>通过国务院官网搜索源文件，通读目录总纲后，我们需要重点关注的就是文件中所提及的行业“热词”。以第五篇《加快数字化发展 建设数字中国》为例，总共分为四个部分：</p><ul><li>打造数字经济新优势</li><li>加快数字社会建设步伐</li><li>提高数字政府建设水平</li><li>营造良好数字生态</li></ul><p>整篇强调的依旧是一些重点项目例如人工智能，云计算，物联网，网络安全等方向，以及新添了近年较为火爆的区块链等技术。读者如果单独从概括来看，这些行业热词似乎与之前并无大的差别。实则不然，仔细对比十三五规划，两者的具体内容有很大的差别。以网络安全方向为例，从2016年国家颁布网络安全法，公安部牵头组织全国护网等一系列行动，使安全行业从之前的鱼龙混杂逐渐向正规化，程序化发展。如果说2016是让安全届的秩序从无到有，从0到1，那么在十四五期间安全行业要求将会更为严格，着重强调了隐私治理，反数据垄断等业务风险，因此作为从业者也应花费部分精力去关注这一部分。这也是上文所提及的时效性，解读政策需要使用发展的眼光。</p><p>与之类似，其他政策都需要精细考虑，确保准确性，时效性，关联性才能让政策从抽象化具象，从文字板书变行动指南。最后限于篇幅以及文章重点，十四五其他方面不在这里展开，更多总结推荐观看B站所长林超的<a href="https://www.bilibili.com/video/BV1zU4y1p7L3">解读概括</a>。</p><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>最后我们需要做的就是更多亲身实践，让思考落于实处，让自己化身为社会海洋里的鲨鱼，从丁点“血腥”中寻觅契机。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E6%94%BF%E6%B2%BB">中国政治体制-维基百科</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E6%B0%91%E7%BB%8F%E6%B5%8E%E5%92%8C%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%E4%BA%94%E5%B9%B4%E8%A7%84%E5%88%92">中华人民共和国国民经济和社会发展五年规划</a></p></li><li><p><a href="http://www.gov.cn/xinwen/2021-03/13/content_5592681.htm">中华人民共和国国民经济和社会发展第十四个五年规划和2035年远景目标纲要</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1zU4y1p7L3">十四五规划65000字，课代表来了！拒绝咸鱼，国家带你飞！—所长林超</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 情报库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静夜思（十八）-莫愁前路无知己</title>
      <link href="night-thoughts-18/"/>
      <url>night-thoughts-18/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在每一个深夜苦苦思索</p></blockquote><p>写于新旧年交际之时，赠诗一句以自勉，莫愁前路无知己，天下谁人不识君。</p><h2 id="回首2020"><a href="#回首2020" class="headerlink" title="回首2020"></a>回首2020</h2><p>2020的最重要的两件事，一个是在长亭实习了整整半年，另一个就是从7月开始一直到10月的秋招了。</p><h3 id="六月长亭"><a href="#六月长亭" class="headerlink" title="六月长亭"></a>六月长亭</h3><p>北京，二月寒冬，初来乍到，藏在出租屋中回炉重造自己。</p><p><img src="https://image.bdwms.com/FoF9MF0w5KmxceZCuMjGBmjWPj0I"></p><p>长亭科技，认识了很多可爱的同事，技术氛围很浓厚，大家的关系都很融洽。第一次了解了公司项目是如何研发的，第一次亲身参与到项目研发。</p><p><img src="https://image.bdwms.com/Fk696l7teLX-3UI_bIEWTQR5QbkM"></p><p>第一次来到天安门，respect。</p><p><img src="https://image.bdwms.com/FlJmIk4wdRbWN9EgAvL1Sfg2Zv03"></p><h3 id="漫漫秋招"><a href="#漫漫秋招" class="headerlink" title="漫漫秋招"></a>漫漫秋招</h3><p>从七月被字节，阿里，百度轮番挂掉怀疑人生，之后调整心态和方法，最终也算是有所收获。</p><p><img src="https://image.bdwms.com/FjZ_uUbckm2rhGsNksdMdJm7VoCh"></p><h2 id="展望2021"><a href="#展望2021" class="headerlink" title="展望2021"></a>展望2021</h2><h3 id="橙色之路"><a href="#橙色之路" class="headerlink" title="橙色之路"></a>橙色之路</h3><p>来到a厂，和长亭的感觉完全不一样，很大，有点累，很多东西需要学，期望能够未来能够快速成长。</p><p><img src="https://image.bdwms.com/FnGfKdiKR8Omf4NKsRpHwM7HpECl"></p><h3 id="自我期许"><a href="#自我期许" class="headerlink" title="自我期许"></a>自我期许</h3><p>接下的一年里，我想要给自己定一些目标，具体的实现步骤暂时不公开，等我完成后写一写</p><ul><li>了解企业安全，熟悉业务，能够独立处理工作问题。</li><li>体重控制在135，保证基本的身体健康。</li><li>熟悉杭州市，研究杭州楼市。</li><li>养一只银渐层。</li><li>拿到日语N3证。</li><li>晋升折纸熟手。</li><li>了解并尝试打造自己个人品牌。</li></ul><h2 id="幻想十年"><a href="#幻想十年" class="headerlink" title="幻想十年"></a>幻想十年</h2><p>幻想一下离开校园的我接下来会有怎样的人生，未来的十年我又会何去何从呢，我会成为一个什么样的人，我会扎根在哪一座城市，我会遇到怎样的她？我时常在幻想着这些，在与现实的不断交互中，不断地调整着目标和期望。就像国家都有五年计划，一个小小的普通人想要把日子过得更明白不是更应该多多计划么。</p><p>在工作上：</p><ul><li>第一年熟悉整个团队的运作，融入团队中，找准自己的定位以及之后发展的方向。</li><li>三年内，能够独立解决问题，成为专业熟手，在相应的领域内有一定的话语权。</li><li>五年内，成为攻坚人员，能够解决难题，形成自己的完整技术栈，方法论，培养自己带队攻坚的能力。</li><li>十年内，成为行业专家，拥有一定的行业知名度，能够从无到有构建相应的能力，做到成体系的建设输出。</li></ul><p>在自我塑造中：</p><ul><li>保证基本的身体健康，控制体重在135至140中，拥有一项坚持的运动。</li><li>保证良好的心理健康，学习并了解基本的心理学知识，对自我有足够的认知与评估。</li><li>拓展自我的兴趣爱好，保持足够的好奇心与实践能力。</li><li>拥有足够的社会经验，生活常识，能够在中国社会做到积极生活。</li></ul><p>在情感上：</p><ul><li>积极陪伴关心父母。</li><li>明确自己的交友标准和原则，维持自己的朋友圈，可以尝试从更多的圈子中拓展自己的朋友。</li><li>明确自己的择偶标准，然后针对性的去拓展交际圈（卑微码农</li></ul><p>经济上：</p><ul><li>一年内，明确自己的理财理念，熟悉自己和家庭的经济状况。</li><li>三年内，掌握基本的理财知识，形成自己的理财方法论和进行一定的实践。</li><li>五年内，熟悉个人理财的基本方法，对多种理财方式都有一定的了解，并对某几个方面拥有自己的实践经验或者运作方法。</li><li>十年内，寻求一种或多种财务副业，争取能够副业收入维持个人家庭生活，甚至做到超过主业收入。</li></ul><h2 id="今日寄语"><a href="#今日寄语" class="headerlink" title="今日寄语"></a>今日寄语</h2><p>思来想去，迟迟无法落笔，不得不感慨自己的语言功底之差，感到羞愧对自己的高中班主任，新的一年中，更加需要多学多看多想多写。纸上得来终觉浅，绝知此事要躬行，写的再多还是需要我一点一点去实践在我的生活中。大年初一的这一天，我满怀希望。</p><p>惟愿诸君一生喜乐安康！</p>]]></content>
      
      
      <categories>
          
          <category> 静夜思 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自建情报库-楼市篇</title>
      <link href="information-database-property-market/"/>
      <url>information-database-property-market/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自建情报库系列是一套信息收集方法论，目的是为了帮助毕业生建立必备的知识情报体系，从而更好地迈入社会。本系列将会从住房，政策，经济，医疗等方面进行概括性的叙述，形成一条完整的知识链路，作为之后付诸行动的个人信息门户。</p></blockquote><p>俗话说兵马未动，粮草先行，在这个信息化时代，情报就是我们出兵北上，征战社会的“粮草”。初入大学时因为缺乏主动意识，带来的巨大信息差导致错过了很多机会。为了吸取教训，弥补遗憾，即将正式迈入社会，独自生活的笔者决定新建自己的情报库，由此决定新开一个专栏。</p><p>同时因为每个人的社会背景与内在属性都是不同的，对于笔者有用的信息可能对其他人就没有参考价值。因此，为了能够提供给读者更多的参考价值，整个系列的文章尽量抽象出笔者的思考过程，做到授人以渔。</p><p>那么作为整个系列的第一篇文章，笔者想要从房产，这个年轻人的第一座大山谈起，无论你现在是否能买得起房，作为中国经济的核心命脉，房产都应该是初入社会的年轻人需要考虑的。当然因为笔者目前也是在调研进行中，所以本篇文章会随着时间推移进行修改。</p><h2 id="背景条件"><a href="#背景条件" class="headerlink" title="背景条件"></a>背景条件</h2><p>首先我们要明确，对于房地产，整个产业的复杂度不是非专业的个人能够完全弄清的，包括很多所谓的经济专家也只是信口开河，牢记没有人能预言未来走向！我们只能根据个人的条件，以点窥面，尽量优化自己的选择。</p><p>所以本篇文章的背景也是从笔者个人的角度和背景出发，思考年轻人购置第一套房需要了解什么，从而针对性地收集情报信息。从面对繁多虚假信息不知道从何下手，到能够条理清晰去梳理脉络。</p><p>而读者想要更好地进情报收集，也需要对自身的条件背景进行充分了解，包括家庭环境，职业发展，个人情感等方面，后面会进行展开说明。</p><h2 id="解析目标"><a href="#解析目标" class="headerlink" title="解析目标"></a>解析目标</h2><p>第一步，思考以下问题：</p><ol><li><p>为什么要买房？</p><p>根据房屋的属性可以分为几种：刚需房，学区房，投资房，置换房。年轻人第一个房子一般都是刚需房，作为自住使用。当然以上几个属性可能会有叠加，也会导致价格上涨乃至翻倍。</p></li><li><p>首付预算多少，还款能力多少？</p><p>决定了能不能买房，以及自己是否有偿还能力。一般普通人都会选择贷款买房，毕竟全款买房的都是土豪。国家提供给每个人一般为两次贷款机会（全国联网互通），第一次为30%，第二次为60%，这都是优质的杠杆机会，毕竟银行不是你想借钱就能借的。从过去几十年的国情来看，普通人能跑赢大盘通货膨胀的最稳定手段就是购置房产。</p></li><li><p>个人发展是否有考虑？</p><p>包括想要在哪个城市发展，职业发展是否有考虑，个人情感是否稳定。工作和婚姻稳定后，购置房产再想要更换城市的代价是很大的，必须结合好自己其他方面的发展来一同考虑。</p></li></ol><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>进一步到了本文重点，如何做信息收集，笔者经过思考和分析决定从三个角度来行动。</p><p>概括下来就是三个字：<strong>房，人，钱</strong>。下面展开来说：</p><h3 id="地区与房屋属性"><a href="#地区与房屋属性" class="headerlink" title="地区与房屋属性"></a>地区与房屋属性</h3><p>第一个关键字：房。更具体的说是从大区域到具体房屋属性进行了解，我们要做到对居住地环境了如指掌。</p><ol><li><p>市：了解全貌</p><ul><li>杭州市地图：了解行政划分，城市中心，地貌等基本因素。</li><li>杭州地铁规划图：即未来交通规划。</li><li>杭州控规图：即城市规划用地，一般在当地房产局可查阅。</li></ul></li><li><p>区域：了解区域化结构</p><ul><li><p>行政划分</p><p>作为基本参考，例如余杭区，虽然行政是一个区但是房价能一个天一个地。但是考虑到上学时，杭州又是按行政区划分。</p></li><li><p>教育划分</p><p>杭州学区划分，学区是房价能够翻倍的唯一因素，虽然好但是导致太贵了很多年轻人无法考虑。参考时注意别被开发商宣传误导欺骗，同时随着时间变化，学区也有可能改变，都要考虑到。</p></li><li><p>物理划分</p><p>交通，城市（副）中心。房子最为重要的属性就是地段，而交通就是决定地段属性好坏的重要标准，包括是否近地铁，近机场等等。除此之外，一个城市不一定越靠近地理中心越好，可能存在多个城市中心，我们都需要考虑，例如杭州的未来科技城就因为阿里在那里。</p></li></ul></li><li><p>一手房 or 二手房</p><p>一手房和二手房是两个完全不同的市场。因为国家限制调控，一手房一般都有限价，会比二手房便宜很多，但是需要摇号，很难买到。所以两者考虑的方面就有所不同，例如一手房需要考虑开发商是否正规，楼盘地段规划等等，二手房需要考虑房主是否完全持有房子，产权是否清晰，中介是否正规等。</p></li><li><p>房屋属性</p><p>到了具体的房屋属性，笔者总结分为主要的四点：</p><ul><li>大小：既由你的钱包决定，并且也有一定决定属性，例如在二手买卖时，小的房子例如两室的会比四室的好卖。</li><li>通勤：包括地铁，路况。作为自主的话肯定越近越好，靠近地铁。</li><li>配套：包括<strong>教育</strong>，医疗，生活设施。其中教育也就是学区可能是影响最大的，不过自主房可能就暂时考虑不到这个了。配套的完善度决定了生活是否方便，例如商场，超时，医院等等。</li><li>舒适性：1.户型＞2.楼层＞3.朝向＞4.得房率＞5.容积率＞6.楼栋位置＞7.物业＞8.小区体量。具体的房子样式，个人看中的因素排名。</li></ul></li></ol><p>除此之外可能个人还有很多特质化要求，比如笔者可能需要一定的易卖性，以及一定的现金流保证，就不会选择太大的户型。</p><p>根据以上这些属性从而衍生出几类房子的定义：刚需房，学区房，投资房，置换房。</p><h3 id="人与政策因素"><a href="#人与政策因素" class="headerlink" title="人与政策因素"></a>人与政策因素</h3><p>第二个关键字：人。我国是一个政策决定型国家，并且政策是多变的，我们需要时刻关注，同时也要结合个人发展来综合考量。</p><ul><li><p>外部因素：</p><ul><li><p>政策：从大到小，可以从官网来查看政策，以及房管局来看楼市政策，当然精力有限我们重点还是关注市级政策。</p><p>国际经济，国务院，浙江省，<strong>杭州市</strong></p></li><li><p>人口流动与转化定居率：看国家统计局和各种历史记录</p><p>人口流入量与转发决定了购房热度，从而影响着房价走势，可以作为一个参考因素。</p></li></ul></li><li><p>内部因素：</p><ul><li>职业发展：在当地城市是否有足够的发展空间，职级晋升等。</li><li>结婚发展：大多数时候是一锤定音的因素，例如笔者不能接受异地恋。</li></ul></li></ul><h3 id="资金"><a href="#资金" class="headerlink" title="资金"></a>资金</h3><p>第三个关键字：钱。没钱都是空头支票，加油挣钱吧，打工人~</p><ul><li><p>外部</p><ul><li>公积金政策</li><li>银行商贷政策</li></ul><p>一般公积金贷款（3.5%）会比商贷便宜（5.x%）很多，但是有上限，并且是根据公积金余额进行计算可贷款额度的，只有两次机会，所以当余额不多时一般选择商贷，避免浪费公积金贷款机会。</p></li><li><p>内部</p><ul><li>首付</li><li>月还款能力</li></ul><p>自行搜索工资计算器，房贷计算器。</p></li><li><p><strong>交付流程是否安全正规</strong></p><p>无论是一手房还是二手房都一定主要资金转账安全，合同签约是否正规，重中之重！</p></li></ul><h3 id="特殊化事件"><a href="#特殊化事件" class="headerlink" title="特殊化事件"></a>特殊化事件</h3><p>除了以上通用的三因素，每个城市和个人都会有特殊的重大事件会影响到楼市，我们都需要关注并了解，例如杭州：</p><ul><li>2022亚运会</li><li>阿里巴巴</li></ul><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>以上进行的情报收集都是动态，具有一定时效性，不能僵化自己的思路，需要多打听多问，多实际跑楼盘，这也是笔者未来一年内会去做的事情，但是整体框架已经搭了起来，我们需要做的就是去实践评估，行动起来吧，少年！</p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><ul><li><a href="https://hz.ke.com/">贝壳找房</a></li><li><a href="http://fgj.hangzhou.gov.cn/">杭州市住房保障和房产管理局</a></li><li><a href="https://link.zhihu.com/?target=http://jjhygl.hzfc.gov.cn/webty/gpfy/gpfySelectlist.jsp">杭州市二手房交易监管服务平台</a></li><li><a href="https://bbs.hangzhou.com.cn/forum-207-1.html">口水楼市</a></li><li><a href="http://www.hangzhou.gov.cn/">杭州市人民政府</a></li><li><a href="http://www.zj.gov.cn/">浙江省人民政府</a></li><li><a href="http://www.gov.cn/guowuyuan/">国务院</a></li><li><a href="https://data.stats.gov.cn/">国家统计局</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>年轻人买房要注意什么？ - 土豆技师的回答-杭州二手房例子 - 知乎 <a href="https://www.zhihu.com/question/21731231/answer/1189064676">https://www.zhihu.com/question/21731231/answer/1189064676</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/142977813">2021年杭州购房政策最新版</a>   （杭州2021最新政策） </p></li><li><p><a href="https://www.shenlanbao.com/zhinan/120090210504573901">买房子需要注意什么？2020最全买房攻略来了！</a>   </p></li><li><p><a href="https://zhuanlan.zhihu.com/p/60016447">一手房VS二手房的买房攻略</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/35053921">一套有效的方法定位房价</a>  （需要查找的资料，包括政策，人口，房价走势）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 情报库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个人的秘密-端到端加密</title>
      <link href="e2ee/"/>
      <url>e2ee/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是端到端加密"><a href="#什么是端到端加密" class="headerlink" title="什么是端到端加密"></a>什么是端到端加密</h2><p>在加密网络通信中（例如TLS），可以防止攻击者破解加密报文，伪造身份。我们假设一个场景：存在两个客户端A和B，它们通过服务器S进行消息传递，从而实现通信。我们可以观察在这个过程中，客户端A与服务器S做一次消息传递，加密消息发送到服务端时会进行解密，当要发送给客户端B时，再进行一次加密然后传输，这也是常见IM的通信方式。</p><p><img src="https://image.bdwms.com/FuPdRD-5x6JDJ-twQbnhC0uNuFzn"></p><p>整个过程中，明文会存储在服务器，当攻击者攻破服务器，或者服务器本身就是恶意的，那么客户之间的通信消息就会泄漏。那么是否存在一种方式，只有通信双方能够加解密，作为传递信息的第三者（包括提供服务的运营商）无法获知明文呢？</p><p>端到端加密（End-to-end encryption，E2EE）正是为了解决这个问题所产生的。书面定义：</p><blockquote><p>是一种只有参与通讯的用户可以读取信息的通信系统。 总的来说，它可以防止潜在的窃听者——包括电信供应商、互联网服务供应商甚至是该通讯系统的提供者——获取能够用以解密通讯的密钥</p></blockquote><p><img src="https://image.bdwms.com/FsloogA_7i-1j3xjYAGESskUdDRG"></p><p>今天我就想围绕着端到端加密的设计来做分析，回答一些我认为比较关键的问题，而不仅仅是复述过程（网上很多文章只是简单介绍了该概念和流程，而没有说明为什么要这样设计），当然因为本人的能力有限，如有错误请指正。</p><h2 id="业界现状"><a href="#业界现状" class="headerlink" title="业界现状"></a>业界现状</h2><p>伴随着美国棱镜门监控事件，人们越来越看重个人隐私保护，将自己的机密通话消息托管给服务商不再可信。为此诞生了很多端到端通信的IM应用，号称能够实现只有两个人知晓的加密通信，其中主流的几个包括Telegram，Whatsapp，Skype等，能力图如下：</p><p><img src="https://image.bdwms.com/Fmt3m8FcP5srMMrRjsqKDpdwSKgZ"></p><p>而对于如何做到端到端加密，除了Telegram自己设计了一套MTProto协议（我暂时还没研究，因为它的资料不是那么全），大部分应用使用的都是Signal协议作为它们的基础。</p><p>Signal作为一个开源的协议，已经被众多安全专家肯定了它的安全性，并且Signal团队也开源了相关库和客户端，服务端代码，是值得信赖的。但是在其上实现的其他应用是否值得相信又是值得商榷的，比如Whatsapp被Facebook收购，Facebook又曾经加入过棱镜计划，并且Whatsapp本身是不开源的，虽然它宣扬自己是基于Signal实现的完全端到端加密，但是究竟如何还是耐人寻味。</p><p>以上就是端到端加密的一些背景，下面我将会介绍和分析协议中最为核心的部分，看看Signal是如何实现端到端加密通信的。</p><h2 id="Signal协议简介"><a href="#Signal协议简介" class="headerlink" title="Signal协议简介"></a>Signal协议简介</h2><p>Signal协议主要由几个部分组成，在官方文档中有四篇文章分别为：</p><ul><li><a href="https://signal.org/docs/specifications/xeddsa/">XEdDSA and VXEdDSA</a>：介绍了如何将做ECDH密钥交换的椭圆曲线，转换为可以做数字签名。</li><li><a href="https://signal.org/docs/specifications/x3dh/">X3DH</a>：将DH算法进行拓展。用于在两个客户端建立共享密钥，提供异步通信能力，身份验证（但是不防中间人，很奇怪是吧，后面我会解释），一定的前向安全性，以及可否认性。</li><li><a href="https://signal.org/docs/specifications/doubleratchet/">Double Ratchet</a>：双棘轮算法，结合了对称密钥棘轮和DH棘轮，保证了前向安全和后向安全。</li><li><a href="https://signal.org/docs/specifications/sesame/">Sesame</a>：用来做多设备多用户的同步管理。</li></ul><p>受篇幅限制，我决定挑出X3DH和Double Ratchet来做分析，个人认为这也是Signal协议中最为核心的点。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="DH类算法"><a href="#DH类算法" class="headerlink" title="DH类算法"></a>DH类算法</h3><p>Diffie–Hellman和基于椭圆曲线的Diffie–Hellman算法，用于两方进行密钥协商，详细介绍请看<a href="https://blog.csdn.net/qmickecs/article/details/76585303">离散对数和椭圆曲线加密原理</a>，简化表述：<br>第一种基于有限域上的离散对数问题：<br><strong>已知x和G，求G^x mod p是简单的；反过来已知G^x mod p和G，求x是困难的。</strong></p><p>第二种是基于椭圆曲线上的离散对数问题，即ECDH类，口语化表达类似：<br><strong>已知x和G，求xG是简单的（椭圆曲线上的运算，不是简单的数乘）；反过来已知xG和G，求x是困难的。</strong></p><p>所以一般我们把x作为私钥，xG（G^x）为公钥，使用的过程类似：</p><ol><li>服务端拥有私钥a，客户端拥有私钥b，第一次服务端发送公钥aG和参数G。</li><li>客户端接受到后计算bG，发送自己的公钥bG至服务端。</li><li>此时客户端拥有aG和b，服务端拥有bG和a，双方经过计算a(bG)&#x3D;b(aG)&#x3D;abG，得出相同的会话数据。</li></ol><p>此时中间人只能截获aG，bG和G，无法求出abG，因为想要求出的话记必须通过aG和G（bG和G）计算出a（b），但是从上文的条件可以看出这是困难的，由此这就是DH类算法的原理。</p><p><img src="https://image.bdwms.com/FpcwsX8mQoxRoZVp1cPJ5bMnpTFv"></p><h3 id="前向安全，后向安全"><a href="#前向安全，后向安全" class="headerlink" title="前向安全，后向安全"></a>前向安全，后向安全</h3><blockquote><p>前向安全：长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。</p><p>后向安全：长期使用的主密钥泄漏不会导致之后的会话密钥泄漏。</p></blockquote><p>通俗点说就是某个密钥泄漏不会对之前或者之后的加密消息有影响，例如在TLS中如果使用ECDHE，DHE就可以保证前向安全，因为协商的私钥都是临时生成的。</p><h2 id="Signal之X3DH协议"><a href="#Signal之X3DH协议" class="headerlink" title="Signal之X3DH协议"></a>Signal之X3DH协议</h2><h3 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h3><p>回想下端到端加密的目的，我们要实现一个只有通信双方能够加解密的过程，包括提供消息转发的服务器也不知道明文，那么服务端不会存储明文，通信的客户单A和B就需要直接协商出一个对称密钥来做加密传输，也就是说设计的协议需要提供离线<strong>异步协商对称密钥</strong>的能力。</p><p>并且为了保证通信双方的身份不与消息强绑定，协议需要提供<strong>可否认性</strong>，即两方都可以否认之间曾经存在会话，这与TLS的不可否认性正好相反，加大了第三方取证的难度。</p><p>最后为了安全性，<strong>对抗密钥泄漏</strong>可能造成的安全问题，例如前向安全，身份伪造等，协议还添加了额外的过程来做防御。</p><p>总之X3DH的最终目的就是协商出一个对称密钥，并保证上面所说的的几个特性，接下来我们来看下相关的定义概念。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>首先约定会用到的角色，密码学函数以及相关参数。</p><p>三个角色：</p><ul><li>Alice：会话的发起者。</li><li>Bob：会话的响应者。</li><li>Server：存储Alice发送给Bob的消息，以及存储一些客户端信息用于密钥协商。</li></ul><p>密码学函数：</p><ul><li>DH(PK1,PK2)：使用PK1和PK2相对应的公私钥进行ECDH的计算，生成一个共享密钥。</li><li>Sig(PK,M)：使用PK对应的私钥对M做签名，验证的时候时候用相应的公钥。</li><li>KDF(KM)：KM是包含密钥的序列，利用HKDF密钥派生函数做拓展衍生出新的密钥。</li></ul><p>会使用到的参数密钥：</p><table><thead><tr><th>Name</th><th>Definition</th></tr></thead><tbody><tr><td>IKA</td><td>Alice的身份密钥</td></tr><tr><td>EKA</td><td>Alice的临时密钥</td></tr><tr><td>IKB</td><td>Bob的身份密钥</td></tr><tr><td>SPKB</td><td>Bob的被签名预密钥</td></tr><tr><td>OPKB</td><td>Bob的一次性预密钥</td></tr></tbody></table><p>这些都是成对出现的公私钥，但是为了简化描述，我们这里只关注公钥的使用。</p><p>通信的双方都会持有一个身份密钥例如Alice的IKA，Bob的IKB。</p><p>Bob持有一个被IKB签名的预密钥SPKB，SPKB会周期性地替换。同时Bob还会有一组一次性预密钥OPKB，每发起一次X3DH协商，就会消耗一个OPKB。（之所以叫预密钥是因为SPKB和OPKB都会在Alice发起会话之前发送到服务器）</p><p>每一次发起X3DH协议，Alice都会生成一个临时密钥EKA。</p><p>经过一次X3DH密钥协商，Alice和Bob会协商出一个32字节的共享密钥SK，这个SK（或者用HKDF函数拓展这个SK）会用在后面的其他协议。</p><h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p>基本流程为三个部分：</p><ol><li>Bob将自己的IKB和prekey发送到服务端。</li><li>Alice从服务器获取一组Bob的公钥，然后使用它生成SK，之后发送初始化信息发送给Bob。</li><li>Bob接受初始化消息，并验证生成相应的SK。</li></ol><p>然后我们来看下具体的步骤，首先Bob生成相应的公私钥：</p><ul><li>Bob的身份密钥IKB</li><li>Bob的被签名预密钥SPKB</li><li>Bob的预密钥签名Sig(IKB,Encode(SPKB))，就是用IKB对SPKB做一个签名生成的信息</li><li>Bob的一组临时预密钥OPKB1，OPKB2，OPKB3…</li></ul><p>然后Bob发送这些到服务器上（Alice其实也会生成发送一组上列信息上传给服务器，但是在一次会话中只会用到Alice的身份密钥IKA），Bob会周期性地更换SPKB，并替换之前旧的SPKB，可能会继续持有一段时间SPKB的私钥以处理延时的消息，之后会删除私钥以保证前向安全（Bob同样会删除一次性预密钥的私钥当收到相应的初始化消息后）</p><p><img src="https://image.bdwms.com/Fk0ETNDhliXg1lnoYC9zWBqgb_Jm"></p><p>之后正式开始协商过程，Alice首先会向服务器请求Bob的相关信息，包括：</p><ul><li>Bob的身份公钥IKB</li><li>Bob的被签名预密钥SPKB</li><li>Bob的预密钥签名Sig(IKB,Encode(SPKB))</li><li>Bob的一次性预密钥（可选的，当服务器中还有的时候发送）</li></ul><p>然后Alice会生成一组临时密钥EKA，进行密钥计算</p><p><img src="https://image.bdwms.com/FpFG1oXDRRgK4RsEdKjX8tTIzn8G"></p><p>没有OPKB的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DH1 = DH(IKA, SPKB)</span><br><span class="line">DH2 = DH(EKA, IKB)</span><br><span class="line">DH3 = DH(EKA, SPKB)</span><br><span class="line">SK = KDF(DH1 || DH2 || DH3)</span><br></pre></td></tr></table></figure><p>有OPKB的时候，多了个DH4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DH4 = DH(EKA, OPKB)</span><br><span class="line">SK = KDF(DH1 || DH2 || DH3 || DH4)</span><br></pre></td></tr></table></figure><p>其中DH1和DH2提供相互认证，DH3和DH4提供前向安全，后面我会解释。</p><p>之后Alice删除EKA的私钥和中间计算的DH值，并使用身份信息计算一个“associated data”即AD，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AD = Encode(IKA) || Encode(IKB)</span><br></pre></td></tr></table></figure><p><img src="https://image.bdwms.com/FkpAO81vOvXytc1IBD3-_ligehZB"></p><p>随后Alice发送初始化消息，包含：</p><ul><li>Alice的身份密钥IKA</li><li>Alice的临时密钥EKA</li><li>Alice使用的Bob的被签名预密钥的标志号（如果使用了OPKB，那么还有OPKB的标志号）</li><li>一段初始化文本，AEAD模式加密，其中AD作为输入的associated data，使用SK（或HKDF函数拓展SK）作为加密的密钥</li></ul><p>Bob接受初始化消息后，就能得知Alice的身份密钥，EKA所代表的临时公钥，Alice使用的SPKB和OPKB，通过相同的方式计算出SK和AD（同样计算完后删除中间的DH值），然后解密初始化文本，如果解密成功，会删除一次性密钥的私钥，保证前向安全性。</p><p><img src="https://image.bdwms.com/FnqmNz5WOFDmV1ainf1IhqDazzng"></p><p>这样子最终Alice和Bob就持有了相同的SK或由HKDF函数拓展SK的新密钥。</p><h3 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h3><p>虽然上面阐述了一遍X3DH的过程，但是想必大部分人看完后都是一头雾水。这些参数的作用是什么，为什么这样设计计算过程，这样的交换是如何实现设计目标的等等，接下来我就会结合官方文档和自己的理解进行解释。</p><ol><li><p>DH1和DH2是如何完成相互认证的，DH3和DH4如何提供前向安全的？</p><p>Bob和Alice都会上传自己的身份密钥，通过两次DH计算，即Alice通过Pri_Alice和Pub_Bob(IKB)进行计算，Bob通过Pri_Bob和Pub_Alice(IKA)进行计算，就能确保对方的确持有相应的私钥。</p><p>DH3通过EKA和SPKB进行计算，因为EKA是每次临时生成的，并且其私钥会在计算出DH结果后丢弃，所以能提供前向安全性。同理OPKB也是只使用一次，并且在计算出结果后丢弃私钥，提供更强的前向安全性。</p></li><li><p>X3DH的可否认性？</p><p>首先说明可否性指的是通信双方即Alice和Bob无法向第三方例如Carol证明两者间曾进行过会话。形象点说Alice想要举报Bob，但是Alice不能够证明给法官Carol说Alice和Bob两人间曾经通过信，就算Alice展示两者的会话消息，Bob也可以否认说这是Alice自己伪造的。</p><p>为什么呢？首先Bob的身份密钥IKB和被签名预密钥SPKB都是公开的，任何人都可以获取，因此Alice可以自己单独计算出SK，并发送给Bob初始化消息，但是此时Bob是可以选择不计算出SK的，Alice并没有显示的证据（例如TLS中Server主动的数字签名下发给客户端），所以无法证明Bob持有同样的密钥。同样因为EKA在使用完后会丢弃私钥，Bob同样无法证明Alice是持有相同的SK密钥。综上X3DH的相互认证是不可向第三方证明的，具有可否认性。</p></li><li><p>存在中间人攻击？</p><p>我们通过上面的分析，会发现一个问题：Alice和Bob在进行相互认证的时候，Bob其实只是收到了一个身份密钥，就算它成功计算出相同的SK，那又怎么证明这个身份密钥确实是Alice的呢？可能存在一个中间人David截获了Alice和Bob的对话，并替换Alice的身份密钥IKA为自己的IKD，Bob只会知道它通信的对端的确持有IKD的私钥，而无法得知对端是否为Alice。</p><p>也就是说X3DH的相互认证只能说是一个身份的绑定，而不能确保通信对端的确是真正想通信的人，这也是上面<strong>可否认性带来的必然结果</strong>，在像TLS的协议中是存在一个可信第三方进行显示证明通信双方身份的，但X3DH是不存在这样的角色。因此为了解决这个问题，在Alice和Bob建立对话后会用带外通信的方式进行身份确认IKA和IKB，例如扫二维码，比较公钥指纹等手段来避免中间人攻击。</p></li><li><p>临时预密钥有什么作用，为什么它是可选的？</p><p>笼统的说是为了前向安全性。详细点说，当不存在OPKB的时候，Bob会长期持有IKB和一定时间内持有SPKB，当攻击者攻破Bob后能拿到IKB和SPKB，并通过观察网络流量记录拿到之前的EKA，这样攻击者就能解密之前的消息了，因此当没有OPKB的时候前向安全会下降。当然OPKB被消耗完时，EKA一般会经过TLS加密，还是能保证一定程度的前向安全的，所以OPKB也不是说必须有。</p></li><li><p>为什么需要SPKB呢，SPKB为什么一定需要被IKB签名呢？</p><p>当不存在SPKB的时候，只有OPKB，如果存在攻击者恶意DDOS发起会话，会迅速消耗OPKB，当消耗完后，就无法与B正常通信了（虽然可以通过服务端进行一些限频等手段防DDOS，但还是更应该从协议层来做一定的防范）。那么为什么SPKB需要被IKB签名呢，官方文档是这么解释的，虽然看起来省略签名的步骤会提高效率，但是可能服务器是恶意的，Alice发起通信后提供给Alice的是伪造的预密钥，然后服务器恶意泄漏B的IKB就可能可以计算出SK了，从而解析Alice想要发送的信息。</p></li></ol><p>以上就是我觉得官方文档中没有解释清楚的，还有几个问题例如重放攻击，密钥泄漏危害讲的比较清楚了，可以直接参考<a href="https://signal.org/docs/specifications/x3dh/">官方文档</a>。</p><h2 id="Signal之双棘轮"><a href="#Signal之双棘轮" class="headerlink" title="Signal之双棘轮"></a>Signal之双棘轮</h2><h3 id="设计目的-1"><a href="#设计目的-1" class="headerlink" title="设计目的"></a>设计目的</h3><p>对于X3DH，保证了一定的前向安全，但是还不足够，为了在真正意义上实现前向安全和后向安全，Signal协议设计了一个双棘轮（Double Ratchet），即用对称密钥棘轮棘轮（Symmetric-key ratchet）保证前向安全，DH棘轮保证后向安全。</p><h3 id="KDF链"><a href="#KDF链" class="headerlink" title="KDF链"></a>KDF链</h3><p>KDF链是保证前向安全的核心</p><p><img src="https://image.bdwms.com/FiJ3s3vnlHhYcuVbaMUm86m-2r0H"></p><p>两个输入一个为密钥，一个是输入材料，输出切分为两部分，一部分作为下一轮的输入密钥，一部分作为本轮输出key，这样子保证了足够的前向安全，弹性，入侵恢复（<a href="https://signal.org/docs/specifications/doubleratchet/#kdf-chains">参考文档</a>）。</p><h3 id="Symmetric-key棘轮"><a href="#Symmetric-key棘轮" class="headerlink" title="Symmetric-key棘轮"></a>Symmetric-key棘轮</h3><p><img src="https://image.bdwms.com/Fj5q6pnm-ekb5E-NyGI09UQ7LO6s"></p><p>每个消息都使用唯一的message key加密，message key从chain链中导出保证了前向安全，但是因为输入的是constant所以无法保证后向安全，如果攻击者拿到了chain key就可以计算出之后的message key。在双棘轮中会有三个链分别为Root Chain，Sending Chain和Receiving Chain。</p><h3 id="DH棘轮"><a href="#DH棘轮" class="headerlink" title="DH棘轮"></a>DH棘轮</h3><p>DH棘轮保证后向安全，因为每次都会重新计算DH密钥。Bob发送公钥至Alice，Alice使用Bob的公钥Pub_B和自己的私钥Pri_A计算出一个DH1，然后Alice发送自己的公钥Pub_A，Bob结合自己的私钥Pri_A计算出相同的DH1。之后Bob生成新的密钥对，发送自己新的公钥Pub_B2，重复上面的过程，这样每一次都会计算出一个新的DH结果，保证了中间某次密钥泄漏，不会影响后面的消息加解密，这就是DH棘轮。</p><p><img src="https://image.bdwms.com/Fk4VYjCBKmc4C-F9Ly_69GIgKOVv"></p><p>然后会利用一个来回生成两组发送和接受链。</p><p><img src="https://image.bdwms.com/FkFdHpvNC0MepPUWB-qJ0KjUHI41"></p><h3 id="双棘轮的组合"><a href="#双棘轮的组合" class="headerlink" title="双棘轮的组合"></a>双棘轮的组合</h3><p>综上，通过组合以上两个棘轮就保证了前向安全和后向安全，DH棘轮生成的DH作为Root Chain的输入，来产生Sending Chain和Receiving Chain。</p><p><img src="https://image.bdwms.com/FqSh4YL63VL3QsoY5yjCWrfJVM9L"></p><p>然后看下实际的交互情况，会从Root Chain导出Sending Chain和Receiving Chain，然后Sending Chain和Receiving Chain会生成每个消息单独的message key。</p><p><img src="https://image.bdwms.com/FguqVlzdQnO4gZZoi5Mcc09j3X7l"></p><h3 id="失序处理"><a href="#失序处理" class="headerlink" title="失序处理"></a>失序处理</h3><p>当消息乱序发送时，会在消息头中维护消息序列和上一个链的长度，然后失序到达时保存未到的消息的对应的message key，例如下面B4到了B2和B3没到，头信息为N&#x3D;1,Pn&#x3D;2，所以可以推算出哪些没到，并保存这些消息的对应密钥。</p><p><img src="https://image.bdwms.com/FvTSBrq41uZsyEA6ykg3YSsy5P5A"></p><h3 id="X3DH结合双棘轮"><a href="#X3DH结合双棘轮" class="headerlink" title="X3DH结合双棘轮"></a>X3DH结合双棘轮</h3><p>X3DH商量的SK作为Root key，协商出的AD作为棘轮加密时用的AD，Bob的Prekey作为Bob初始棘轮公钥。X3DH的主要任务就是为了生成这个root chain的key。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上的描述我们大致了解了Signal协议是如何做到端到端加密的，真正意义上解决了第三者插入会话的问题，并且提供了可否认性，加强了前后向安全与对抗密钥泄漏。但是对于还有很多问题没有回答，比如如何做到多设备管理（Sesame），如何进行群组会话支持端到端加密（参考WhatsApp白皮书），如何做到多服务器负载均衡下的通信。同时我们要知道，就算在协议设计上没有问题，但是可能因为攻击者直接攻破接管了客户端等等类似的问题，影响到端到端通信之间的安全，所以要铭记一点：没有绝对的安全，我们只能尽量接近安全。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://faq.whatsapp.com/general/security-and-privacy/end-to-end-encryption/?lang=en">WhatsApp E2EE</a></p></li><li><p><a href="https://faq.whatsapp.com/general/security-and-privacy/end-to-end-encryption/?lang=en">WhatsApp白皮书翻译</a></p></li><li><p><a href="https://signal.org/docs/specifications/x3dh/">X3DH官方文档</a></p></li><li><p><a href="https://signal.org/docs/specifications/doubleratchet/">双棘轮官方文档</a></p></li><li><p><a href="https://blog.csdn.net/qmickecs/article/details/76585303">离散对数和椭圆曲线加密原理</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从TLS看安全协议设计（下）</title>
      <link href="TLS-design-part-two/"/>
      <url>TLS-design-part-two/</url>
      
        <content type="html"><![CDATA[<p>TLS1.3作为升级的版本，根据需求主要是在两个方面做了整改，一个是安全方面，一个就是性能，下面我们就来看一下。</p><h2 id="升级之处"><a href="#升级之处" class="headerlink" title="升级之处"></a>升级之处</h2><p>安全：</p><ul><li>删除了不安全的密码组件，例如MD5。</li><li>为了前向安全性，密钥协商过程不再使用RSA和静态DH，ECDH，只选用DHE或者ECDHE。</li><li>设计了新的密钥派生函数HKDF代替了PRF函数。</li><li>记录层进行加密和MAC时固定为AEAD模式。</li></ul><p>性能：</p><ul><li>重新设计了握手层流程，让冷启动从2RTT变化1RTT。</li><li>设计了PSK会话恢复机制代替了原来的Session会话恢复机制。</li><li>0-RTT</li></ul><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>对于TLS1.3的流程如下，最主要分为两种方式，一种是基于key_share和signature_algorithms来选择加密的算法，另一种是基于预共享密钥PSK的会话恢复。</p><h3 id="握手层冷启动"><a href="#握手层冷启动" class="headerlink" title="握手层冷启动"></a>握手层冷启动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Key  ^ ClientHello</span><br><span class="line">Exch | + key_share*</span><br><span class="line">     | + signature_algorithms*</span><br><span class="line">     | + psk_key_exchange_modes*</span><br><span class="line">     v + pre_shared_key*       --------&gt;</span><br><span class="line">                                                  ServerHello  ^ Key</span><br><span class="line">                                                 + key_share*  | Exch</span><br><span class="line">                                            + pre_shared_key*  v</span><br><span class="line">                                        &#123;EncryptedExtensions&#125;  ^  Server</span><br><span class="line">                                        &#123;CertificateRequest*&#125;  v  Params</span><br><span class="line">                                               &#123;Certificate*&#125;  ^</span><br><span class="line">                                         &#123;CertificateVerify*&#125;  | Auth</span><br><span class="line">                                                   &#123;Finished&#125;  v</span><br><span class="line">                               &lt;--------  [Application Data*]</span><br><span class="line">     ^ &#123;Certificate*&#125;</span><br><span class="line">Auth | &#123;CertificateVerify*&#125;</span><br><span class="line">     v &#123;Finished&#125;              --------&gt;</span><br><span class="line">                                                     &lt;--------  [NewSessionTicket]</span><br><span class="line">       [Application Data]      &lt;-------&gt;  [Application Data]</span><br></pre></td></tr></table></figure><p>我们首先来看第一种</p><ol><li>客户端发送ClinetHello，在key_share和signature_algorithms中声明自己支持的DHE或者ECDHE算法类型对应的具体参数。</li><li>服务端返回ServerHello，选择自己支持的算法和自己的参数。</li><li>服务端发送EncryptedExtensions，包含不需要建立加密上下文并且和证书无关的拓展。注意从本条消息开始都会被加密传输。</li><li>如果想要验证客户端认证，服务端就会发送CertificateRequest消息。</li><li>服务端发送Certificate消息，包含自己的证书。</li><li>服务端发送CertificateVerify消息。对之前握手的消息做Hash后用证书私钥进行签名，进行显示认证表明自己持有证书私钥。</li><li>服务端发送Finished消息对之前握手消息做校验，以及验证协商密钥的正确性。</li><li>此时服务端已经可以发送加密的应用数据了。</li><li>如果需要客户端验证，就会发送客户端Certificate消息。</li><li>如果客户端发送了Certificate消息，就会发送CertificateVerify来表明客户端持有证书私钥。</li><li>客户端同样发送Finished消息，进行校验。</li><li>客户端可以发送加密的应用消息。</li></ol><p>我们观察整个流程，冷启动仅需要1-RTT。因为在ClientHello时已经携带了DHE（ECDHE）的参数，让第一次握手有更多的作用。这也是因为在密钥协商时抛弃了RSA算法，因为对于RSA需要服务端先下发公钥，所以需要至少2-RTT。</p><h3 id="握手层热启动"><a href="#握手层热启动" class="headerlink" title="握手层热启动"></a>握手层热启动</h3><p>我们再看一下会话恢复的情况。对于1.3使用的是PSK机制，其中PSK可以从上次握手时生成，或者由使用者预置。</p><p>看一下流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ClientHello</span><br><span class="line">    + key_share*</span><br><span class="line">    + pre_shared_key          --------&gt;</span><br><span class="line">                                                    ServerHello</span><br><span class="line">                                               + pre_shared_key</span><br><span class="line">                                                   + key_share*</span><br><span class="line">                                          &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                     &#123;Finished&#125;</span><br><span class="line">                              &lt;--------     [Application Data*]</span><br><span class="line">    &#123;Finished&#125;                --------&gt;</span><br><span class="line">    [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line">    +表示携带的参数，*表示可选</span><br></pre></td></tr></table></figure><p>客户端携带PSK发送给服务端，服务端如果接受就返回ServerHello，以及加密的EncryptedExtensions，Finished消息。之后两者就能进行应用数据传输，整个流程需要一个1-RTT。</p><h3 id="记录层"><a href="#记录层" class="headerlink" title="记录层"></a>记录层</h3><p>流程为数据分段，填充（为了隐藏流量），加密和完整性保护（AEAD），添加消息头。</p><p>与1.2最主要的不同就是抛弃的块模式和流模式，固定为AEAD，并对AEAD做了一些调整，这里就不展开说了。</p><h2 id="变化分析"><a href="#变化分析" class="headerlink" title="变化分析"></a>变化分析</h2><h3 id="HKDF密钥派生函数"><a href="#HKDF密钥派生函数" class="headerlink" title="HKDF密钥派生函数"></a>HKDF密钥派生函数</h3><p>1.3重新设计了密钥派生函数，对于HKDF函数分为Extract和Expand过程，Extract过程增加密钥材料的随机性,Expand进行拓展，在1.2中PRF函数只有Expand的过程，它默认密钥材料的随机性是足够的，然而这是不一定的可能ECC协商出来的随机分布是不够均匀的。</p><p>Extract过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Extract(salt, IKM) -&gt; PRK</span><br><span class="line">salt盐可选，没有时用<span class="number">0</span>填充HashLen长度</span><br><span class="line">IKM：Input Keying Material</span><br><span class="line">PRK: 生成的伪随机key</span><br><span class="line"></span><br><span class="line">PRK = HMAC-Hash(salt, IKM)      </span><br></pre></td></tr></table></figure><p>Expand过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Expand(PRK, info, L) -&gt; OKM</span><br><span class="line">PRK伪随机key</span><br><span class="line">info可选一般标志上下文信息</span><br><span class="line">L期望输出的字节数</span><br><span class="line"></span><br><span class="line"> OKM生成方式：</span><br><span class="line"> N = <span class="built_in">ceil</span>(L/HashLen)</span><br><span class="line"> T = T(<span class="number">1</span>) | T(<span class="number">2</span>) | T(<span class="number">3</span>) | ... | T(N)</span><br><span class="line"> OKM = first L octets of T</span><br><span class="line"></span><br><span class="line"> where:</span><br><span class="line"> T(<span class="number">0</span>) = empty <span class="built_in">string</span> (zero length)</span><br><span class="line"> T(<span class="number">1</span>) = HMAC-Hash(PRK, T(<span class="number">0</span>) | info | <span class="number">0x01</span>)</span><br><span class="line"> T(<span class="number">2</span>) = HMAC-Hash(PRK, T(<span class="number">1</span>) | info | <span class="number">0x02</span>)</span><br><span class="line"> T(<span class="number">3</span>) = HMAC-Hash(PRK, T(<span class="number">2</span>) | info | <span class="number">0x03</span>)</span><br><span class="line"> ...   </span><br></pre></td></tr></table></figure><p>以及最终使用的Derive-Secret函数与Expand所对应的关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Expand-Label(Secret, Label, Context, Length) =</span><br><span class="line">            HKDF-Expand(Secret, HkdfLabel, Length)</span><br><span class="line"></span><br><span class="line">Where HkdfLabel is specified as:</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  uint16 length = Length;</span><br><span class="line">  opaque label&lt;<span class="number">7.</span><span class="number">.255</span>&gt; = <span class="string">&quot;tls13 &quot;</span> + Label;</span><br><span class="line">  opaque context&lt;<span class="number">0.</span><span class="number">.255</span>&gt; = Context;</span><br><span class="line">&#125; HkdfLabel;</span><br><span class="line"></span><br><span class="line">Derive-Secret(Secret, Label, Messages) =</span><br><span class="line">  HKDF-Expand-Label(Secret, Label,</span><br><span class="line">       Transcript-Hash(Messages), Hash.length)</span><br><span class="line">  </span><br><span class="line">Transcript-Hash级联握手消息做Hash运算</span><br></pre></td></tr></table></figure><h3 id="密钥变化"><a href="#密钥变化" class="headerlink" title="密钥变化"></a>密钥变化</h3><p>1.3对于密钥做了更加详细的分类，在每一个使用部分的密钥实际上都是不同的，都会通过HKDF函数做变化，这也是密码学上的安全要求，一个密钥只使用在一种功能上。</p><p>一次握手的密钥变化如下，很复杂，可以只大概了解下有什么密钥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">0</span></span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line">PSK -&gt;  HKDF-Extract = Early Secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;ext binder&quot;</span> | <span class="string">&quot;res binder&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">          |                     = binder_key</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;c e traffic&quot;</span>, ClientHello)</span><br><span class="line">          |                     = client_early_traffic_secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;e exp master&quot;</span>, ClientHello)</span><br><span class="line">          |                     = early_exporter_master_secret</span><br><span class="line">          v</span><br><span class="line">    Derive-Secret(., <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line">(EC)DHE -&gt; HKDF-Extract = Handshake Secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;c hs traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...ServerHello)</span><br><span class="line">          |                     = client_handshake_traffic_secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;s hs traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...ServerHello)</span><br><span class="line">          |                     = server_handshake_traffic_secret</span><br><span class="line">          v</span><br><span class="line">    Derive-Secret(., <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line"><span class="number">0</span> -&gt; HKDF-Extract = Master Secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;c ap traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...server Finished)</span><br><span class="line">          |                     = client_application_traffic_secret_0</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;s ap traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...server Finished)</span><br><span class="line">          |                     = server_application_traffic_secret_0</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;exp master&quot;</span>,</span><br><span class="line">          |                     ClientHello...server Finished)</span><br><span class="line">          |                     = exporter_master_secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;res master&quot;</span>,</span><br><span class="line">                                ClientHello...client Finished)</span><br><span class="line">                                = resumption_master_secret</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ol><li>HKDF-Extract 画在图上，它为从顶部获取 Salt 参数，从左侧获取 IKM 参数，它的输出是底部，和右侧输出的名称。</li><li>Derive-Secret 的 Secret 参数由传入的箭头指示。例如，Early Secret 是生成 client_early_traffic_secret 的 Secret。</li><li>“0” 表示将 Hash.length 字节的字符串设置为零。</li></ol><p>其中有三个Secret，是从Extract中得来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Early Secret = HKDF-Extract(salt, IKM) = HKDF-Extract(<span class="number">0</span>, PSK) (有PSK的情况)= HKDF-Extract(<span class="number">0</span>,<span class="number">0</span>) （没有PSK的情况）</span><br><span class="line">                                          </span><br><span class="line">Handshake Secret = HKDF-Extract(salt, IKM) = HKDF-Extract(Derive-Secret(Early Secret, <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>), (EC)DHE)</span><br><span class="line"></span><br><span class="line">Master Secret = HKDF-Extract(salt, IKM) = HKDF-Extract(Derive-Secret(Handshake Secret, <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>八个可能用到的密钥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client_early_traffic_secret = Derive-Secret(Early Secret, <span class="string">&quot;c e traffic&quot;</span>, ClientHello)</span><br><span class="line">early_exporter_master_secret = Derive-Secret(Early Secret, <span class="string">&quot;e exp master&quot;</span>, ClientHello)</span><br><span class="line"></span><br><span class="line">client_handshake_traffic_secret = Derive-Secret(Handshake Secret, <span class="string">&quot;c hs traffic&quot;</span>, ClientHello...ServerHello)</span><br><span class="line">server_handshake_traffic_secret = Derive-Secret(Handshake Secret, <span class="string">&quot;s hs traffic&quot;</span>, ClientHello...ServerHello)</span><br><span class="line"></span><br><span class="line">client_application_traffic_secret_0 = Derive-Secret(Master Secret, <span class="string">&quot;c ap traffic&quot;</span>, ClientHello...server Finished)</span><br><span class="line">server_application_traffic_secret_0 = Derive-Secret(Master Secret, <span class="string">&quot;s ap traffic&quot;</span>, ClientHello...server Finished)</span><br><span class="line"></span><br><span class="line">exporter_master_secret = Derive-Secret(Master Secret, <span class="string">&quot;exp master&quot;</span>, ClientHello...server Finished)</span><br><span class="line">resumption_master_secret = Derive-Secret(Master Secret, <span class="string">&quot;res master&quot;</span>, ClientHello...client Finished)</span><br></pre></td></tr></table></figure><ol><li>early_exporter_master_secret和exporter_master_secre导出密钥，用户可以自定义使用方式。</li><li>resumption_master_secret用于会话恢复。</li><li>client_early_traffic_secret用于加密early_data，在0-RTT模式中使用。</li><li>client_handshake_traffic_secret和server_handshake_traffic_secret用于握手时的加密。</li><li>client_application_traffic_secret_0和server_application_traffic_secret_0用于加密应用流量数据。</li></ol><p>3，4，5的密钥想要加密数据还需要一次Expand过程生成write_key和iv来作为真正加密数据的密钥，生成方式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sender]_write_key = HKDF-Expand-Label(Secret, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;&quot;</span>, key_length)</span><br><span class="line">[sender]_write_iv  = HKDF-Expand-Label(Secret, <span class="string">&quot;iv&quot;</span>, <span class="string">&quot;&quot;</span>, iv_length)</span><br></pre></td></tr></table></figure><h3 id="PSK会话恢复机制"><a href="#PSK会话恢复机制" class="headerlink" title="PSK会话恢复机制"></a>PSK会话恢复机制</h3><p>1.3中使用PSK机制代替了Session机制，那么PSK是如何生成并使用的？</p><p>先看下Server发送的NewSessionTicket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">          uint32 ticket_lifetime;</span><br><span class="line">          uint32 ticket_age_add;</span><br><span class="line">          opaque ticket_nonce&lt;<span class="number">0.</span><span class="number">.255</span>&gt;;</span><br><span class="line">          opaque ticket&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">          Extension extensions&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-2</span>&gt;;</span><br><span class="line">      &#125; NewSessionTicket;</span><br></pre></td></tr></table></figure><p>其中ticket的值是从上一节提到的resumptition_master_secret中计算出来的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PskIdentity.identity = ticket </span><br><span class="line">                          = HKDF-Expand-Label(resumption_master_secret, <span class="string">&quot;resumption&quot;</span>, ticket_nonce, Hash.length)</span><br></pre></td></tr></table></figure><p>客户端接受到NewSessionTicket后会计算一个binder值，Truncate会取出ClientHello1中的binder_list，避免陷入无限循环。利用这个值来绑定上下文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PskBinderEntry = HMAC(binder_key, Transcript-Hash(Truncate(ClientHello1)))</span><br><span class="line">                   = HMAC(Derive-Secret(HKDF-Extract(<span class="number">0</span>, PSK), <span class="string">&quot;ext binder&quot;</span> | <span class="string">&quot;res binder&quot;</span>, <span class="string">&quot;&quot;</span>), Transcript-Hash(Truncate(ClientHello1)))</span><br><span class="line"></span><br><span class="line">其中binder_key = Derive-Secret(HKDF-Extract(<span class="number">0</span>, PSK), <span class="string">&quot;ext binder&quot;</span> | <span class="string">&quot;res binder&quot;</span>, <span class="string">&quot;&quot;</span>)                   </span><br></pre></td></tr></table></figure><p>然后Client在会话恢复时将identity和binder包含在ClientHello的拓展中发送给Server，Server再验证binder的完整性，比对identity，选择是否接受PSK，从而生成新的handshake_traffic和application密钥进行会话恢复。</p><p>可以看到如果仅仅是这样的会话恢复，相对于1.2来说只是更安全（因为不再使用master_secret做传递，而是利用HKDF派生），性能上没有大的提升，所以就会涉及到下面的0-RTT。</p><h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h3><p>对于TLS1.3还有一个很大的变化，那就是0-RTT模式。什么是0-RTT呢，就是基于PSK会话恢复时，PSK会作为Early Secret的IKM，然后从Early Secret生成client_early_traffic_secret，再由client_early_traffic_secret生成key和iv用来加密0-RTT发送的early_data。Client在ClientHello中携带early_data拓展选项，并发送由client_early_traffic_secret加密的数据，如果服务端接受early_data，那么就成功完成了0-RTT传输。</p><p>但是0-RTT为了效率降低了安全性，存在重放问题，因为在客户端发送early_data时，只有客户端参数决定，服务端没有参与到其中，那么中间人就可以截获这个ClientHello包以及加密数据，而服务端每次都能成功解析这个包，中间人就可以进行重放ddos或者重复敏感操作。除了这种最简单的重放，还有针对分布式系统的重放攻击，这里就不展开说了。</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>通过上面的分析，我们可以看出TLS具有极强的通用性与可拓展性，但是针对一些具体的使用场景能否进行特殊化的改造，这里我们以微信mmtls作为例子来分析下。我们回顾TLS的过程，身份认证的过程是采用建立PKI体系，做到全球的通用性，但是针对完全可控的微信程序，可以直接将签名的公钥预埋在客户端中，这样就不用建立或者申请证书，通过强制更新客户端，来做公钥的维护，这样就很大程度简略的流程并提升了效率。</p><p>还有针对0-RTT的问题，对于TLS1.3本身协议上来说是无解的，更多的只能从应用层来做缓解，例如cloudflare针对0-RTT将禁止非幂等的操作像POST，PUT，只允许不带参数的GET请求。mmtls也是根据这些应用行为，有选择性的使用0-RTT模式，例如只在端连接使用。chrome甚至选择不解决0-RTT重放，因为大部分浏览器的操作都是GET先，安全性交由其他方面来做。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个TLS完成了密码学上的安全，并结合了软件工程的理念，做到了分层抽象，模块化等等优秀的设计，在通用性上也确保了更多的场景能够被覆盖，提升了互联网的安全性，基本完成了它的设计目标。</p><p>当然作为使用者，当我们自己在设计（魔改）安全协议的时候，依然需要小心谨慎，密码学的快速发展已经让大部分程序员很难理解其原理，甚至正确使用密码学黑盒工具也是困难的，所以我们更需要的是怀着严谨的态度去使用密码学工具，紧跟主流，避免陷入闭门造车的困境。还有根据本身的应用场景我们是否能够吸取TLS的精华，结合自己的业务需求去做特质化，省略一些臃肿的包袱，做到定制优化都是可以考虑的。</p><p>TLS中的奥义远远不止我所阐述的，短短两篇文章也不能尽善尽美地描绘，希望能够对每一个读者有所帮助，更加有条理地理解其奥义。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tools.ietf.org/html/rfc5246">TLS1.2 RFC</a></li><li><a href="https://halfrost.com/">冰霜之地</a></li><li><a href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/">TLS协议分析 与 现代加密通信协议设计</a></li><li><a href="https://blog.shell909090.org/blog/archives/2873/">安全协议的设计</a></li><li><a href="https://cloud.tencent.com/developer/article/1005518">微信mmtls</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从TLS看安全协议设计（上）</title>
      <link href="TLS-design-part-one/"/>
      <url>TLS-design-part-one/</url>
      
        <content type="html"><![CDATA[<p>在开始正文前，我想先谈谈为什么要写这篇文章，为什么要对TLS协议进行分析？</p><p>打开网站时我们经常能看到左上角的小绿锁，而TLS正是隐藏在后面的原由。对于大部分程序员，多多少少都可以聊一聊TLS的几分样貌，但是能真正的从其整体发散到细节，从理念落地到实践，以更高的角度去理解TLS是很少的。因此这里想要从我个人的角度，去理清TLS，解读这个将密码科学和软件工程良好结合的优秀设计，也希望能够给读者有所帮助。</p><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><h3 id="为什么需要TLS"><a href="#为什么需要TLS" class="headerlink" title="为什么需要TLS?"></a>为什么需要TLS?</h3><p>在不存在SSL&#x2F;TLS的互联网中，消息通过例如HTTP明文传递，作为一个攻击者可以截获任意的包，那么他就可以获取报文中的信息，并对报文进行修改，伪装成对端进行窃听或者控制传输。</p><p>在上文的描述中，我们可以看出明文传输存在的最显著问题：数据没有加密，消息易被篡改，身份能被伪造。这也对应着信息安全中的<strong>机密性</strong>，<strong>完整性</strong>，<strong>身份认证</strong>。</p><p>除了这三个最明显的问题，还有其他很多待解决的问题，例如如何确保用户不能抵赖之前发送的消息，即<strong>不可否认性</strong>；如何在设计时，降低所需的传输时间，提升<strong>性能</strong>；如何做到协议的<strong>通用性</strong>和<strong>可拓展性</strong>。这一系列的问题缺乏一个统一的解决方案，很多情况下仅是通过应用层的一些手段去不完善的处理，这些需求也就促成了SSL&#x2F;TLS的诞生与发展。</p><p>围绕着这些需求，从90年代SSL1.0设计之初，一直走到了08年TLS1.2版本正式发布，整个协议才趋于成熟，又伴随着安全研究的升级对抗以及对性能提升的要求，1.3版本也在几年的商讨中于18年诞生。而这几年业界也是逐渐从1.2版本向1.3升级。当然因为历史遗留原因目前主流的还是1.2版本，因此我的分析也将从1.2版本开始，再迈向1.3，为读者浅析TLS的前世今生。</p><p><img src="https://image.bdwms.com/FvB5KJRP8BMLJtatrdl8yHLHZFKZ"></p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>在阅读这一部分时，可以不先完全理解其细节，在浏览后面章节必要时，再返回本章进行对照理解。</p><p>因为TLS是建立在密码学之上的协议，想要将TLS理解清楚，对密码学应有一定了解，但是具体深入密码学的细节不是本文重点所在，所以我简单归纳了几个需要了解的点和一些特性，实现细节的话请参看所给资料链接或自行搜索。</p><h3 id="密码学基本工具"><a href="#密码学基本工具" class="headerlink" title="密码学基本工具"></a>密码学基本工具</h3><ul><li>对称加密：加密和解密时使用同一密钥，常用有AES，(DES,RC4等都被证明不安全了)，然后还涉及到加密模式，例如流式加密（RC4使用的就是流式）,块加密模式（CBC等模式）。<strong>加解密效率高，密钥配送管理不便</strong>。</li><li>非对称加密：公私钥体系。常见的有RSA（基于大整数的质因数分解难题）和ECC（基于椭圆曲线上的离散对数难题）,以及DH（基于有限域上的离散对数难题），后两者在使用过程中类似一个协商，而RSA更类似一个单方面的加密传输过程。<strong>加解密效率低，密钥派发管理方便</strong>。</li><li>单向散列函数：输入消息不同，输出Hash值不同，保证消息的<strong>一致性</strong>，<strong>完整性</strong>。</li><li>消息认证码MAC：比单项散列函数多了个共享秘钥，保证消息的<strong>一致性</strong>，<strong>完整性</strong>，并且通过密钥加解密确保<strong>身份认证</strong>。但是因为使用的是共享秘钥不能“第三方证明”和“防抵赖”。</li><li>数字签名：利用私钥对hash值签名，公钥认证。保证消息的<strong>一致性</strong>，<strong>完整性</strong>，<strong>认证</strong>，并且能<strong>防止抵赖</strong>。</li><li>伪随机数生成器：模拟产生随机数列的算法。</li></ul><p>以上就是常用的密码学工具，在接下来的流程中会分别涉及到，如果对相关的工具有困惑可以自行查阅资料。</p><h3 id="RSA-ECC-DH"><a href="#RSA-ECC-DH" class="headerlink" title="RSA ECC DH"></a>RSA ECC DH</h3><p>这里想要对最常用的非对称加密算法做个简单的介绍，因为后面讲解时会利用到其特性。</p><p>对于常用的非对称加密算法，可以简单的分为两种类型，一种是基于RSA，一种是类DH（包括原生的DH和基于ECC的DH，即ECDH），简单来看一下两者的使用和区别。</p><ul><li><p>RSA</p><p>基于大整数进行质因数分解的困难，具体原理可以看阮一峰的<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">《RSA算法原理》</a>，这里说下使用方法：</p><p>存在一对公私钥：公钥(E,N)，私钥(D,N)，明文加密和密文解密类似下列的运算</p><p>密文 &#x3D; 明文^E mod N   </p><p>明文 &#x3D; 密文^D mod N  </p><p>使用的过程类似：</p><p>服务端下发公钥给客户端，客户端利用公钥加密一段会话数据后返回给服务端，服务端利用自己的私钥进行解密。</p><p><img src="https://image.bdwms.com/FgWFJLCGyoonFMeoZxHodhv6io3d"></p></li><li><p>DH（ECDH）</p><p>分为两种，一种是基于有限域上的离散对数问题，即DH类（Diffie-Hellman），具体原理自行搜索，这里只做口语化表达：</p><p><strong>已知x和G，求G^x mod p是简单的；反过来已知G^x mod p和G，求x是困难的。</strong></p><p>第二种是基于椭圆曲线上的离散对数问题，即ECDH类，口语化表达类似：</p><p><strong>已知x和G，求xG是简单的（椭圆曲线上的运算，不是简单的数乘）；反过来已知xG和G，求x是困难的。</strong></p><p>所以一般我们把x作为私钥，xG（G^x）为公钥</p><p>使用的过程类似：</p><p>服务端拥有私钥a，客户端拥有私钥b，第一次服务端发送公钥aG和参数G，客户端接受到后计算bG，发送给服务端，此时客户端拥有aG和b，服务端拥有bG和a，双方经过计算a(bG)&#x3D;b(aG)&#x3D;abG，得出相同的会话数据，但此时中间人只能截获aG，bG和G，无法求出abG，因为想要求出的话记必须通过aG和G（bG和G）计算出a（b），但是从上文的条件可以看出这是困难的，由此这就是DH类的原理。</p><p><img src="https://image.bdwms.com/FpcwsX8mQoxRoZVp1cPJ5bMnpTFv"></p></li></ul><p>我们通过以上的简介不难发现一点，两类算法最大的区别就是RSA做加密传输的时候，整个的会话数据是由客户端决定的，而服务端没有参与到生成的过程，更类似于一个<strong>加密传输</strong>的过程。而DH类客户端和服务端双方都需要参与到生成的过程中，单方面是无法决定会话数据的，也就是说相较于RSA，DH（ECDH）更类似一个<strong>密钥协商</strong>的过程。</p><p>针对上面的特性，也就衍生出下一个需要关注问题——前向安全，这也是为什么TLS1.3会抛弃RSA作为密钥协商的算法。</p><h3 id="前向安全"><a href="#前向安全" class="headerlink" title="前向安全"></a>前向安全</h3><p>官方定义是：长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。简单点来说就是我的长期持有的私钥泄漏了不会对之前的会话消息造成影响，那么对于上述两种算法，其又有什么不同呢？</p><p>显然，对于RSA来说，如果我们一直使用同一对公私钥，当私钥泄漏时，攻击者就可以轻易解密之前的会话消息，也就是说RSA时不具有前向安全的。不可能每次会话都更新RSA公私钥，因为每次更新下发公钥是不现实的，效率太低了，不可接受。</p><p>对于DH（ECDH），如果双方每次通话的私钥a，b都是固定的，那么生成的abG也是固定的，如果泄漏，也无法保证前向安全。但是我们可以通过每次会话时都利用随机数发生器生成临时的a和b（这个效率是可接受的），这样每次计算出来的结果都不一样，这就保证了前向安全，这也就是DHE和ECDHE，其中E表示的就是临时的意思。</p><p>基于上述拥有的密码学工具，以及相应的设计目的和需求，我们应该怎么设计呢，假如你是一个协议开发者，你如何协调使用好所拥有的能力，完成一个精巧的架构呢？让我们先来看看TLS是如何操作的，由全局到细节，由问题推方法，我们来细细品味。</p><h2 id="协议架构"><a href="#协议架构" class="headerlink" title="协议架构"></a>协议架构</h2><p>TLS1.2主要分为两个层级，上层的握手层（以及一些辅助协议，例如密钥切换通知，告警协议）和下层的记录层。</p><p><img src="https://image.bdwms.com/FrxN1tlsNbsfyfNbH4sQ9fZgAGwx"></p><p>首先为什么TLS会设计成分层架构呢？最主要的原因就是公钥加密算法和对称加密算法的优劣性。当使用对称密钥的方式进行加密时，双方持有相同密钥，根据选定算法对信息加密，然后传输给对端进行解密。整个加解密的过程建立在双方持有相同的密钥，但是对于互联网多方交互的环境下，是不可能做到服务端与每个客户端直接持有一个对称密钥的，无论是维护密钥的成本，还是密钥派发时的安全保证，都是不可接受的。</p><p>因此为了解决密钥的派发管理问题，一般是采用公钥加密的方式，服务端将公钥派发出去，客户端利用公钥加密信息后返回给服务端，服务端再用自己的私钥进行解密。但是在真正设计时并没有选择完全使用两端采用公钥加密的方式进行加密沟通，因为公钥加解密的速度是非常慢的。</p><p>综合以上两点，TLS分为两层，握手层采用公钥加密的方式协商一段数据作为加密素材，传递给记录层做为对称加密的密钥材料，记录层生成对称密钥加密应用数据，既解决了密钥管理的问题，也保证了效率。同时这也有利于解耦各种需求，并化简整个问题的复杂度，将TLS分层模块化，每一部分完成一定的需求，并让之后的升级更新更加方便。</p><h2 id="推演思路"><a href="#推演思路" class="headerlink" title="推演思路"></a>推演思路</h2><p>了解了TLS最基本的架构后我们按照握手层和记录层的顺序进行推理分析，由需求得出方案，再根据连贯的问题，补充完善之前的方案。</p><h3 id="握手层"><a href="#握手层" class="headerlink" title="握手层"></a>握手层</h3><p>先从握手从来看，对于握手层，需要完成的最基本需求是利用非对称加密完成“材料”数据的传输，如客户端C向服务端S发送会话请求，服务端同意后下发自己的公钥S_Pub，客户端利用公钥加密数据Data传输给服务端，服务端利用自己的私钥S_Pri解密，得到数据。</p><p>但是以上步骤存在一个问题就是假设存在一个可以截取数据的中间人，是无法保证对端身份可信的。例如下图中间人M截获S_Pub，替换为自己的公钥M_Pub，客户端使用M_Pub作为公钥加密后发送数据，中间人能用自己的M_Pri解密并修改数据，再用S_Pub加密后发送给服务端，从而造成中间人攻击。</p><p><img src="https://image.bdwms.com/FvHsGjuxiuWLnIXz04eK4pLkoOm4"></p><p>之所以产生这个问题是因为缺乏身份认证，解决身份认证问题一般是利用消息认证码MAC或数字签名。对于消息认证码需要对称密钥，此时还不存在所以选用数字签名进行认证。假设数字签名的公私钥对位Sign_Pub和Sign_Pri，利用Sign_Pri对S_Pub进行数字签名，客户端利用Sign_Pub对数字签名进行认证（中间人是无法阻止客户端获取到Sign_Pub的）。</p><p>但是又如何确保数字签名的公钥是可信的呢？TLS给出的方案就是PKI证书体系，建立可信第三方CA，然后在客户端预装可信CA的公钥（存在一个证书链体系，不是只有一个CA）。服务端通过下发证书，客户端通过预装公钥验证证书签名以及一些其他信息，确认了服务端身份，这样就能解决身份认证的问题并且保证了服务器公钥的完整性。TLS还支持双向认证，即服务端请求验证客户端身份，但一般只需要验证一方就可以解决中间人问题了。</p><p>记录层会通过握手层传输过来的数据Data生成用于加密应用数据的对称密钥，在此之前为了保证刚刚握手的完整性，还需要做消息校验并用协商生成的对称密钥加密，作为双方第一个对称加密的包。通过这个消息就能验证协商出的对称密钥是否正确，以及之前握手消息没有被篡改。之后记录层就可以正式加密传输应用数据了。</p><p>完成这样一次会话过程后，我们还需要思考一个问题：每次会话都需要重新生成新的密钥，这样是否很浪费，我们是否能复用之前的密钥。由此TLS产生了会话恢复机制，包括使用Session_id和Session_ticket两种手段。</p><p>以上就是从我个人理解的角度，观察TLS握手层一步一步的设计缘由，当然这其中隐藏了很多具体的实现细节，比如每一步的密钥是如何生成的，应该如何使用，如何减少私钥泄漏后的影响，为什么会话恢复有两种模式等等很多有意思的问题，在接下的分析中我会挑选一些我认为比较重要的进行解析。</p><p>总结下以上步骤，整体思路如下图：</p><p><img src="https://image.bdwms.com/FgkGgBr3d1jnp_3ycicaEH7BkSCB"></p><h3 id="记录层"><a href="#记录层" class="headerlink" title="记录层"></a>记录层</h3><p>对于记录层步骤主要为分段，压缩（可选，因为存在安全问题一般不开启），加密和消息认证MAC（存在三种模式，stream ,block,aead）,添加消息头。在这一层会利用握手层传输的密钥材料，生成对称密钥，MAC密钥等必备参数。完成对数据的对称加密和生成消息认证码（AEAD模式将两者结合起来了），这就是这一层做的最主要的事情。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="握手层冷启动"><a href="#握手层冷启动" class="headerlink" title="握手层冷启动"></a>握手层冷启动</h3><p>通过上面的推演，我们大致了解了每一层的目的以及大致的步骤，这里我们来看一下具体的实现。</p><p>对于第一次冷启动的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello                  --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                               Certificate*</span><br><span class="line">                                         ServerKeyExchange*</span><br><span class="line">                                        CertificateRequest*</span><br><span class="line">                             &lt;--------      ServerHelloDone</span><br><span class="line">Certificate*</span><br><span class="line">ClientKeyExchange</span><br><span class="line">CertificateVerify*</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                     --------&gt;</span><br><span class="line">                                         [ChangeCipherSpec]</span><br><span class="line">                             &lt;--------             Finished</span><br><span class="line">Application Data             &lt;-------&gt;     Application Data</span><br><span class="line">*表示可选发送</span><br><span class="line">[]表示独立消息，这里为了防阻塞单独通知密钥协议已切换，有冗余在<span class="number">1.3</span>中删除</span><br></pre></td></tr></table></figure><ol><li>客户端发送ClientHello携带自己支持的加密组件以及随机值，服务端收到后选择支持的加密组件并携带服务端随机值返回一个ServerHello消息。</li><li>之后服务端发送Certifacate消息，包含证书信息，以及当Certificate信息不足时，发送ServerKeyExchange消息包含补充信息。</li><li>因为TLS支持双向认证，如果服务端需要对客户端身份进行认证的话，就会发送CertifacateRequest消息。</li><li>服务端发送ServerHelloDone表明自己已经发送完成。</li><li>当客户端收到CertificateRequest请求后，如果支持认证就发送Certificate消息包含自己的证书。如果没有收到验证请求，就不发送此条消息。</li><li>客户端发送ClientKeyExchange，交换密钥材料。例如使用RSA，就会生成由46字节的随机值和2字节的版本号组成的Pre_master_secret，使用服务端公钥加密后，在本条消息包含发送。</li><li>如果客户端发送了Certificate消息，就需要发送一条CertificateVerify消息来对之前的握手做Hash并用自己的证书私钥进行签名，表明自己确实拥有客户端证书私钥以验证身份，并保证了之前握手消息未被篡改。</li><li>之后会发送ChangeCipherSpec通知对端已经切换密钥了（为了防阻塞不在本消息流中）</li><li>客户端发送Finished消息，通过结合之前握手消息的Hash，Master_secret等生成验证数据，并利用协商出来的Session_key加密传输给对端。Finished消息是第一条使用协商出来的对称密钥加密的消息，通过这条消息验证了密钥的正确性以及之前握手消息未被篡改。</li><li>同样服务端也发送Finished消息，注意在做Hash时的握手消息包含上条客户端发送的Finished消息。</li><li>双方通过握手以及密钥派生计算已经拥有了相同的Session_key，可以进行正式的应用数据加密传输了。</li></ol><h3 id="握手层热启动"><a href="#握手层热启动" class="headerlink" title="握手层热启动"></a>握手层热启动</h3><p>分为Session_id和Session_ticket两种。第一种使用Session_id，发送ClientHello时会客户端会携带会话唯一标示，服务端同意后发送ServerHello以及Finished，根据保存的主密钥Master_secrert等信息以及新的随机值重新计算会话密钥来进行应用数据加密。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Client                                                Server</span><br><span class="line"></span><br><span class="line">ClientHello                   --------&gt;</span><br><span class="line">                                                 ServerHello</span><br><span class="line">                                          [ChangeCipherSpec]</span><br><span class="line">                              &lt;--------             Finished</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                      --------&gt;</span><br><span class="line">Application Data              &lt;-------&gt;     Application Data</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>但是因为存在分布式Session同步以及存储性能的限制，一般选用下面的Session_ticket手段，这十分类似HTTP中的Cookie和Session机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">第一次：</span><br><span class="line">   ClientHello</span><br><span class="line">   (empty SessionTicket extension)--------&gt;</span><br><span class="line">                                                   ServerHello</span><br><span class="line">                                (empty SessionTicket extension)</span><br><span class="line">                                                  Certificate*</span><br><span class="line">                                            ServerKeyExchange*</span><br><span class="line">                                           CertificateRequest*</span><br><span class="line">                                &lt;--------      ServerHelloDone</span><br><span class="line">   Certificate*</span><br><span class="line">   ClientKeyExchange</span><br><span class="line">   CertificateVerify*</span><br><span class="line">   [ChangeCipherSpec]</span><br><span class="line">   Finished                     --------&gt;</span><br><span class="line">            NewSessionTicket</span><br><span class="line">                                            [ChangeCipherSpec]</span><br><span class="line">                                &lt;--------             Finished</span><br><span class="line">   Application Data             &lt;-------&gt;     Application Data</span><br><span class="line">第二次：</span><br><span class="line">   ClientHello</span><br><span class="line">   (SessionTicket extension)     --------&gt;</span><br><span class="line">                                                    ServerHello</span><br><span class="line">                                 (empty SessionTicket extension)</span><br><span class="line">                                               NewSessionTicket</span><br><span class="line">                                             [ChangeCipherSpec]</span><br><span class="line">                                 &lt;--------             Finished</span><br><span class="line">   [ChangeCipherSpec]</span><br><span class="line">   Finished                      --------&gt;</span><br><span class="line">   Application Data              &lt;-------&gt;     Application Data</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>可以看到在第一次中服务端会发送一个NewSessionTicket消息，将会话信息加密并MAC在其中，客户端在第二次中携带ticket，服务端成功解密并验证完整性后，如果同意就会直接省略密钥协商的过程，从而节省了传输时间。</p><h3 id="记录层-1"><a href="#记录层-1" class="headerlink" title="记录层"></a>记录层</h3><p>从握手层得到数据如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ConnectionEnd          entity;</span><br><span class="line">    PRFAlgorithm           prf_algorithm;</span><br><span class="line">    BulkCipherAlgorithm    bulk_cipher_algorithm;</span><br><span class="line">    CipherType             cipher_type;</span><br><span class="line">    uint8                  enc_key_length;</span><br><span class="line">    uint8                  block_length;</span><br><span class="line">    uint8                  fixed_iv_length;</span><br><span class="line">    uint8                  record_iv_length;</span><br><span class="line">    MACAlgorithm           mac_algorithm;  <span class="comment">/*mac 算法*/</span></span><br><span class="line">    uint8                  mac_length;     <span class="comment">/*mac 值的长度*/</span></span><br><span class="line">    uint8                  mac_key_length; <span class="comment">/*mac 算法密钥的长度*/</span></span><br><span class="line">    CompressionMethod      compression_algorithm;</span><br><span class="line">    opaque                 master_secret[<span class="number">48</span>];</span><br><span class="line">    opaque                 client_random[<span class="number">32</span>];</span><br><span class="line">    opaque                 server_random[<span class="number">32</span>];</span><br><span class="line">&#125; SecurityParameters;</span><br></pre></td></tr></table></figure><p>利用PRF密钥派生函数生成以下数据用来加密和MAC。同时因为根据密码学的研究，客户端写&#x2F;服务端读，服务端写&#x2F;客户端读，这两种流向是不能使用同一个会话密钥的，会产生安全问题，所以生成两组write key。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client write MAC key*</span><br><span class="line">server write MAC key*</span><br><span class="line">client write encryption key</span><br><span class="line">server write encryption key</span><br><span class="line">client write IV</span><br><span class="line">server write IV</span><br><span class="line">*表示可选，AEAD模式无需MAC</span><br></pre></td></tr></table></figure><p>记录层的流程为数据分段，压缩（可选，因为存在安全问题一般禁用），加密和完整性保护，添加消息头。</p><p>我们这里重点关注加密和完整性保护。在密码学中存在三种加密和MAC的组合方式。</p><ul><li>Encrypt-and-MAC：明文加密和明文MAC拼接在一起。</li><li>MAC-then-Encrypt：对明文MAC后拼接在明文后，对整个进行加密。</li><li>Encrypt-then-MAC：对明文加密后在对密文MAC，将MAC内容拼接在密文后。</li></ul><p>TLS中采用的是第二种，但是随着发展发现了很多问题，例如Padding Oracle漏洞等。对于具体的做法又分为块模式+Hmac，流模式+Hmac，以及AEAD模式。块和流模式采用的是MAC then encrypt，之后为了从密码学上直接解决这个问题，密码学专家便提出了将加密和完整性保护融合在一个算法中即AEAD，彻底解决以上问题，因此更推荐使用AEAD模式例如aes-256-gcm。</p><h3 id="密钥派生函数与密钥变化"><a href="#密钥派生函数与密钥变化" class="headerlink" title="密钥派生函数与密钥变化"></a>密钥派生函数与密钥变化</h3><p>以上就是1.2的基本流程，针对密钥这一块需要单独强调一下。</p><p>我们先看下PRF函数，它通过输入的材料可以通过递归的Hash生成无限长的随机输出，我们可以截取任意长度作为我们的产出需求，看一下具体的表现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> P_hash(secret, seed) = HMAC_hash(secret, A(<span class="number">1</span>) + seed) +</span><br><span class="line">                           HMAC_hash(secret, A(<span class="number">2</span>) + seed) +</span><br><span class="line">                           HMAC_hash(secret, A(<span class="number">3</span>) + seed) + ...</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">A(<span class="number">0</span>) = seed</span><br><span class="line">A(i) = HMAC_hash(secret, A(i<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><p>因此在TLS中的表现形式就为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRF(secret, label, seed) = P_&lt;hash&gt;(secret, label + seed)</span><br></pre></td></tr></table></figure><p>我们有了这样一个派生密钥的工具后，我们在来看下具体的密钥变化。在整个过程中主要涉及三个密钥：</p><p><code>Premaster_secret -&gt; Master_secret -&gt; Session_key</code></p><p>其中Premaster_secret是在握手交换时完成的，采用不同的密钥协商算法会有不同变化，如下：</p><ul><li>RSA：客户端生成随机值作为Premaster_secret。</li><li>静态DH，ECDH：服务端公钥包含在证书中，客户端看是否包含在证书，不在的话就用ClientKeyExchange中，通过计算得出Premaster_secret。</li><li>动态DHE，ECDHE：公钥分别由服务端ServerKeyExchange，客户端ClientKeyExchange消息中，并计算得出Premaster_secret.</li></ul><p>之后使用Premaster_seceret通过PRF函数生成48字节的Master_secret</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret, <span class="string">&quot;master secret&quot;</span>,</span><br><span class="line">                            ClientHello.random + ServerHello.random)</span><br><span class="line">                            [<span class="number">0.</span><span class="number">.47</span>];</span><br></pre></td></tr></table></figure><p>Master_secret才是真正传递给记录层的，之后记录层利用Master_secret生成Session_key，然后切分为对称密钥，IV，MAC密钥来处理真正的应用数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key_block = PRF(SecurityParameters.master_secret,</span><br><span class="line">                <span class="string">&quot;key expansion&quot;</span>,</span><br><span class="line">                SecurityParameters.server_random +</span><br><span class="line">                SecurityParameters.client_random);</span><br></pre></td></tr></table></figure><p>这些变化的理由，我个人思考如下：</p><ul><li><p>为什么不直接使用Premaster_secret生成Session_key呢？</p><p>因为Premaster_secret的格式不同,RSA是48位，ECC类基于具体算法，我们想要得到固定格式的熵源，所以利用PRF函数计算出Master_secret，并且保证secret的随机性不仅仅受单一方影响，比如rsa做秘钥交换时仅仅是客户端发送48字节的值</p></li><li><p>为什么不直接使用Master_secret加密呢？</p><p>长度不够；利用主密钥生成会话密钥会让攻击者进行计算破解难度更大</p></li></ul><p>更多问题限于篇幅请看我之前的文章：<a href="https://www.bdwms.com/?p=946">TLS相关FAQ</a></p><h2 id="回顾与展望"><a href="#回顾与展望" class="headerlink" title="回顾与展望"></a>回顾与展望</h2><p>说到这里，我们暂停一下我们的脚步，首先来回顾一下TLS1.2是怎么完成它开始的设计目标的。</p><ul><li>机密性：非对称和对称加密的结合使用。</li><li>身份认证：证书体系的建立。</li><li>完整性保护：握手阶段的CertificateVerify，Finished消息做校验，记录层对消息做MAC。</li><li>性能：基于Session的会话恢复机制。</li><li>通用性：凡是基于RFC文档实现的，理论上上都是可以做到多种设备的兼容，并且采用的证书体系也是全球通用的。</li><li>可拓展性：在握手的会话中支持插件机制。</li></ul><p>除了以上特性TLS在其他种种方面也是做到基本可用成型，做到了对网络传输安全的保障。当然，这些年来随之密码学的研究深入，以及技术迭代的发展，由此产生了更高的要求，TLS1.2在一些方面已经不能满足业界了，我们简单看下它的主要问题在哪：</p><ul><li>不安全的密码组件，模式和配置。例如RC4,MD5等一种算法被破解，块加密，流加密模式的不安全因素。</li><li>伴随着斯诺登泄密事件，前向安全性更加被重视。</li><li>1.2冷启动至少需要2RTT，热启动需要1RTT，对于很多短链接的场景下，耗时过长是不可接受的。</li></ul><p>为了改善这些问题，1.3版本做了巨大的改变，甚至一定程度上放弃了前向兼容来保证架构的重新调整，让我们在一篇文章中看下TLS1.3究竟有何神奇之处。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来准备一篇文章写完整个TLS1.2和1.3的，但是发现就算省略了很多细节，仅仅是1.2也已经6000多字了，决定还是分上下两篇，方便读者阅读。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tools.ietf.org/html/rfc5246">TLS1.2 RFC</a></li><li><a href="https://halfrost.com/">冰霜之地</a></li><li><a href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/">TLS协议分析 与 现代加密通信协议设计</a></li><li><a href="https://blog.shell909090.org/blog/archives/2873/">安全协议的设计</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>再起航，2021</title>
      <link href="Hello-2021/"/>
      <url>Hello-2021/</url>
      
        <content type="html"><![CDATA[<p>2021起始，告别了我的旧博客，来到了我的新家。</p><p>Hello, World!</p><h2 id="告别过去"><a href="#告别过去" class="headerlink" title="告别过去"></a>告别过去</h2><h3 id="为什么要更换博客"><a href="#为什么要更换博客" class="headerlink" title="为什么要更换博客"></a>为什么要更换博客</h3><ul><li>Wordpress对markdown原生支持不好，尝试了n种插件后发现兼容性或者效果展示也不尽人意。</li><li>旧博客采用的是宝塔+Wordpress+Cloudflare，外加上各种插件，较容易存在安全问题，频繁升级维护很麻烦。</li><li>回望过去两年多来，陆陆续续写了130多篇的博客，但是其质量限于本人的水平，以及写作时较为随意，导致整体的质量不高。并且随着我的大学时光即将结束，慢慢进入社畜的节奏，无法维持高频度的更新，由此想要更加精炼自己的文章。所以最终决定抛下旧包袱，开启新的篇章。</li></ul><h3 id="方案分析选择"><a href="#方案分析选择" class="headerlink" title="方案分析选择"></a>方案分析选择</h3><p>既然决定了要更换博客，那么肯定就要进行好好分析，分为两个部分，一个是新博客如何选择，旧博客如何处理，经过我的尝试，最后完成了本次更新升级。</p><ul><li><p>旧博客：</p><p>一开始的想法是做二级域名，将旧博客指向二级域名，例如backup.bdwms.com。方法很简单，因为我的域名统一托管在cloudflare，只要添加个二级域名的A记录就行了，但是此时就存在两个问题了。</p><p>一个是免费的SSL证书只能是单域名，通配符的证书都要钱，所以就需要给二级域名单独申请一张证书。</p><p>二就是我发现更改完二级域名后，整个Wordpress的链接指向都乱了，分析和搜索了下需要甚至需要手动改数据库，这个操作很危险，考虑我放弃了这个方案，最终选择保留旧博客的域名，重新申请个域名。</p></li><li><p>新博客：</p><p>选择Hexo，优秀地支持markdown，安装和维护简单，作为黑色爱好者选择了极简的主题<a href="https://github.com/probberechts/hexo-theme-cactus">Cactus</a>，也是因为之前看到P牛的博客。</p></li></ul><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h3><p>官网安装npm，hexo，网上文章太多了不多赘述。然后就是配置主题Cactus，进行了一些魔改，评论系统选择了Disqus（需要科学上网）。</p><p>在部署的时候，出现一个选择，一个很简单的方法是直接在Github中配置个[username].github.io，然后在_config.yml中配置deploy的repository，再将自己的新买的域名解析到[username].github.io，再在仓库的settings配置下域名就可以替换域名了。</p><p>但是这样的话不够优雅，每次都需要</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>并且存在一个备份和同步问题，我要是换了电脑怎么复原，以及怎么在不同电脑上写呢。我研究了网上的方法，很多说在仓库里面新开一个branch，但是这样的话很多配置魔改的文件都会公开，遂放弃。</p><h3 id="CI-x2F-CD"><a href="#CI-x2F-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h3><p>最后经过研究参考部署的方便，以及备份和同步，选择了Github提供的Action来做自动部署，优化使用流程只需要push代码就可以自动部署，并且将自己的源代码单独放在一个私有库，生成文件在公开库，同时将魔改后的主题文件单独放在一个库中。具体流程如下：</p><ol><li><p>生成三个库，一个私有库放BlogSource源代码，一个公共库Themes放魔改的主题，一个公共库[username].github.io放真正的生成文件。然后进行生成密钥对，私钥放<code>Settings -&gt; Secrets -&gt; Add a new secret</code>，命名<code>HEXO_DEPLOY_PRI</code>,公钥放github.io的公钥库<code>Settings -&gt; Deploy keys -&gt; Add deploy key</code>，命名<code>HEXO_DEPLOY_PUB</code>，开启<code>Allow write access</code></p></li><li><p>因为我clone后魔改的主题也想要进行管理，所以将其推到Themes库，注意这里push的时候将主题的_config.yml改名放在博客根目录中，不能传到公共库中，在博客根目录生成git后，与主题的git冲突，于是选择使用submodule方式，进行分离管理，命令类似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add [themes_url] themes/cactus</span><br></pre></td></tr></table></figure><p>然后为了能够保证CNAME不被每次覆盖，在source文件下放一个CNAME文件，里面写要CNAME的域名，push源代码到远端。</p></li><li><p>最后也是最重要的生成CI&#x2F;CD文件，在私有库的Action中选择生成一个Workflow，配置文件例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">GIT_USER:</span> <span class="string">user.name</span></span><br><span class="line">  <span class="attr">GIT_EMAIL:</span> <span class="string">user.email</span></span><br><span class="line">  <span class="attr">THEME_REPO:</span> <span class="string">birdmanwings/cactus-modify</span></span><br><span class="line">  <span class="attr">THEME_BRANCH:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">DEPLOY_REPO:</span> <span class="string">birdmanwings/birdmanwings.github.io</span></span><br><span class="line">  <span class="attr">DEPLOY_BRANCH:</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span> <span class="string">on</span> <span class="string">node</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span> <span class="string">and</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.os</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">os:</span> [<span class="string">ubuntu-latest</span>]</span><br><span class="line">        <span class="attr">node_version:</span> [<span class="number">14.</span><span class="string">x</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">theme</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">themes/cactus</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">deploy</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.DEPLOY_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.DEPLOY_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">.deploy_git</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configuration</span> <span class="string">environment</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">HEXO_DEPLOY_PRI:</span> <span class="string">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.name $GIT_USER</span></span><br><span class="line"><span class="string">          git config --global user.email $GIT_EMAIL</span></span><br><span class="line"><span class="string">          cp _config.theme.yml themes/cactus/_config.yml</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">run</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>需要更改下名字，邮箱，主题地址，分支名称，然后commit就可以了，这里注意主题config，密钥对名称是否正确，之后本地pull下同步下代码，写一个文章push上去后能够发现成功自动部署。</p></li></ol><p>可以看下最后的项目结构类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy_git</span><br><span class="line">├── .git</span><br><span class="line">├── .github</span><br><span class="line">│   └── workflows</span><br><span class="line">│       ├── main.yml</span><br><span class="line">├── _config.landscape.yml</span><br><span class="line">├── _config.theme.yml</span><br><span class="line">├── _config.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── source</span><br><span class="line">│   ├── CNAME</span><br><span class="line">│   ├── _posts</span><br><span class="line">│   │   ├── Hello,World.md</span><br><span class="line">│   ├── about</span><br><span class="line">│   │   └── index.md</span><br><span class="line">│   ├── categories</span><br><span class="line">│   │   ├── index.md</span><br><span class="line">│   └── search</span><br><span class="line">│       ├── index.md</span><br><span class="line">└── themes</span><br><span class="line">    └── cactus</span><br><span class="line">        ├── LICENSE</span><br><span class="line">        ├── README.md</span><br><span class="line">        ├── gulpfile.js</span><br><span class="line">        ├── languages</span><br><span class="line">        ├── layout</span><br><span class="line">        ├── package.json</span><br><span class="line">        ├── scripts</span><br><span class="line">        └── source</span><br></pre></td></tr></table></figure><h3 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h3><p>如何备份恢复呢，先配好git，npm，hexo，然后clone recurvise自己的源代码下来，<code>npm install</code>安装下依赖，然后就可以写文章push自动部署了，跟我们平常做项目管理没有什么区别了。</p><h3 id="阿里云CDN加速"><a href="#阿里云CDN加速" class="headerlink" title="阿里云CDN加速"></a>阿里云CDN加速</h3><p>折腾了几天终于配好了，吐槽下阿里云前端逻辑真的乱，然后网上教程好多还是错的，无语。首先域名需要备案，然后买一个下行流量包和静态HTTPS包，然后申请下全站加速，源站选username.github.io，选择申请，不同前缀需要申请不同的加速域名，也可以使用通配符，这里申请了www和@。</p><p><img src="https://image.bdwms.com/Fk0Bfrkv8qzpYext4iHx6jtJybqX"></p><p>通过后会分配一个CNAME，然后配置CNAME域名，境外和境内分两个线路来配，这样就可以国内外都满速访问，如下：</p><p><img src="https://image.bdwms.com/FnUPZ-WhDF1MECJkH7c4A1G-sC7c"></p><p>Github仓库的custom域名指向bdwms.site。然后因为cdn没有HTTPS，需要申请个免费证书部署到CDN，开启强制HTTPS。等会后看下国内访问速度，一片绿感人。</p><p><img src="https://image.bdwms.com/FmB36fDsTH3KgzELf6JVobQ6-_qO"></p><h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>下一个十年，</p><p>想做一个懂业务的安全人，</p><p>想做一个有思考的技术人，</p><p>想做一个明白爱的成年人，</p><p>再起航，2021～</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/87053283">Git中submodule的使用</a></p></li><li><p><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">利用 Github Actions 自动部署 Hexo 博客</a></p></li><li><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-5">超详细Hexo+Github博客搭建小白教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>静夜思（十八）-莫愁前路无知己</title>
      <link href="night-thoughts-18/"/>
      <url>night-thoughts-18/</url>
      
        <content type="html"><![CDATA[<p>写于新旧年交际之时，赠诗一句以自勉，莫愁前路无知己，天下谁人不识君。</p><h2 id="回首2020"><a href="#回首2020" class="headerlink" title="回首2020"></a>回首2020</h2><p>2020的最重要的两件事，一个是在长亭实习了整整半年，另一个就是从7月开始一直到10月的秋招了。</p><h3 id="六月长亭"><a href="#六月长亭" class="headerlink" title="六月长亭"></a>六月长亭</h3><p>北京，二月寒冬，初来乍到，藏在出租屋中回炉重造自己。</p><p><img src="https://image.bdwms.com/FoF9MF0w5KmxceZCuMjGBmjWPj0I"></p><p>长亭科技，认识了很多可爱的同事，技术氛围很浓厚，大家的关系都很融洽。第一次了解了公司项目是如何研发的，第一次亲身参与到项目研发。</p><p><img src="https://image.bdwms.com/Fk696l7teLX-3UI_bIEWTQR5QbkM"></p><p>第一次来到天安门，respect。</p><p><img src="https://image.bdwms.com/FlJmIk4wdRbWN9EgAvL1Sfg2Zv03"></p><h3 id="漫漫秋招"><a href="#漫漫秋招" class="headerlink" title="漫漫秋招"></a>漫漫秋招</h3><p>从七月被字节，阿里，百度轮番挂掉怀疑人生，之后调整心态和方法，最终也算是有所收获。</p><p><img src="https://image.bdwms.com/FjZ_uUbckm2rhGsNksdMdJm7VoCh"></p><h2 id="展望2021"><a href="#展望2021" class="headerlink" title="展望2021"></a>展望2021</h2><h3 id="橙色之路"><a href="#橙色之路" class="headerlink" title="橙色之路"></a>橙色之路</h3><p>来到a厂，和长亭的感觉完全不一样，很大，有点累，很多东西需要学，期望能够未来能够快速成长。</p><p><img src="https://image.bdwms.com/FnGfKdiKR8Omf4NKsRpHwM7HpECl"></p><h3 id="自我期许"><a href="#自我期许" class="headerlink" title="自我期许"></a>自我期许</h3><p>接下的一年里，我想要给自己定一些目标，具体的实现步骤暂时不公开，等我完成后写一写</p><ul><li>了解企业安全，熟悉业务，能够独立处理工作问题。</li><li>体重控制在135，保证基本的身体健康。</li><li>熟悉杭州市，研究杭州楼市。</li><li>养一只银渐层。</li><li>拿到日语N3证。</li><li>晋升折纸熟手。</li><li>了解并尝试打造自己个人品牌。</li></ul><h2 id="幻想十年"><a href="#幻想十年" class="headerlink" title="幻想十年"></a>幻想十年</h2><p>幻想一下离开校园的我接下来会有怎样的人生，未来的十年我又会何去何从呢，我会成为一个什么样的人，我会扎根在哪一座城市，我会遇到怎样的她？我时常在幻想着这些，在与现实的不断交互中，不断地调整着目标和期望。就像国家都有五年计划，一个小小的普通人想要把日子过得更明白不是更应该多多计划么。</p><p>在工作上：</p><ul><li>第一年熟悉整个团队的运作，融入团队中，找准自己的定位以及之后发展的方向。</li><li>三年内，能够独立解决问题，成为专业熟手，在相应的领域内有一定的话语权。</li><li>五年内，成为攻坚人员，能够解决难题，形成自己的完整技术栈，方法论，培养自己带队攻坚的能力。</li><li>十年内，成为行业专家，拥有一定的行业知名度，能够从无到有构建相应的能力，做到成体系的建设输出。</li></ul><p>在自我塑造中：</p><ul><li>保证基本的身体健康，控制体重在135至140中，拥有一项坚持的运动。</li><li>保证良好的心理健康，学习并了解基本的心理学知识，对自我有足够的认知与评估。</li><li>拓展自我的兴趣爱好，保持足够的好奇心与实践能力。</li><li>拥有足够的社会经验，生活常识，能够在中国社会做到积极生活。</li></ul><p>在情感上：</p><ul><li>积极陪伴关心父母。</li><li>明确自己的交友标准和原则，维持自己的朋友圈，可以尝试从更多的圈子中拓展自己的朋友。</li><li>明确自己的择偶标准，然后针对性的去拓展交际圈（卑微码农</li></ul><p>经济上：</p><ul><li>一年内，明确自己的理财理念，熟悉自己和家庭的经济状况。</li><li>三年内，掌握基本的理财知识，形成自己的理财方法论和进行一定的实践。</li><li>五年内，熟悉个人理财的基本方法，对多种理财方式都有一定的了解，并对某几个方面拥有自己的实践经验或者运作方法。</li><li>十年内，寻求一种或多种财务副业，争取能够副业收入维持个人家庭生活，甚至做到超过主业收入。</li></ul><h2 id="今日寄语"><a href="#今日寄语" class="headerlink" title="今日寄语"></a>今日寄语</h2><p>思来想去，迟迟无法落笔，不得不感慨自己的语言功底之差，感到羞愧对自己的高中班主任，新的一年中，更加需要多学多看多想多写。纸上得来终觉浅，绝知此事要躬行，写的再多还是需要我一点一点去实践在我的生活中。大年初一的这一天，我满怀希望。</p><p>惟愿诸君一生喜乐安康！</p>]]></content>
      
      
      <categories>
          
          <category> 静夜思 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自建情报库-楼市篇</title>
      <link href="information-database-property-market/"/>
      <url>information-database-property-market/</url>
      
        <content type="html"><![CDATA[<p>俗话说兵马未动，粮草先行，在这个信息化时代，情报就是我们出兵北上，征战社会的“粮草”。初入大学时因为缺乏主动意识，带来的巨大信息差导致错过了很多机会。为了吸取教训，弥补遗憾，即将正式迈入社会，独自生活的笔者决定新建自己的情报库，由此决定新开一个专栏。</p><p>同时因为每个人的社会背景与内在属性都是不同的，对于笔者有用的信息可能对其他人就没有参考价值。因此，为了能够提供给读者更多的参考价值，整个系列的文章尽量抽象出笔者的思考过程，做到授人以渔。</p><p>那么作为整个系列的第一篇文章，笔者想要从房产，这个年轻人的第一座大山谈起，无论你现在是否能买得起房，作为中国经济的核心命脉，房产都应该是初入社会的年轻人需要考虑的。当然因为笔者目前也是在调研进行中，所以本篇文章会随着时间推移进行修改。</p><h2 id="背景条件"><a href="#背景条件" class="headerlink" title="背景条件"></a>背景条件</h2><p>首先我们要明确，对于房地产，整个产业的复杂度不是非专业的个人能够完全弄清的，包括很多所谓的经济专家也只是信口开河，牢记没有人能预言未来走向！我们只能根据个人的条件，以点窥面，尽量优化自己的选择。</p><p>所以本篇文章的背景也是从笔者个人的角度和背景出发，思考年轻人购置第一套房需要了解什么，从而针对性地收集情报信息。从面对繁多虚假信息不知道从何下手，到能够条理清晰去梳理脉络。</p><p>而读者想要更好地进情报收集，也需要对自身的条件背景进行充分了解，包括家庭环境，职业发展，个人情感等方面，后面会进行展开说明。</p><h2 id="解析目标"><a href="#解析目标" class="headerlink" title="解析目标"></a>解析目标</h2><p>第一步，思考以下问题：</p><ol><li><p>为什么要买房？</p><p>根据房屋的属性可以分为几种：刚需房，学区房，投资房，置换房。年轻人第一个房子一般都是刚需房，作为自住使用。当然以上几个属性可能会有叠加，也会导致价格上涨乃至翻倍。</p></li><li><p>首付预算多少，还款能力多少？</p><p>决定了能不能买房，以及自己是否有偿还能力。一般普通人都会选择贷款买房，毕竟全款买房的都是土豪。国家提供给每个人一般为两次贷款机会（全国联网互通），第一次为30%，第二次为60%，这都是优质的杠杆机会，毕竟银行不是你想借钱就能借的。从过去几十年的国情来看，普通人能跑赢大盘通货膨胀的最稳定手段就是购置房产。</p></li><li><p>个人发展是否有考虑？</p><p>包括想要在哪个城市发展，职业发展是否有考虑，个人情感是否稳定。工作和婚姻稳定后，购置房产再想要更换城市的代价是很大的，必须结合好自己其他方面的发展来一同考虑。</p></li></ol><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>进一步到了本文重点，如何做信息收集，笔者经过思考和分析决定从三个角度来行动。</p><p>概括下来就是三个字：<strong>房，人，钱</strong>。下面展开来说：</p><h3 id="地区与房屋属性"><a href="#地区与房屋属性" class="headerlink" title="地区与房屋属性"></a>地区与房屋属性</h3><p>第一个关键字：房。更具体的说是从大区域到具体房屋属性进行了解，我们要做到对居住地环境了如指掌。</p><ol><li><p>市：了解全貌</p><ul><li>杭州市地图：了解行政划分，城市中心，地貌等基本因素。</li><li>杭州地铁规划图：即未来交通规划。</li><li>杭州控规图：即城市规划用地，一般在当地房产局可查阅。</li></ul></li><li><p>区域：了解区域化结构</p><ul><li><p>行政划分</p><p>作为基本参考，例如余杭区，虽然行政是一个区但是房价能一个天一个地。但是考虑到上学时，杭州又是按行政区划分。</p></li><li><p>教育划分</p><p>杭州学区划分，学区是房价能够翻倍的唯一因素，虽然好但是导致太贵了很多年轻人无法考虑。参考时注意别被开发商宣传误导欺骗，同时随着时间变化，学区也有可能改变，都要考虑到。</p></li><li><p>物理划分</p><p>交通，城市（副）中心。房子最为重要的属性就是地段，而交通就是决定地段属性好坏的重要标准，包括是否近地铁，近机场等等。除此之外，一个城市不一定越靠近地理中心越好，可能存在多个城市中心，我们都需要考虑，例如杭州的未来科技城就因为阿里在那里。</p></li></ul></li><li><p>一手房 or 二手房</p><p>一手房和二手房是两个完全不同的市场。因为国家限制调控，一手房一般都有限价，会比二手房便宜很多，但是需要摇号，很难买到。所以两者考虑的方面就有所不同，例如一手房需要考虑开发商是否正规，楼盘地段规划等等，二手房需要考虑房主是否完全持有房子，产权是否清晰，中介是否正规等。</p></li><li><p>房屋属性</p><p>到了具体的房屋属性，笔者总结分为主要的四点：</p><ul><li>大小：既由你的钱包决定，并且也有一定决定属性，例如在二手买卖时，小的房子例如两室的会比四室的好卖。</li><li>通勤：包括地铁，路况。作为自主的话肯定越近越好，靠近地铁。</li><li>配套：包括<strong>教育</strong>，医疗，生活设施。其中教育也就是学区可能是影响最大的，不过自主房可能就暂时考虑不到这个了。配套的完善度决定了生活是否方便，例如商场，超时，医院等等。</li><li>舒适性：1.户型＞2.楼层＞3.朝向＞4.得房率＞5.容积率＞6.楼栋位置＞7.物业＞8.小区体量。具体的房子样式，个人看中的因素排名。</li></ul></li></ol><p>除此之外可能个人还有很多特质化要求，比如笔者可能需要一定的易卖性，以及一定的现金流保证，就不会选择太大的户型。</p><p>根据以上这些属性从而衍生出几类房子的定义：刚需房，学区房，投资房，置换房。</p><h3 id="人与政策因素"><a href="#人与政策因素" class="headerlink" title="人与政策因素"></a>人与政策因素</h3><p>第二个关键字：人。我国是一个政策决定型国家，并且政策是多变的，我们需要时刻关注，同时也要结合个人发展来综合考量。</p><ul><li><p>外部因素：</p><ul><li><p>政策：从大到小，可以从官网来查看政策，以及房管局来看楼市政策，当然精力有限我们重点还是关注市级政策。</p><p>国际经济，国务院，浙江省，<strong>杭州市</strong></p></li><li><p>人口流动与转化定居率：看国家统计局和各种历史记录</p><p>人口流入量与转发决定了购房热度，从而影响着房价走势，可以作为一个参考因素。</p></li></ul></li><li><p>内部因素：</p><ul><li>职业发展：在当地城市是否有足够的发展空间，职级晋升等。</li><li>结婚发展：大多数时候是一锤定音的因素，例如笔者不能接受异地恋。</li></ul></li></ul><h3 id="资金"><a href="#资金" class="headerlink" title="资金"></a>资金</h3><p>第三个关键字：钱。没钱都是空头支票，加油挣钱吧，打工人~</p><ul><li><p>外部</p><ul><li>公积金政策</li><li>银行商贷政策</li></ul><p>一般公积金贷款（3.5%）会比商贷便宜（5.x%）很多，但是有上限，并且是根据公积金余额进行计算可贷款额度的，只有两次机会，所以当余额不多时一般选择商贷，避免浪费公积金贷款机会。</p></li><li><p>内部</p><ul><li>首付</li><li>月还款能力</li></ul><p>自行搜索工资计算器，房贷计算器。</p></li><li><p><strong>交付流程是否安全正规</strong></p><p>无论是一手房还是二手房都一定主要资金转账安全，合同签约是否正规，重中之重！</p></li></ul><h3 id="特殊化事件"><a href="#特殊化事件" class="headerlink" title="特殊化事件"></a>特殊化事件</h3><p>除了以上通用的三因素，每个城市和个人都会有特殊的重大事件会影响到楼市，我们都需要关注并了解，例如杭州：</p><ul><li>2022亚运会</li><li>阿里巴巴</li></ul><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>以上进行的情报收集都是动态，具有一定时效性，不能僵化自己的思路，需要多打听多问，多实际跑楼盘，这也是笔者未来一年内会去做的事情，但是整体框架已经搭了起来，我们需要做的就是去实践评估，行动起来吧，少年！</p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><ul><li><a href="https://hz.ke.com/">贝壳找房</a></li><li><a href="http://fgj.hangzhou.gov.cn/">杭州市住房保障和房产管理局</a></li><li><a href="https://link.zhihu.com/?target=http://jjhygl.hzfc.gov.cn/webty/gpfy/gpfySelectlist.jsp">杭州市二手房交易监管服务平台</a></li><li><a href="https://bbs.hangzhou.com.cn/forum-207-1.html">口水楼市</a></li><li><a href="http://www.hangzhou.gov.cn/">杭州市人民政府</a></li><li><a href="http://www.zj.gov.cn/">浙江省人民政府</a></li><li><a href="http://www.gov.cn/guowuyuan/">国务院</a></li><li><a href="https://data.stats.gov.cn/">国家统计局</a> </li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>年轻人买房要注意什么？ - 土豆技师的回答-杭州二手房例子 - 知乎 <a href="https://www.zhihu.com/question/21731231/answer/1189064676">https://www.zhihu.com/question/21731231/answer/1189064676</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/142977813">2021年杭州购房政策最新版</a>   （杭州2021最新政策） </p></li><li><p><a href="https://www.shenlanbao.com/zhinan/120090210504573901">买房子需要注意什么？2020最全买房攻略来了！</a>   </p></li><li><p><a href="https://zhuanlan.zhihu.com/p/60016447">一手房VS二手房的买房攻略</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/35053921">一套有效的方法定位房价</a>  （需要查找的资料，包括政策，人口，房价走势）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 情报库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个人的秘密-端到端加密</title>
      <link href="e2ee/"/>
      <url>e2ee/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是端到端加密"><a href="#什么是端到端加密" class="headerlink" title="什么是端到端加密"></a>什么是端到端加密</h2><p>在加密网络通信中（例如TLS），可以防止攻击者破解加密报文，伪造身份。我们假设一个场景：存在两个客户端A和B，它们通过服务器S进行消息传递，从而实现通信。我们可以观察在这个过程中，客户端A与服务器S做一次消息传递，加密消息发送到服务端时会进行解密，当要发送给客户端B时，再进行一次加密然后传输，这也是常见IM的通信方式。</p><p><img src="https://image.bdwms.com/FuPdRD-5x6JDJ-twQbnhC0uNuFzn"></p><p>整个过程中，明文会存储在服务器，当攻击者攻破服务器，或者服务器本身就是恶意的，那么客户之间的通信消息就会泄漏。那么是否存在一种方式，只有通信双方能够加解密，作为传递信息的第三者（包括提供服务的运营商）无法获知明文呢？</p><p>端到端加密（End-to-end encryption，E2EE）正是为了解决这个问题所产生的。书面定义：</p><blockquote><p>是一种只有参与通讯的用户可以读取信息的通信系统。 总的来说，它可以防止潜在的窃听者——包括电信供应商、互联网服务供应商甚至是该通讯系统的提供者——获取能够用以解密通讯的密钥</p></blockquote><p><img src="https://image.bdwms.com/FsloogA_7i-1j3xjYAGESskUdDRG"></p><p>今天我就想围绕着端到端加密的设计来做分析，回答一些我认为比较关键的问题，而不仅仅是复述过程（网上很多文章只是简单介绍了该概念和流程，而没有说明为什么要这样设计），当然因为本人的能力有限，如有错误请指正。</p><h2 id="业界现状"><a href="#业界现状" class="headerlink" title="业界现状"></a>业界现状</h2><p>伴随着美国棱镜门监控事件，人们越来越看重个人隐私保护，将自己的机密通话消息托管给服务商不再可信。为此诞生了很多端到端通信的IM应用，号称能够实现只有两个人知晓的加密通信，其中主流的几个包括Telegram，Whatsapp，Skype等，能力图如下：</p><p><img src="https://image.bdwms.com/Fmt3m8FcP5srMMrRjsqKDpdwSKgZ"></p><p>而对于如何做到端到端加密，除了Telegram自己设计了一套MTProto协议（我暂时还没研究，因为它的资料不是那么全），大部分应用使用的都是Signal协议作为它们的基础。</p><p>Signal作为一个开源的协议，已经被众多安全专家肯定了它的安全性，并且Signal团队也开源了相关库和客户端，服务端代码，是值得信赖的。但是在其上实现的其他应用是否值得相信又是值得商榷的，比如Whatsapp被Facebook收购，Facebook又曾经加入过棱镜计划，并且Whatsapp本身是不开源的，虽然它宣扬自己是基于Signal实现的完全端到端加密，但是究竟如何还是耐人寻味。</p><p>以上就是端到端加密的一些背景，下面我将会介绍和分析协议中最为核心的部分，看看Signal是如何实现端到端加密通信的。</p><h2 id="Signal协议简介"><a href="#Signal协议简介" class="headerlink" title="Signal协议简介"></a>Signal协议简介</h2><p>Signal协议主要由几个部分组成，在官方文档中有四篇文章分别为：</p><ul><li><a href="https://signal.org/docs/specifications/xeddsa/">XEdDSA and VXEdDSA</a>：介绍了如何将做ECDH密钥交换的椭圆曲线，转换为可以做数字签名。</li><li><a href="https://signal.org/docs/specifications/x3dh/">X3DH</a>：将DH算法进行拓展。用于在两个客户端建立共享密钥，提供异步通信能力，身份验证（但是不防中间人，很奇怪是吧，后面我会解释），一定的前向安全性，以及可否认性。</li><li><a href="https://signal.org/docs/specifications/doubleratchet/">Double Ratchet</a>：双棘轮算法，结合了对称密钥棘轮和DH棘轮，保证了前向安全和后向安全。</li><li><a href="https://signal.org/docs/specifications/sesame/">Sesame</a>：用来做多设备多用户的同步管理。</li></ul><p>受篇幅限制，我决定挑出X3DH和Double Ratchet来做分析，个人认为这也是Signal协议中最为核心的点。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="DH类算法"><a href="#DH类算法" class="headerlink" title="DH类算法"></a>DH类算法</h3><p>Diffie–Hellman和基于椭圆曲线的Diffie–Hellman算法，用于两方进行密钥协商，详细介绍请看<a href="https://blog.csdn.net/qmickecs/article/details/76585303">离散对数和椭圆曲线加密原理</a>，简化表述：<br>第一种基于有限域上的离散对数问题：<br><strong>已知x和G，求G^x mod p是简单的；反过来已知G^x mod p和G，求x是困难的。</strong></p><p>第二种是基于椭圆曲线上的离散对数问题，即ECDH类，口语化表达类似：<br><strong>已知x和G，求xG是简单的（椭圆曲线上的运算，不是简单的数乘）；反过来已知xG和G，求x是困难的。</strong></p><p>所以一般我们把x作为私钥，xG（G^x）为公钥，使用的过程类似：</p><ol><li>服务端拥有私钥a，客户端拥有私钥b，第一次服务端发送公钥aG和参数G。</li><li>客户端接受到后计算bG，发送自己的公钥bG至服务端。</li><li>此时客户端拥有aG和b，服务端拥有bG和a，双方经过计算a(bG)=b(aG)=abG，得出相同的会话数据。</li></ol><p>此时中间人只能截获aG，bG和G，无法求出abG，因为想要求出的话记必须通过aG和G（bG和G）计算出a（b），但是从上文的条件可以看出这是困难的，由此这就是DH类算法的原理。</p><p><img src="https://image.bdwms.com/FpcwsX8mQoxRoZVp1cPJ5bMnpTFv"></p><h3 id="前向安全，后向安全"><a href="#前向安全，后向安全" class="headerlink" title="前向安全，后向安全"></a>前向安全，后向安全</h3><blockquote><p>前向安全：长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。</p><p>后向安全：长期使用的主密钥泄漏不会导致之后的会话密钥泄漏。</p></blockquote><p>通俗点说就是某个密钥泄漏不会对之前或者之后的加密消息有影响，例如在TLS中如果使用ECDHE，DHE就可以保证前向安全，因为协商的私钥都是临时生成的。</p><h2 id="Signal之X3DH协议"><a href="#Signal之X3DH协议" class="headerlink" title="Signal之X3DH协议"></a>Signal之X3DH协议</h2><h3 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h3><p>回想下端到端加密的目的，我们要实现一个只有通信双方能够加解密的过程，包括提供消息转发的服务器也不知道明文，那么服务端不会存储明文，通信的客户单A和B就需要直接协商出一个对称密钥来做加密传输，也就是说设计的协议需要提供离线<strong>异步协商对称密钥</strong>的能力。</p><p>并且为了保证通信双方的身份不与消息强绑定，协议需要提供<strong>可否认性</strong>，即两方都可以否认之间曾经存在会话，这与TLS的不可否认性正好相反，加大了第三方取证的难度。</p><p>最后为了安全性，<strong>对抗密钥泄漏</strong>可能造成的安全问题，例如前向安全，身份伪造等，协议还添加了额外的过程来做防御。</p><p>总之X3DH的最终目的就是协商出一个对称密钥，并保证上面所说的的几个特性，接下来我们来看下相关的定义概念。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>首先约定会用到的角色，密码学函数以及相关参数。</p><p>三个角色：</p><ul><li>Alice：会话的发起者。</li><li>Bob：会话的响应者。</li><li>Server：存储Alice发送给Bob的消息，以及存储一些客户端信息用于密钥协商。</li></ul><p>密码学函数：</p><ul><li>DH(PK1,PK2)：使用PK1和PK2相对应的公私钥进行ECDH的计算，生成一个共享密钥。</li><li>Sig(PK,M)：使用PK对应的私钥对M做签名，验证的时候时候用相应的公钥。</li><li>KDF(KM)：KM是包含密钥的序列，利用HKDF密钥派生函数做拓展衍生出新的密钥。</li></ul><p>会使用到的参数密钥：</p><table><thead><tr><th>Name</th><th>Definition</th></tr></thead><tbody><tr><td>IKA</td><td>Alice的身份密钥</td></tr><tr><td>EKA</td><td>Alice的临时密钥</td></tr><tr><td>IKB</td><td>Bob的身份密钥</td></tr><tr><td>SPKB</td><td>Bob的被签名预密钥</td></tr><tr><td>OPKB</td><td>Bob的一次性预密钥</td></tr></tbody></table><p>这些都是成对出现的公私钥，但是为了简化描述，我们这里只关注公钥的使用。</p><p>通信的双方都会持有一个身份密钥例如Alice的IKA，Bob的IKB。</p><p>Bob持有一个被IKB签名的预密钥SPKB，SPKB会周期性地替换。同时Bob还会有一组一次性预密钥OPKB，每发起一次X3DH协商，就会消耗一个OPKB。（之所以叫预密钥是因为SPKB和OPKB都会在Alice发起会话之前发送到服务器）</p><p>每一次发起X3DH协议，Alice都会生成一个临时密钥EKA。</p><p>经过一次X3DH密钥协商，Alice和Bob会协商出一个32字节的共享密钥SK，这个SK（或者用HKDF函数拓展这个SK）会用在后面的其他协议。</p><h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p>基本流程为三个部分：</p><ol><li>Bob将自己的IKB和prekey发送到服务端。</li><li>Alice从服务器获取一组Bob的公钥，然后使用它生成SK，之后发送初始化信息发送给Bob。</li><li>Bob接受初始化消息，并验证生成相应的SK。</li></ol><p>然后我们来看下具体的步骤，首先Bob生成相应的公私钥：</p><ul><li>Bob的身份密钥IKB</li><li>Bob的被签名预密钥SPKB</li><li>Bob的预密钥签名Sig(IKB,Encode(SPKB))，就是用IKB对SPKB做一个签名生成的信息</li><li>Bob的一组临时预密钥OPKB1，OPKB2，OPKB3…</li></ul><p>然后Bob发送这些到服务器上（Alice其实也会生成发送一组上列信息上传给服务器，但是在一次会话中只会用到Alice的身份密钥IKA），Bob会周期性地更换SPKB，并替换之前旧的SPKB，可能会继续持有一段时间SPKB的私钥以处理延时的消息，之后会删除私钥以保证前向安全（Bob同样会删除一次性预密钥的私钥当收到相应的初始化消息后）</p><p><img src="https://image.bdwms.com/Fk0ETNDhliXg1lnoYC9zWBqgb_Jm"></p><p>之后正式开始协商过程，Alice首先会向服务器请求Bob的相关信息，包括：</p><ul><li>Bob的身份公钥IKB</li><li>Bob的被签名预密钥SPKB</li><li>Bob的预密钥签名Sig(IKB,Encode(SPKB))</li><li>Bob的一次性预密钥（可选的，当服务器中还有的时候发送）</li></ul><p>然后Alice会生成一组临时密钥EKA，进行密钥计算</p><p><img src="https://image.bdwms.com/FpFG1oXDRRgK4RsEdKjX8tTIzn8G"></p><p>没有OPKB的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DH1 &#x3D; DH(IKA, SPKB)</span><br><span class="line">DH2 &#x3D; DH(EKA, IKB)</span><br><span class="line">DH3 &#x3D; DH(EKA, SPKB)</span><br><span class="line">SK &#x3D; KDF(DH1 || DH2 || DH3)</span><br></pre></td></tr></table></figure><p>有OPKB的时候，多了个DH4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DH4 &#x3D; DH(EKA, OPKB)</span><br><span class="line">SK &#x3D; KDF(DH1 || DH2 || DH3 || DH4)</span><br></pre></td></tr></table></figure><p>其中DH1和DH2提供相互认证，DH3和DH4提供前向安全，后面我会解释。</p><p>之后Alice删除EKA的私钥和中间计算的DH值，并使用身份信息计算一个“associated data”即AD，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AD &#x3D; Encode(IKA) || Encode(IKB)</span><br></pre></td></tr></table></figure><p><img src="https://image.bdwms.com/FkpAO81vOvXytc1IBD3-_ligehZB"></p><p>随后Alice发送初始化消息，包含：</p><ul><li>Alice的身份密钥IKA</li><li>Alice的临时密钥EKA</li><li>Alice使用的Bob的被签名预密钥的标志号（如果使用了OPKB，那么还有OPKB的标志号）</li><li>一段初始化文本，AEAD模式加密，其中AD作为输入的associated data，使用SK（或HKDF函数拓展SK）作为加密的密钥</li></ul><p>Bob接受初始化消息后，就能得知Alice的身份密钥，EKA所代表的临时公钥，Alice使用的SPKB和OPKB，通过相同的方式计算出SK和AD（同样计算完后删除中间的DH值），然后解密初始化文本，如果解密成功，会删除一次性密钥的私钥，保证前向安全性。</p><p><img src="https://image.bdwms.com/FnqmNz5WOFDmV1ainf1IhqDazzng"></p><p>这样子最终Alice和Bob就持有了相同的SK或由HKDF函数拓展SK的新密钥。</p><h3 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h3><p>虽然上面阐述了一遍X3DH的过程，但是想必大部分人看完后都是一头雾水。这些参数的作用是什么，为什么这样设计计算过程，这样的交换是如何实现设计目标的等等，接下来我就会结合官方文档和自己的理解进行解释。</p><ol><li><p>DH1和DH2是如何完成相互认证的，DH3和DH4如何提供前向安全的？</p><p>Bob和Alice都会上传自己的身份密钥，通过两次DH计算，即Alice通过Pri_Alice和Pub_Bob(IKB)进行计算，Bob通过Pri_Bob和Pub_Alice(IKA)进行计算，就能确保对方的确持有相应的私钥。</p><p>DH3通过EKA和SPKB进行计算，因为EKA是每次临时生成的，并且其私钥会在计算出DH结果后丢弃，所以能提供前向安全性。同理OPKB也是只使用一次，并且在计算出结果后丢弃私钥，提供更强的前向安全性。</p></li><li><p>X3DH的可否认性？</p><p>首先说明可否性指的是通信双方即Alice和Bob无法向第三方例如Carol证明两者间曾进行过会话。形象点说Alice想要举报Bob，但是Alice不能够证明给法官Carol说Alice和Bob两人间曾经通过信，就算Alice展示两者的会话消息，Bob也可以否认说这是Alice自己伪造的。</p><p>为什么呢？首先Bob的身份密钥IKB和被签名预密钥SPKB都是公开的，任何人都可以获取，因此Alice可以自己单独计算出SK，并发送给Bob初始化消息，但是此时Bob是可以选择不计算出SK的，Alice并没有显示的证据（例如TLS中Server主动的数字签名下发给客户端），所以无法证明Bob持有同样的密钥。同样因为EKA在使用完后会丢弃私钥，Bob同样无法证明Alice是持有相同的SK密钥。综上X3DH的相互认证是不可向第三方证明的，具有可否认性。</p></li><li><p>存在中间人攻击？</p><p>我们通过上面的分析，会发现一个问题：Alice和Bob在进行相互认证的时候，Bob其实只是收到了一个身份密钥，就算它成功计算出相同的SK，那又怎么证明这个身份密钥确实是Alice的呢？可能存在一个中间人David截获了Alice和Bob的对话，并替换Alice的身份密钥IKA为自己的IKD，Bob只会知道它通信的对端的确持有IKD的私钥，而无法得知对端是否为Alice。</p><p>也就是说X3DH的相互认证只能说是一个身份的绑定，而不能确保通信对端的确是真正想通信的人，这也是上面<strong>可否认性带来的必然结果</strong>，在像TLS的协议中是存在一个可信第三方进行显示证明通信双方身份的，但X3DH是不存在这样的角色。因此为了解决这个问题，在Alice和Bob建立对话后会用带外通信的方式进行身份确认IKA和IKB，例如扫二维码，比较公钥指纹等手段来避免中间人攻击。</p></li><li><p>临时预密钥有什么作用，为什么它是可选的？</p><p>笼统的说是为了前向安全性。详细点说，当不存在OPKB的时候，Bob会长期持有IKB和一定时间内持有SPKB，当攻击者攻破Bob后能拿到IKB和SPKB，并通过观察网络流量记录拿到之前的EKA，这样攻击者就能解密之前的消息了，因此当没有OPKB的时候前向安全会下降。当然OPKB被消耗完时，EKA一般会经过TLS加密，还是能保证一定程度的前向安全的，所以OPKB也不是说必须有。</p></li><li><p>为什么需要SPKB呢，SPKB为什么一定需要被IKB签名呢？</p><p>当不存在SPKB的时候，只有OPKB，如果存在攻击者恶意DDOS发起会话，会迅速消耗OPKB，当消耗完后，就无法与B正常通信了（虽然可以通过服务端进行一些限频等手段防DDOS，但还是更应该从协议层来做一定的防范）。那么为什么SPKB需要被IKB签名呢，官方文档是这么解释的，虽然看起来省略签名的步骤会提高效率，但是可能服务器是恶意的，Alice发起通信后提供给Alice的是伪造的预密钥，然后服务器恶意泄漏B的IKB就可能可以计算出SK了，从而解析Alice想要发送的信息。</p></li></ol><p>以上就是我觉得官方文档中没有解释清楚的，还有几个问题例如重放攻击，密钥泄漏危害讲的比较清楚了，可以直接参考<a href="https://signal.org/docs/specifications/x3dh/">官方文档</a>。</p><h2 id="Signal之双棘轮"><a href="#Signal之双棘轮" class="headerlink" title="Signal之双棘轮"></a>Signal之双棘轮</h2><h3 id="设计目的-1"><a href="#设计目的-1" class="headerlink" title="设计目的"></a>设计目的</h3><p>对于X3DH，保证了一定的前向安全，但是还不足够，为了在真正意义上实现前向安全和后向安全，Signal协议设计了一个双棘轮（Double Ratchet），即用对称密钥棘轮棘轮（Symmetric-key ratchet）保证前向安全，DH棘轮保证后向安全。</p><h3 id="KDF链"><a href="#KDF链" class="headerlink" title="KDF链"></a>KDF链</h3><p>KDF链是保证前向安全的核心</p><p><img src="https://image.bdwms.com/FiJ3s3vnlHhYcuVbaMUm86m-2r0H"></p><p>两个输入一个为密钥，一个是输入材料，输出切分为两部分，一部分作为下一轮的输入密钥，一部分作为本轮输出key，这样子保证了足够的前向安全，弹性，入侵恢复（<a href="https://signal.org/docs/specifications/doubleratchet/#kdf-chains">参考文档</a>）。</p><h3 id="Symmetric-key棘轮"><a href="#Symmetric-key棘轮" class="headerlink" title="Symmetric-key棘轮"></a>Symmetric-key棘轮</h3><p><img src="https://image.bdwms.com/Fj5q6pnm-ekb5E-NyGI09UQ7LO6s"></p><p>每个消息都使用唯一的message key加密，message key从chain链中导出保证了前向安全，但是因为输入的是constant所以无法保证后向安全，如果攻击者拿到了chain key就可以计算出之后的message key。在双棘轮中会有三个链分别为Root Chain，Sending Chain和Receiving Chain。</p><h3 id="DH棘轮"><a href="#DH棘轮" class="headerlink" title="DH棘轮"></a>DH棘轮</h3><p>DH棘轮保证后向安全，因为每次都会重新计算DH密钥。Bob发送公钥至Alice，Alice使用Bob的公钥Pub_B和自己的私钥Pri_A计算出一个DH1，然后Alice发送自己的公钥Pub_A，Bob结合自己的私钥Pri_A计算出相同的DH1。之后Bob生成新的密钥对，发送自己新的公钥Pub_B2，重复上面的过程，这样每一次都会计算出一个新的DH结果，保证了中间某次密钥泄漏，不会影响后面的消息加解密，这就是DH棘轮。</p><p><img src="https://image.bdwms.com/Fk4VYjCBKmc4C-F9Ly_69GIgKOVv"></p><p>然后会利用一个来回生成两组发送和接受链。</p><p><img src="https://image.bdwms.com/FkFdHpvNC0MepPUWB-qJ0KjUHI41"></p><h3 id="双棘轮的组合"><a href="#双棘轮的组合" class="headerlink" title="双棘轮的组合"></a>双棘轮的组合</h3><p>综上，通过组合以上两个棘轮就保证了前向安全和后向安全，DH棘轮生成的DH作为Root Chain的输入，来产生Sending Chain和Receiving Chain。</p><p><img src="https://image.bdwms.com/FqSh4YL63VL3QsoY5yjCWrfJVM9L"></p><p>然后看下实际的交互情况，会从Root Chain导出Sending Chain和Receiving Chain，然后Sending Chain和Receiving Chain会生成每个消息单独的message key。</p><p><img src="https://image.bdwms.com/FguqVlzdQnO4gZZoi5Mcc09j3X7l"></p><h3 id="失序处理"><a href="#失序处理" class="headerlink" title="失序处理"></a>失序处理</h3><p>当消息乱序发送时，会在消息头中维护消息序列和上一个链的长度，然后失序到达时保存未到的消息的对应的message key，例如下面B4到了B2和B3没到，头信息为N=1,Pn=2，所以可以推算出哪些没到，并保存这些消息的对应密钥。</p><p><img src="https://image.bdwms.com/FvTSBrq41uZsyEA6ykg3YSsy5P5A"></p><h3 id="X3DH结合双棘轮"><a href="#X3DH结合双棘轮" class="headerlink" title="X3DH结合双棘轮"></a>X3DH结合双棘轮</h3><p>X3DH商量的SK作为Root key，协商出的AD作为棘轮加密时用的AD，Bob的Prekey作为Bob初始棘轮公钥。X3DH的主要任务就是为了生成这个root chain的key。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上的描述我们大致了解了Signal协议是如何做到端到端加密的，真正意义上解决了第三者插入会话的问题，并且提供了可否认性，加强了前后向安全与对抗密钥泄漏。但是对于还有很多问题没有回答，比如如何做到多设备管理（Sesame），如何进行群组会话支持端到端加密（参考WhatsApp白皮书），如何做到多服务器负载均衡下的通信。同时我们要知道，就算在协议设计上没有问题，但是可能因为攻击者直接攻破接管了客户端等等类似的问题，影响到端到端通信之间的安全，所以要铭记一点：没有绝对的安全，我们只能尽量接近安全。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://faq.whatsapp.com/general/security-and-privacy/end-to-end-encryption/?lang=en">WhatsApp E2EE</a></p></li><li><p><a href="https://faq.whatsapp.com/general/security-and-privacy/end-to-end-encryption/?lang=en">WhatsApp白皮书翻译</a></p></li><li><p><a href="https://signal.org/docs/specifications/x3dh/">X3DH官方文档</a></p></li><li><p><a href="https://signal.org/docs/specifications/doubleratchet/">双棘轮官方文档</a></p></li><li><p><a href="https://blog.csdn.net/qmickecs/article/details/76585303">离散对数和椭圆曲线加密原理</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从TLS看安全协议设计（下）</title>
      <link href="TLS-design-part-two/"/>
      <url>TLS-design-part-two/</url>
      
        <content type="html"><![CDATA[<p>TLS1.3作为升级的版本，根据需求主要是在两个方面做了整改，一个是安全方面，一个就是性能，下面我们就来看一下。</p><h2 id="升级之处"><a href="#升级之处" class="headerlink" title="升级之处"></a>升级之处</h2><p>安全：</p><ul><li>删除了不安全的密码组件，例如MD5。</li><li>为了前向安全性，密钥协商过程不再使用RSA和静态DH，ECDH，只选用DHE或者ECDHE。</li><li>设计了新的密钥派生函数HKDF代替了PRF函数。</li><li>记录层进行加密和MAC时固定为AEAD模式。</li></ul><p>性能：</p><ul><li>重新设计了握手层流程，让冷启动从2RTT变化1RTT。</li><li>设计了PSK会话恢复机制代替了原来的Session会话恢复机制。</li><li>0-RTT</li></ul><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>对于TLS1.3的流程如下，最主要分为两种方式，一种是基于key_share和signature_algorithms来选择加密的算法，另一种是基于预共享密钥PSK的会话恢复。</p><h3 id="握手层冷启动"><a href="#握手层冷启动" class="headerlink" title="握手层冷启动"></a>握手层冷启动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Key  ^ ClientHello</span><br><span class="line">Exch | + key_share*</span><br><span class="line">     | + signature_algorithms*</span><br><span class="line">     | + psk_key_exchange_modes*</span><br><span class="line">     v + pre_shared_key*       --------&gt;</span><br><span class="line">                                                  ServerHello  ^ Key</span><br><span class="line">                                                 + key_share*  | Exch</span><br><span class="line">                                            + pre_shared_key*  v</span><br><span class="line">                                        &#123;EncryptedExtensions&#125;  ^  Server</span><br><span class="line">                                        &#123;CertificateRequest*&#125;  v  Params</span><br><span class="line">                                               &#123;Certificate*&#125;  ^</span><br><span class="line">                                         &#123;CertificateVerify*&#125;  | Auth</span><br><span class="line">                                                   &#123;Finished&#125;  v</span><br><span class="line">                               &lt;--------  [Application Data*]</span><br><span class="line">     ^ &#123;Certificate*&#125;</span><br><span class="line">Auth | &#123;CertificateVerify*&#125;</span><br><span class="line">     v &#123;Finished&#125;              --------&gt;</span><br><span class="line">                                                     &lt;--------  [NewSessionTicket]</span><br><span class="line">       [Application Data]      &lt;-------&gt;  [Application Data]</span><br></pre></td></tr></table></figure><p>我们首先来看第一种</p><ol><li>客户端发送ClinetHello，在key_share和signature_algorithms中声明自己支持的DHE或者ECDHE算法类型对应的具体参数。</li><li>服务端返回ServerHello，选择自己支持的算法和自己的参数。</li><li>服务端发送EncryptedExtensions，包含不需要建立加密上下文并且和证书无关的拓展。注意从本条消息开始都会被加密传输。</li><li>如果想要验证客户端认证，服务端就会发送CertificateRequest消息。</li><li>服务端发送Certificate消息，包含自己的证书。</li><li>服务端发送CertificateVerify消息。对之前握手的消息做Hash后用证书私钥进行签名，进行显示认证表明自己持有证书私钥。</li><li>服务端发送Finished消息对之前握手消息做校验，以及验证协商密钥的正确性。</li><li>此时服务端已经可以发送加密的应用数据了。</li><li>如果需要客户端验证，就会发送客户端Certificate消息。</li><li>如果客户端发送了Certificate消息，就会发送CertificateVerify来表明客户端持有证书私钥。</li><li>客户端同样发送Finished消息，进行校验。</li><li>客户端可以发送加密的应用消息。</li></ol><p>我们观察整个流程，冷启动仅需要1-RTT。因为在ClientHello时已经携带了DHE（ECDHE）的参数，让第一次握手有更多的作用。这也是因为在密钥协商时抛弃了RSA算法，因为对于RSA需要服务端先下发公钥，所以需要至少2-RTT。</p><h3 id="握手层热启动"><a href="#握手层热启动" class="headerlink" title="握手层热启动"></a>握手层热启动</h3><p>我们再看一下会话恢复的情况。对于1.3使用的是PSK机制，其中PSK可以从上次握手时生成，或者由使用者预置。</p><p>看一下流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ClientHello</span><br><span class="line">    + key_share*</span><br><span class="line">    + pre_shared_key          --------&gt;</span><br><span class="line">                                                    ServerHello</span><br><span class="line">                                               + pre_shared_key</span><br><span class="line">                                                   + key_share*</span><br><span class="line">                                          &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                     &#123;Finished&#125;</span><br><span class="line">                              &lt;--------     [Application Data*]</span><br><span class="line">    &#123;Finished&#125;                --------&gt;</span><br><span class="line">    [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line">    +表示携带的参数，*表示可选</span><br></pre></td></tr></table></figure><p>客户端携带PSK发送给服务端，服务端如果接受就返回ServerHello，以及加密的EncryptedExtensions，Finished消息。之后两者就能进行应用数据传输，整个流程需要一个1-RTT。</p><h3 id="记录层"><a href="#记录层" class="headerlink" title="记录层"></a>记录层</h3><p>流程为数据分段，填充（为了隐藏流量），加密和完整性保护（AEAD），添加消息头。</p><p>与1.2最主要的不同就是抛弃的块模式和流模式，固定为AEAD，并对AEAD做了一些调整，这里就不展开说了。</p><h2 id="变化分析"><a href="#变化分析" class="headerlink" title="变化分析"></a>变化分析</h2><h3 id="HKDF密钥派生函数"><a href="#HKDF密钥派生函数" class="headerlink" title="HKDF密钥派生函数"></a>HKDF密钥派生函数</h3><p>1.3重新设计了密钥派生函数，对于HKDF函数分为Extract和Expand过程，Extract过程增加密钥材料的随机性,Expand进行拓展，在1.2中PRF函数只有Expand的过程，它默认密钥材料的随机性是足够的，然而这是不一定的可能ECC协商出来的随机分布是不够均匀的。</p><p>Extract过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Extract(salt, IKM) -&gt; PRK</span><br><span class="line">salt盐可选，没有时用<span class="number">0</span>填充HashLen长度</span><br><span class="line">IKM：Input Keying Material</span><br><span class="line">PRK: 生成的伪随机key</span><br><span class="line"></span><br><span class="line">PRK = HMAC-Hash(salt, IKM)      </span><br></pre></td></tr></table></figure><p>Expand过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Expand(PRK, info, L) -&gt; OKM</span><br><span class="line">PRK伪随机key</span><br><span class="line">info可选一般标志上下文信息</span><br><span class="line">L期望输出的字节数</span><br><span class="line"></span><br><span class="line"> OKM生成方式：</span><br><span class="line"> N = <span class="built_in">ceil</span>(L/HashLen)</span><br><span class="line"> T = T(<span class="number">1</span>) | T(<span class="number">2</span>) | T(<span class="number">3</span>) | ... | T(N)</span><br><span class="line"> OKM = first L octets of T</span><br><span class="line"></span><br><span class="line"> where:</span><br><span class="line"> T(<span class="number">0</span>) = empty <span class="built_in">string</span> (zero length)</span><br><span class="line"> T(<span class="number">1</span>) = HMAC-Hash(PRK, T(<span class="number">0</span>) | info | <span class="number">0x01</span>)</span><br><span class="line"> T(<span class="number">2</span>) = HMAC-Hash(PRK, T(<span class="number">1</span>) | info | <span class="number">0x02</span>)</span><br><span class="line"> T(<span class="number">3</span>) = HMAC-Hash(PRK, T(<span class="number">2</span>) | info | <span class="number">0x03</span>)</span><br><span class="line"> ...   </span><br></pre></td></tr></table></figure><p>以及最终使用的Derive-Secret函数与Expand所对应的关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Expand-Label(Secret, Label, Context, Length) =</span><br><span class="line">            HKDF-Expand(Secret, HkdfLabel, Length)</span><br><span class="line"></span><br><span class="line">Where HkdfLabel is specified as:</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">  uint16 length = Length;</span><br><span class="line">  opaque label&lt;<span class="number">7.</span><span class="number">.255</span>&gt; = <span class="string">&quot;tls13 &quot;</span> + Label;</span><br><span class="line">  opaque context&lt;<span class="number">0.</span><span class="number">.255</span>&gt; = Context;</span><br><span class="line">&#125; HkdfLabel;</span><br><span class="line"></span><br><span class="line">Derive-Secret(Secret, Label, Messages) =</span><br><span class="line">  HKDF-Expand-Label(Secret, Label,</span><br><span class="line">       Transcript-Hash(Messages), Hash.length)</span><br><span class="line">  </span><br><span class="line">Transcript-Hash级联握手消息做Hash运算</span><br></pre></td></tr></table></figure><h3 id="密钥变化"><a href="#密钥变化" class="headerlink" title="密钥变化"></a>密钥变化</h3><p>1.3对于密钥做了更加详细的分类，在每一个使用部分的密钥实际上都是不同的，都会通过HKDF函数做变化，这也是密码学上的安全要求，一个密钥只使用在一种功能上。</p><p>一次握手的密钥变化如下，很复杂，可以只大概了解下有什么密钥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">0</span></span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line">PSK -&gt;  HKDF-Extract = Early Secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;ext binder&quot;</span> | <span class="string">&quot;res binder&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">          |                     = binder_key</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;c e traffic&quot;</span>, ClientHello)</span><br><span class="line">          |                     = client_early_traffic_secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;e exp master&quot;</span>, ClientHello)</span><br><span class="line">          |                     = early_exporter_master_secret</span><br><span class="line">          v</span><br><span class="line">    Derive-Secret(., <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line">(EC)DHE -&gt; HKDF-Extract = Handshake Secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;c hs traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...ServerHello)</span><br><span class="line">          |                     = client_handshake_traffic_secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;s hs traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...ServerHello)</span><br><span class="line">          |                     = server_handshake_traffic_secret</span><br><span class="line">          v</span><br><span class="line">    Derive-Secret(., <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line"><span class="number">0</span> -&gt; HKDF-Extract = Master Secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;c ap traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...server Finished)</span><br><span class="line">          |                     = client_application_traffic_secret_0</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;s ap traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...server Finished)</span><br><span class="line">          |                     = server_application_traffic_secret_0</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;exp master&quot;</span>,</span><br><span class="line">          |                     ClientHello...server Finished)</span><br><span class="line">          |                     = exporter_master_secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;res master&quot;</span>,</span><br><span class="line">                                ClientHello...client Finished)</span><br><span class="line">                                = resumption_master_secret</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ol><li>HKDF-Extract 画在图上，它为从顶部获取 Salt 参数，从左侧获取 IKM 参数，它的输出是底部，和右侧输出的名称。</li><li>Derive-Secret 的 Secret 参数由传入的箭头指示。例如，Early Secret 是生成 client_early_traffic_secret 的 Secret。</li><li>“0” 表示将 Hash.length 字节的字符串设置为零。</li></ol><p>其中有三个Secret，是从Extract中得来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Early Secret = HKDF-Extract(salt, IKM) = HKDF-Extract(<span class="number">0</span>, PSK) (有PSK的情况)= HKDF-Extract(<span class="number">0</span>,<span class="number">0</span>) （没有PSK的情况）</span><br><span class="line">                                          </span><br><span class="line">Handshake Secret = HKDF-Extract(salt, IKM) = HKDF-Extract(Derive-Secret(Early Secret, <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>), (EC)DHE)</span><br><span class="line"></span><br><span class="line">Master Secret = HKDF-Extract(salt, IKM) = HKDF-Extract(Derive-Secret(Handshake Secret, <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>八个可能用到的密钥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client_early_traffic_secret = Derive-Secret(Early Secret, <span class="string">&quot;c e traffic&quot;</span>, ClientHello)</span><br><span class="line">early_exporter_master_secret = Derive-Secret(Early Secret, <span class="string">&quot;e exp master&quot;</span>, ClientHello)</span><br><span class="line"></span><br><span class="line">client_handshake_traffic_secret = Derive-Secret(Handshake Secret, <span class="string">&quot;c hs traffic&quot;</span>, ClientHello...ServerHello)</span><br><span class="line">server_handshake_traffic_secret = Derive-Secret(Handshake Secret, <span class="string">&quot;s hs traffic&quot;</span>, ClientHello...ServerHello)</span><br><span class="line"></span><br><span class="line">client_application_traffic_secret_0 = Derive-Secret(Master Secret, <span class="string">&quot;c ap traffic&quot;</span>, ClientHello...server Finished)</span><br><span class="line">server_application_traffic_secret_0 = Derive-Secret(Master Secret, <span class="string">&quot;s ap traffic&quot;</span>, ClientHello...server Finished)</span><br><span class="line"></span><br><span class="line">exporter_master_secret = Derive-Secret(Master Secret, <span class="string">&quot;exp master&quot;</span>, ClientHello...server Finished)</span><br><span class="line">resumption_master_secret = Derive-Secret(Master Secret, <span class="string">&quot;res master&quot;</span>, ClientHello...client Finished)</span><br></pre></td></tr></table></figure><ol><li>early_exporter_master_secret和exporter_master_secre导出密钥，用户可以自定义使用方式。</li><li>resumption_master_secret用于会话恢复。</li><li>client_early_traffic_secret用于加密early_data，在0-RTT模式中使用。</li><li>client_handshake_traffic_secret和server_handshake_traffic_secret用于握手时的加密。</li><li>client_application_traffic_secret_0和server_application_traffic_secret_0用于加密应用流量数据。</li></ol><p>3，4，5的密钥想要加密数据还需要一次Expand过程生成write_key和iv来作为真正加密数据的密钥，生成方式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sender]_write_key = HKDF-Expand-Label(Secret, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;&quot;</span>, key_length)</span><br><span class="line">[sender]_write_iv  = HKDF-Expand-Label(Secret, <span class="string">&quot;iv&quot;</span>, <span class="string">&quot;&quot;</span>, iv_length)</span><br></pre></td></tr></table></figure><h3 id="PSK会话恢复机制"><a href="#PSK会话恢复机制" class="headerlink" title="PSK会话恢复机制"></a>PSK会话恢复机制</h3><p>1.3中使用PSK机制代替了Session机制，那么PSK是如何生成并使用的？</p><p>先看下Server发送的NewSessionTicket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">          uint32 ticket_lifetime;</span><br><span class="line">          uint32 ticket_age_add;</span><br><span class="line">          opaque ticket_nonce&lt;<span class="number">0.</span><span class="number">.255</span>&gt;;</span><br><span class="line">          opaque ticket&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">          Extension extensions&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-2</span>&gt;;</span><br><span class="line">      &#125; NewSessionTicket;</span><br></pre></td></tr></table></figure><p>其中ticket的值是从上一节提到的resumptition_master_secret中计算出来的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PskIdentity.identity = ticket </span><br><span class="line">                          = HKDF-Expand-Label(resumption_master_secret, <span class="string">&quot;resumption&quot;</span>, ticket_nonce, Hash.length)</span><br></pre></td></tr></table></figure><p>客户端接受到NewSessionTicket后会计算一个binder值，Truncate会取出ClientHello1中的binder_list，避免陷入无限循环。利用这个值来绑定上下文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PskBinderEntry = HMAC(binder_key, Transcript-Hash(Truncate(ClientHello1)))</span><br><span class="line">                   = HMAC(Derive-Secret(HKDF-Extract(<span class="number">0</span>, PSK), <span class="string">&quot;ext binder&quot;</span> | <span class="string">&quot;res binder&quot;</span>, <span class="string">&quot;&quot;</span>), Transcript-Hash(Truncate(ClientHello1)))</span><br><span class="line"></span><br><span class="line">其中binder_key = Derive-Secret(HKDF-Extract(<span class="number">0</span>, PSK), <span class="string">&quot;ext binder&quot;</span> | <span class="string">&quot;res binder&quot;</span>, <span class="string">&quot;&quot;</span>)                   </span><br></pre></td></tr></table></figure><p>然后Client在会话恢复时将identity和binder包含在ClientHello的拓展中发送给Server，Server再验证binder的完整性，比对identity，选择是否接受PSK，从而生成新的handshake_traffic和application密钥进行会话恢复。</p><p>可以看到如果仅仅是这样的会话恢复，相对于1.2来说只是更安全（因为不再使用master_secret做传递，而是利用HKDF派生），性能上没有大的提升，所以就会涉及到下面的0-RTT。</p><h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h3><p>对于TLS1.3还有一个很大的变化，那就是0-RTT模式。什么是0-RTT呢，就是基于PSK会话恢复时，PSK会作为Early Secret的IKM，然后从Early Secret生成client_early_traffic_secret，再由client_early_traffic_secret生成key和iv用来加密0-RTT发送的early_data。Client在ClientHello中携带early_data拓展选项，并发送由client_early_traffic_secret加密的数据，如果服务端接受early_data，那么就成功完成了0-RTT传输。</p><p>但是0-RTT为了效率降低了安全性，存在重放问题，因为在客户端发送early_data时，只有客户端参数决定，服务端没有参与到其中，那么中间人就可以截获这个ClientHello包以及加密数据，而服务端每次都能成功解析这个包，中间人就可以进行重放ddos或者重复敏感操作。除了这种最简单的重放，还有针对分布式系统的重放攻击，这里就不展开说了。</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>通过上面的分析，我们可以看出TLS具有极强的通用性与可拓展性，但是针对一些具体的使用场景能否进行特殊化的改造，这里我们以微信mmtls作为例子来分析下。我们回顾TLS的过程，身份认证的过程是采用建立PKI体系，做到全球的通用性，但是针对完全可控的微信程序，可以直接将签名的公钥预埋在客户端中，这样就不用建立或者申请证书，通过强制更新客户端，来做公钥的维护，这样就很大程度简略的流程并提升了效率。</p><p>还有针对0-RTT的问题，对于TLS1.3本身协议上来说是无解的，更多的只能从应用层来做缓解，例如cloudflare针对0-RTT将禁止非幂等的操作像POST，PUT，只允许不带参数的GET请求。mmtls也是根据这些应用行为，有选择性的使用0-RTT模式，例如只在端连接使用。chrome甚至选择不解决0-RTT重放，因为大部分浏览器的操作都是GET先，安全性交由其他方面来做。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个TLS完成了密码学上的安全，并结合了软件工程的理念，做到了分层抽象，模块化等等优秀的设计，在通用性上也确保了更多的场景能够被覆盖，提升了互联网的安全性，基本完成了它的设计目标。</p><p>当然作为使用者，当我们自己在设计（魔改）安全协议的时候，依然需要小心谨慎，密码学的快速发展已经让大部分程序员很难理解其原理，甚至正确使用密码学黑盒工具也是困难的，所以我们更需要的是怀着严谨的态度去使用密码学工具，紧跟主流，避免陷入闭门造车的困境。还有根据本身的应用场景我们是否能够吸取TLS的精华，结合自己的业务需求去做特质化，省略一些臃肿的包袱，做到定制优化都是可以考虑的。</p><p>TLS中的奥义远远不止我所阐述的，短短两篇文章也不能尽善尽美地描绘，希望能够对每一个读者有所帮助，更加有条理地理解其奥义。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tools.ietf.org/html/rfc5246">TLS1.2 RFC</a></li><li><a href="https://halfrost.com/">冰霜之地</a></li><li><a href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/">TLS协议分析 与 现代加密通信协议设计</a></li><li><a href="https://blog.shell909090.org/blog/archives/2873/">安全协议的设计</a></li><li><a href="https://cloud.tencent.com/developer/article/1005518">微信mmtls</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从TLS看安全协议设计（上）</title>
      <link href="TLS-design-part-one/"/>
      <url>TLS-design-part-one/</url>
      
        <content type="html"><![CDATA[<p>在开始正文前，我想先谈谈为什么要写这篇文章，为什么要对TLS协议进行分析？</p><p>打开网站时我们经常能看到左上角的小绿锁，而TLS正是隐藏在后面的原由。对于大部分程序员，多多少少都可以聊一聊TLS的几分样貌，但是能真正的从其整体发散到细节，从理念落地到实践，以更高的角度去理解TLS是很少的。因此这里想要从我个人的角度，去理清TLS，解读这个将密码科学和软件工程良好结合的优秀设计，也希望能够给读者有所帮助。</p><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><h3 id="为什么需要TLS"><a href="#为什么需要TLS" class="headerlink" title="为什么需要TLS?"></a>为什么需要TLS?</h3><p>在不存在SSL/TLS的互联网中，消息通过例如HTTP明文传递，作为一个攻击者可以截获任意的包，那么他就可以获取报文中的信息，并对报文进行修改，伪装成对端进行窃听或者控制传输。</p><p>在上文的描述中，我们可以看出明文传输存在的最显著问题：数据没有加密，消息易被篡改，身份能被伪造。这也对应着信息安全中的<strong>机密性</strong>，<strong>完整性</strong>，<strong>身份认证</strong>。</p><p>除了这三个最明显的问题，还有其他很多待解决的问题，例如如何确保用户不能抵赖之前发送的消息，即<strong>不可否认性</strong>；如何在设计时，降低所需的传输时间，提升<strong>性能</strong>；如何做到协议的<strong>通用性</strong>和<strong>可拓展性</strong>。这一系列的问题缺乏一个统一的解决方案，很多情况下仅是通过应用层的一些手段去不完善的处理，这些需求也就促成了SSL/TLS的诞生与发展。</p><p>围绕着这些需求，从90年代SSL1.0设计之初，一直走到了08年TLS1.2版本正式发布，整个协议才趋于成熟，又伴随着安全研究的升级对抗以及对性能提升的要求，1.3版本也在几年的商讨中于18年诞生。而这几年业界也是逐渐从1.2版本向1.3升级。当然因为历史遗留原因目前主流的还是1.2版本，因此我的分析也将从1.2版本开始，再迈向1.3，为读者浅析TLS的前世今生。</p><p><img src="https://image.bdwms.com/FvB5KJRP8BMLJtatrdl8yHLHZFKZ"></p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>在阅读这一部分时，可以不先完全理解其细节，在浏览后面章节必要时，再返回本章进行对照理解。</p><p>因为TLS是建立在密码学之上的协议，想要将TLS理解清楚，对密码学应有一定了解，但是具体深入密码学的细节不是本文重点所在，所以我简单归纳了几个需要了解的点和一些特性，实现细节的话请参看所给资料链接或自行搜索。</p><h3 id="密码学基本工具"><a href="#密码学基本工具" class="headerlink" title="密码学基本工具"></a>密码学基本工具</h3><ul><li>对称加密：加密和解密时使用同一密钥，常用有AES，(DES,RC4等都被证明不安全了)，然后还涉及到加密模式，例如流式加密（RC4使用的就是流式）,块加密模式（CBC等模式）。<strong>加解密效率高，密钥配送管理不便</strong>。</li><li>非对称加密：公私钥体系。常见的有RSA（基于大整数的质因数分解难题）和ECC（基于椭圆曲线上的离散对数难题）,以及DH（基于有限域上的离散对数难题），后两者在使用过程中类似一个协商，而RSA更类似一个单方面的加密传输过程。<strong>加解密效率低，密钥派发管理方便</strong>。</li><li>单向散列函数：输入消息不同，输出Hash值不同，保证消息的<strong>一致性</strong>，<strong>完整性</strong>。</li><li>消息认证码MAC：比单项散列函数多了个共享秘钥，保证消息的<strong>一致性</strong>，<strong>完整性</strong>，并且通过密钥加解密确保<strong>身份认证</strong>。但是因为使用的是共享秘钥不能“第三方证明”和“防抵赖”。</li><li>数字签名：利用私钥对hash值签名，公钥认证。保证消息的<strong>一致性</strong>，<strong>完整性</strong>，<strong>认证</strong>，并且能<strong>防止抵赖</strong>。</li><li>伪随机数生成器：模拟产生随机数列的算法。</li></ul><p>以上就是常用的密码学工具，在接下来的流程中会分别涉及到，如果对相关的工具有困惑可以自行查阅资料。</p><h3 id="RSA-ECC-DH"><a href="#RSA-ECC-DH" class="headerlink" title="RSA ECC DH"></a>RSA ECC DH</h3><p>这里想要对最常用的非对称加密算法做个简单的介绍，因为后面讲解时会利用到其特性。</p><p>对于常用的非对称加密算法，可以简单的分为两种类型，一种是基于RSA，一种是类DH（包括原生的DH和基于ECC的DH，即ECDH），简单来看一下两者的使用和区别。</p><ul><li><p>RSA</p><p>基于大整数进行质因数分解的困难，具体原理可以看阮一峰的<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">《RSA算法原理》</a>，这里说下使用方法：</p><p>存在一对公私钥：公钥(E,N)，私钥(D,N)，明文加密和密文解密类似下列的运算</p><p>密文 = 明文^E mod N   </p><p>明文 = 密文^D mod N  </p><p>使用的过程类似：</p><p>服务端下发公钥给客户端，客户端利用公钥加密一段会话数据后返回给服务端，服务端利用自己的私钥进行解密。</p><p><img src="https://image.bdwms.com/FgWFJLCGyoonFMeoZxHodhv6io3d"></p></li><li><p>DH（ECDH）</p><p>分为两种，一种是基于有限域上的离散对数问题，即DH类（Diffie-Hellman），具体原理自行搜索，这里只做口语化表达：</p><p><strong>已知x和G，求G^x mod p是简单的；反过来已知G^x mod p和G，求x是困难的。</strong></p><p>第二种是基于椭圆曲线上的离散对数问题，即ECDH类，口语化表达类似：</p><p><strong>已知x和G，求xG是简单的（椭圆曲线上的运算，不是简单的数乘）；反过来已知xG和G，求x是困难的。</strong></p><p>所以一般我们把x作为私钥，xG（G^x）为公钥</p><p>使用的过程类似：</p><p>服务端拥有私钥a，客户端拥有私钥b，第一次服务端发送公钥aG和参数G，客户端接受到后计算bG，发送给服务端，此时客户端拥有aG和b，服务端拥有bG和a，双方经过计算a(bG)=b(aG)=abG，得出相同的会话数据，但此时中间人只能截获aG，bG和G，无法求出abG，因为想要求出的话记必须通过aG和G（bG和G）计算出a（b），但是从上文的条件可以看出这是困难的，由此这就是DH类的原理。</p><p><img src="https://image.bdwms.com/FpcwsX8mQoxRoZVp1cPJ5bMnpTFv"></p></li></ul><p>我们通过以上的简介不难发现一点，两类算法最大的区别就是RSA做加密传输的时候，整个的会话数据是由客户端决定的，而服务端没有参与到生成的过程，更类似于一个<strong>加密传输</strong>的过程。而DH类客户端和服务端双方都需要参与到生成的过程中，单方面是无法决定会话数据的，也就是说相较于RSA，DH（ECDH）更类似一个<strong>密钥协商</strong>的过程。</p><p>针对上面的特性，也就衍生出下一个需要关注问题——前向安全，这也是为什么TLS1.3会抛弃RSA作为密钥协商的算法。</p><h3 id="前向安全"><a href="#前向安全" class="headerlink" title="前向安全"></a>前向安全</h3><p>官方定义是：长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。简单点来说就是我的长期持有的私钥泄漏了不会对之前的会话消息造成影响，那么对于上述两种算法，其又有什么不同呢？</p><p>显然，对于RSA来说，如果我们一直使用同一对公私钥，当私钥泄漏时，攻击者就可以轻易解密之前的会话消息，也就是说RSA时不具有前向安全的。不可能每次会话都更新RSA公私钥，因为每次更新下发公钥是不现实的，效率太低了，不可接受。</p><p>对于DH（ECDH），如果双方每次通话的私钥a，b都是固定的，那么生成的abG也是固定的，如果泄漏，也无法保证前向安全。但是我们可以通过每次会话时都利用随机数发生器生成临时的a和b（这个效率是可接受的），这样每次计算出来的结果都不一样，这就保证了前向安全，这也就是DHE和ECDHE，其中E表示的就是临时的意思。</p><p>基于上述拥有的密码学工具，以及相应的设计目的和需求，我们应该怎么设计呢，假如你是一个协议开发者，你如何协调使用好所拥有的能力，完成一个精巧的架构呢？让我们先来看看TLS是如何操作的，由全局到细节，由问题推方法，我们来细细品味。</p><h2 id="协议架构"><a href="#协议架构" class="headerlink" title="协议架构"></a>协议架构</h2><p>TLS1.2主要分为两个层级，上层的握手层（以及一些辅助协议，例如密钥切换通知，告警协议）和下层的记录层。</p><p><img src="https://image.bdwms.com/FrxN1tlsNbsfyfNbH4sQ9fZgAGwx"></p><p>首先为什么TLS会设计成分层架构呢？最主要的原因就是公钥加密算法和对称加密算法的优劣性。当使用对称密钥的方式进行加密时，双方持有相同密钥，根据选定算法对信息加密，然后传输给对端进行解密。整个加解密的过程建立在双方持有相同的密钥，但是对于互联网多方交互的环境下，是不可能做到服务端与每个客户端直接持有一个对称密钥的，无论是维护密钥的成本，还是密钥派发时的安全保证，都是不可接受的。</p><p>因此为了解决密钥的派发管理问题，一般是采用公钥加密的方式，服务端将公钥派发出去，客户端利用公钥加密信息后返回给服务端，服务端再用自己的私钥进行解密。但是在真正设计时并没有选择完全使用两端采用公钥加密的方式进行加密沟通，因为公钥加解密的速度是非常慢的。</p><p>综合以上两点，TLS分为两层，握手层采用公钥加密的方式协商一段数据作为加密素材，传递给记录层做为对称加密的密钥材料，记录层生成对称密钥加密应用数据，既解决了密钥管理的问题，也保证了效率。同时这也有利于解耦各种需求，并化简整个问题的复杂度，将TLS分层模块化，每一部分完成一定的需求，并让之后的升级更新更加方便。</p><h2 id="推演思路"><a href="#推演思路" class="headerlink" title="推演思路"></a>推演思路</h2><p>了解了TLS最基本的架构后我们按照握手层和记录层的顺序进行推理分析，由需求得出方案，再根据连贯的问题，补充完善之前的方案。</p><h3 id="握手层"><a href="#握手层" class="headerlink" title="握手层"></a>握手层</h3><p>先从握手从来看，对于握手层，需要完成的最基本需求是利用非对称加密完成“材料”数据的传输，如客户端C向服务端S发送会话请求，服务端同意后下发自己的公钥S_Pub，客户端利用公钥加密数据Data传输给服务端，服务端利用自己的私钥S_Pri解密，得到数据。</p><p>但是以上步骤存在一个问题就是假设存在一个可以截取数据的中间人，是无法保证对端身份可信的。例如下图中间人M截获S_Pub，替换为自己的公钥M_Pub，客户端使用M_Pub作为公钥加密后发送数据，中间人能用自己的M_Pri解密并修改数据，再用S_Pub加密后发送给服务端，从而造成中间人攻击。</p><p><img src="https://image.bdwms.com/FvHsGjuxiuWLnIXz04eK4pLkoOm4"></p><p>之所以产生这个问题是因为缺乏身份认证，解决身份认证问题一般是利用消息认证码MAC或数字签名。对于消息认证码需要对称密钥，此时还不存在所以选用数字签名进行认证。假设数字签名的公私钥对位Sign_Pub和Sign_Pri，利用Sign_Pri对S_Pub进行数字签名，客户端利用Sign_Pub对数字签名进行认证（中间人是无法阻止客户端获取到Sign_Pub的）。</p><p>但是又如何确保数字签名的公钥是可信的呢？TLS给出的方案就是PKI证书体系，建立可信第三方CA，然后在客户端预装可信CA的公钥（存在一个证书链体系，不是只有一个CA）。服务端通过下发证书，客户端通过预装公钥验证证书签名以及一些其他信息，确认了服务端身份，这样就能解决身份认证的问题并且保证了服务器公钥的完整性。TLS还支持双向认证，即服务端请求验证客户端身份，但一般只需要验证一方就可以解决中间人问题了。</p><p>记录层会通过握手层传输过来的数据Data生成用于加密应用数据的对称密钥，在此之前为了保证刚刚握手的完整性，还需要做消息校验并用协商生成的对称密钥加密，作为双方第一个对称加密的包。通过这个消息就能验证协商出的对称密钥是否正确，以及之前握手消息没有被篡改。之后记录层就可以正式加密传输应用数据了。</p><p>完成这样一次会话过程后，我们还需要思考一个问题：每次会话都需要重新生成新的密钥，这样是否很浪费，我们是否能复用之前的密钥。由此TLS产生了会话恢复机制，包括使用Session_id和Session_ticket两种手段。</p><p>以上就是从我个人理解的角度，观察TLS握手层一步一步的设计缘由，当然这其中隐藏了很多具体的实现细节，比如每一步的密钥是如何生成的，应该如何使用，如何减少私钥泄漏后的影响，为什么会话恢复有两种模式等等很多有意思的问题，在接下的分析中我会挑选一些我认为比较重要的进行解析。</p><p>总结下以上步骤，整体思路如下图：</p><p><img src="https://image.bdwms.com/FgkGgBr3d1jnp_3ycicaEH7BkSCB"></p><h3 id="记录层"><a href="#记录层" class="headerlink" title="记录层"></a>记录层</h3><p>对于记录层步骤主要为分段，压缩（可选，因为存在安全问题一般不开启），加密和消息认证MAC（存在三种模式，stream ,block,aead）,添加消息头。在这一层会利用握手层传输的密钥材料，生成对称密钥，MAC密钥等必备参数。完成对数据的对称加密和生成消息认证码（AEAD模式将两者结合起来了），这就是这一层做的最主要的事情。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="握手层冷启动"><a href="#握手层冷启动" class="headerlink" title="握手层冷启动"></a>握手层冷启动</h3><p>通过上面的推演，我们大致了解了每一层的目的以及大致的步骤，这里我们来看一下具体的实现。</p><p>对于第一次冷启动的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello                  --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                               Certificate*</span><br><span class="line">                                         ServerKeyExchange*</span><br><span class="line">                                        CertificateRequest*</span><br><span class="line">                             &lt;--------      ServerHelloDone</span><br><span class="line">Certificate*</span><br><span class="line">ClientKeyExchange</span><br><span class="line">CertificateVerify*</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                     --------&gt;</span><br><span class="line">                                         [ChangeCipherSpec]</span><br><span class="line">                             &lt;--------             Finished</span><br><span class="line">Application Data             &lt;-------&gt;     Application Data</span><br><span class="line">*表示可选发送</span><br><span class="line">[]表示独立消息，这里为了防阻塞单独通知密钥协议已切换，有冗余在<span class="number">1.3</span>中删除</span><br></pre></td></tr></table></figure><ol><li>客户端发送ClientHello携带自己支持的加密组件以及随机值，服务端收到后选择支持的加密组件并携带服务端随机值返回一个ServerHello消息。</li><li>之后服务端发送Certifacate消息，包含证书信息，以及当Certificate信息不足时，发送ServerKeyExchange消息包含补充信息。</li><li>因为TLS支持双向认证，如果服务端需要对客户端身份进行认证的话，就会发送CertifacateRequest消息。</li><li>服务端发送ServerHelloDone表明自己已经发送完成。</li><li>当客户端收到CertificateRequest请求后，如果支持认证就发送Certificate消息包含自己的证书。如果没有收到验证请求，就不发送此条消息。</li><li>客户端发送ClientKeyExchange，交换密钥材料。例如使用RSA，就会生成由46字节的随机值和2字节的版本号组成的Pre_master_secret，使用服务端公钥加密后，在本条消息包含发送。</li><li>如果客户端发送了Certificate消息，就需要发送一条CertificateVerify消息来对之前的握手做Hash并用自己的证书私钥进行签名，表明自己确实拥有客户端证书私钥以验证身份，并保证了之前握手消息未被篡改。</li><li>之后会发送ChangeCipherSpec通知对端已经切换密钥了（为了防阻塞不在本消息流中）</li><li>客户端发送Finished消息，通过结合之前握手消息的Hash，Master_secret等生成验证数据，并利用协商出来的Session_key加密传输给对端。Finished消息是第一条使用协商出来的对称密钥加密的消息，通过这条消息验证了密钥的正确性以及之前握手消息未被篡改。</li><li>同样服务端也发送Finished消息，注意在做Hash时的握手消息包含上条客户端发送的Finished消息。</li><li>双方通过握手以及密钥派生计算已经拥有了相同的Session_key，可以进行正式的应用数据加密传输了。</li></ol><h3 id="握手层热启动"><a href="#握手层热启动" class="headerlink" title="握手层热启动"></a>握手层热启动</h3><p>分为Session_id和Session_ticket两种。第一种使用Session_id，发送ClientHello时会客户端会携带会话唯一标示，服务端同意后发送ServerHello以及Finished，根据保存的主密钥Master_secrert等信息以及新的随机值重新计算会话密钥来进行应用数据加密。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Client                                                Server</span><br><span class="line"></span><br><span class="line">ClientHello                   --------&gt;</span><br><span class="line">                                                 ServerHello</span><br><span class="line">                                          [ChangeCipherSpec]</span><br><span class="line">                              &lt;--------             Finished</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                      --------&gt;</span><br><span class="line">Application Data              &lt;-------&gt;     Application Data</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>但是因为存在分布式Session同步以及存储性能的限制，一般选用下面的Session_ticket手段，这十分类似HTTP中的Cookie和Session机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">第一次：</span><br><span class="line">   ClientHello</span><br><span class="line">   (empty SessionTicket extension)--------&gt;</span><br><span class="line">                                                   ServerHello</span><br><span class="line">                                (empty SessionTicket extension)</span><br><span class="line">                                                  Certificate*</span><br><span class="line">                                            ServerKeyExchange*</span><br><span class="line">                                           CertificateRequest*</span><br><span class="line">                                &lt;--------      ServerHelloDone</span><br><span class="line">   Certificate*</span><br><span class="line">   ClientKeyExchange</span><br><span class="line">   CertificateVerify*</span><br><span class="line">   [ChangeCipherSpec]</span><br><span class="line">   Finished                     --------&gt;</span><br><span class="line">            NewSessionTicket</span><br><span class="line">                                            [ChangeCipherSpec]</span><br><span class="line">                                &lt;--------             Finished</span><br><span class="line">   Application Data             &lt;-------&gt;     Application Data</span><br><span class="line">第二次：</span><br><span class="line">   ClientHello</span><br><span class="line">   (SessionTicket extension)     --------&gt;</span><br><span class="line">                                                    ServerHello</span><br><span class="line">                                 (empty SessionTicket extension)</span><br><span class="line">                                               NewSessionTicket</span><br><span class="line">                                             [ChangeCipherSpec]</span><br><span class="line">                                 &lt;--------             Finished</span><br><span class="line">   [ChangeCipherSpec]</span><br><span class="line">   Finished                      --------&gt;</span><br><span class="line">   Application Data              &lt;-------&gt;     Application Data</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>可以看到在第一次中服务端会发送一个NewSessionTicket消息，将会话信息加密并MAC在其中，客户端在第二次中携带ticket，服务端成功解密并验证完整性后，如果同意就会直接省略密钥协商的过程，从而节省了传输时间。</p><h3 id="记录层-1"><a href="#记录层-1" class="headerlink" title="记录层"></a>记录层</h3><p>从握手层得到数据如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ConnectionEnd          entity;</span><br><span class="line">    PRFAlgorithm           prf_algorithm;</span><br><span class="line">    BulkCipherAlgorithm    bulk_cipher_algorithm;</span><br><span class="line">    CipherType             cipher_type;</span><br><span class="line">    uint8                  enc_key_length;</span><br><span class="line">    uint8                  block_length;</span><br><span class="line">    uint8                  fixed_iv_length;</span><br><span class="line">    uint8                  record_iv_length;</span><br><span class="line">    MACAlgorithm           mac_algorithm;  <span class="comment">/*mac 算法*/</span></span><br><span class="line">    uint8                  mac_length;     <span class="comment">/*mac 值的长度*/</span></span><br><span class="line">    uint8                  mac_key_length; <span class="comment">/*mac 算法密钥的长度*/</span></span><br><span class="line">    CompressionMethod      compression_algorithm;</span><br><span class="line">    opaque                 master_secret[<span class="number">48</span>];</span><br><span class="line">    opaque                 client_random[<span class="number">32</span>];</span><br><span class="line">    opaque                 server_random[<span class="number">32</span>];</span><br><span class="line">&#125; SecurityParameters;</span><br></pre></td></tr></table></figure><p>利用PRF密钥派生函数生成以下数据用来加密和MAC。同时因为根据密码学的研究，客户端写/服务端读，服务端写/客户端读，这两种流向是不能使用同一个会话密钥的，会产生安全问题，所以生成两组write key。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client write MAC key*</span><br><span class="line">server write MAC key*</span><br><span class="line">client write encryption key</span><br><span class="line">server write encryption key</span><br><span class="line">client write IV</span><br><span class="line">server write IV</span><br><span class="line">*表示可选，AEAD模式无需MAC</span><br></pre></td></tr></table></figure><p>记录层的流程为数据分段，压缩（可选，因为存在安全问题一般禁用），加密和完整性保护，添加消息头。</p><p>我们这里重点关注加密和完整性保护。在密码学中存在三种加密和MAC的组合方式。</p><ul><li>Encrypt-and-MAC：明文加密和明文MAC拼接在一起。</li><li>MAC-then-Encrypt：对明文MAC后拼接在明文后，对整个进行加密。</li><li>Encrypt-then-MAC：对明文加密后在对密文MAC，将MAC内容拼接在密文后。</li></ul><p>TLS中采用的是第二种，但是随着发展发现了很多问题，例如Padding Oracle漏洞等。对于具体的做法又分为块模式+Hmac，流模式+Hmac，以及AEAD模式。块和流模式采用的是MAC then encrypt，之后为了从密码学上直接解决这个问题，密码学专家便提出了将加密和完整性保护融合在一个算法中即AEAD，彻底解决以上问题，因此更推荐使用AEAD模式例如aes-256-gcm。</p><h3 id="密钥派生函数与密钥变化"><a href="#密钥派生函数与密钥变化" class="headerlink" title="密钥派生函数与密钥变化"></a>密钥派生函数与密钥变化</h3><p>以上就是1.2的基本流程，针对密钥这一块需要单独强调一下。</p><p>我们先看下PRF函数，它通过输入的材料可以通过递归的Hash生成无限长的随机输出，我们可以截取任意长度作为我们的产出需求，看一下具体的表现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> P_hash(secret, seed) = HMAC_hash(secret, A(<span class="number">1</span>) + seed) +</span><br><span class="line">                           HMAC_hash(secret, A(<span class="number">2</span>) + seed) +</span><br><span class="line">                           HMAC_hash(secret, A(<span class="number">3</span>) + seed) + ...</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">A(<span class="number">0</span>) = seed</span><br><span class="line">A(i) = HMAC_hash(secret, A(i<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><p>因此在TLS中的表现形式就为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRF(secret, label, seed) = P_&lt;hash&gt;(secret, label + seed)</span><br></pre></td></tr></table></figure><p>我们有了这样一个派生密钥的工具后，我们在来看下具体的密钥变化。在整个过程中主要涉及三个密钥：</p><p><code>Premaster_secret -&gt; Master_secret -&gt; Session_key</code></p><p>其中Premaster_secret是在握手交换时完成的，采用不同的密钥协商算法会有不同变化，如下：</p><ul><li>RSA：客户端生成随机值作为Premaster_secret。</li><li>静态DH，ECDH：服务端公钥包含在证书中，客户端看是否包含在证书，不在的话就用ClientKeyExchange中，通过计算得出Premaster_secret。</li><li>动态DHE，ECDHE：公钥分别由服务端ServerKeyExchange，客户端ClientKeyExchange消息中，并计算得出Premaster_secret.</li></ul><p>之后使用Premaster_seceret通过PRF函数生成48字节的Master_secret</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret, <span class="string">&quot;master secret&quot;</span>,</span><br><span class="line">                            ClientHello.random + ServerHello.random)</span><br><span class="line">                            [<span class="number">0.</span><span class="number">.47</span>];</span><br></pre></td></tr></table></figure><p>Master_secret才是真正传递给记录层的，之后记录层利用Master_secret生成Session_key，然后切分为对称密钥，IV，MAC密钥来处理真正的应用数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key_block = PRF(SecurityParameters.master_secret,</span><br><span class="line">                <span class="string">&quot;key expansion&quot;</span>,</span><br><span class="line">                SecurityParameters.server_random +</span><br><span class="line">                SecurityParameters.client_random);</span><br></pre></td></tr></table></figure><p>这些变化的理由，我个人思考如下：</p><ul><li><p>为什么不直接使用Premaster_secret生成Session_key呢？</p><p>因为Premaster_secret的格式不同,RSA是48位，ECC类基于具体算法，我们想要得到固定格式的熵源，所以利用PRF函数计算出Master_secret，并且保证secret的随机性不仅仅受单一方影响，比如rsa做秘钥交换时仅仅是客户端发送48字节的值</p></li><li><p>为什么不直接使用Master_secret加密呢？</p><p>长度不够；利用主密钥生成会话密钥会让攻击者进行计算破解难度更大</p></li></ul><p>更多问题限于篇幅请看我之前的文章：<a href="https://www.bdwms.com/?p=946">TLS相关FAQ</a></p><h2 id="回顾与展望"><a href="#回顾与展望" class="headerlink" title="回顾与展望"></a>回顾与展望</h2><p>说到这里，我们暂停一下我们的脚步，首先来回顾一下TLS1.2是怎么完成它开始的设计目标的。</p><ul><li>机密性：非对称和对称加密的结合使用。</li><li>身份认证：证书体系的建立。</li><li>完整性保护：握手阶段的CertificateVerify，Finished消息做校验，记录层对消息做MAC。</li><li>性能：基于Session的会话恢复机制。</li><li>通用性：凡是基于RFC文档实现的，理论上上都是可以做到多种设备的兼容，并且采用的证书体系也是全球通用的。</li><li>可拓展性：在握手的会话中支持插件机制。</li></ul><p>除了以上特性TLS在其他种种方面也是做到基本可用成型，做到了对网络传输安全的保障。当然，这些年来随之密码学的研究深入，以及技术迭代的发展，由此产生了更高的要求，TLS1.2在一些方面已经不能满足业界了，我们简单看下它的主要问题在哪：</p><ul><li>不安全的密码组件，模式和配置。例如RC4,MD5等一种算法被破解，块加密，流加密模式的不安全因素。</li><li>伴随着斯诺登泄密事件，前向安全性更加被重视。</li><li>1.2冷启动至少需要2RTT，热启动需要1RTT，对于很多短链接的场景下，耗时过长是不可接受的。</li></ul><p>为了改善这些问题，1.3版本做了巨大的改变，甚至一定程度上放弃了前向兼容来保证架构的重新调整，让我们在一篇文章中看下TLS1.3究竟有何神奇之处。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来准备一篇文章写完整个TLS1.2和1.3的，但是发现就算省略了很多细节，仅仅是1.2也已经6000多字了，决定还是分上下两篇，方便读者阅读。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tools.ietf.org/html/rfc5246">TLS1.2 RFC</a></li><li><a href="https://halfrost.com/">冰霜之地</a></li><li><a href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/">TLS协议分析 与 现代加密通信协议设计</a></li><li><a href="https://blog.shell909090.org/blog/archives/2873/">安全协议的设计</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>再起航，2021</title>
      <link href="Hello-2021/"/>
      <url>Hello-2021/</url>
      
        <content type="html"><![CDATA[<p>2021起始，告别了我的旧博客，来到了我的新家。</p><p>Hello, World!</p><h2 id="告别过去"><a href="#告别过去" class="headerlink" title="告别过去"></a>告别过去</h2><h3 id="为什么要更换博客"><a href="#为什么要更换博客" class="headerlink" title="为什么要更换博客"></a>为什么要更换博客</h3><ul><li>Wordpress对markdown原生支持不好，尝试了n种插件后发现兼容性或者效果展示也不尽人意。</li><li>旧博客采用的是宝塔+Wordpress+Cloudflare，外加上各种插件，较容易存在安全问题，频繁升级维护很麻烦。</li><li>回望过去两年多来，陆陆续续写了130多篇的博客，但是其质量限于本人的水平，以及写作时较为随意，导致整体的质量不高。并且随着我的大学时光即将结束，慢慢进入社畜的节奏，无法维持高频度的更新，由此想要更加精炼自己的文章。所以最终决定抛下旧包袱，开启新的篇章。</li></ul><h3 id="方案分析选择"><a href="#方案分析选择" class="headerlink" title="方案分析选择"></a>方案分析选择</h3><p>既然决定了要更换博客，那么肯定就要进行好好分析，分为两个部分，一个是新博客如何选择，旧博客如何处理，经过我的尝试，最后完成了本次更新升级。</p><ul><li><p>旧博客：</p><p>一开始的想法是做二级域名，将旧博客指向二级域名，例如backup.bdwms.com。方法很简单，因为我的域名统一托管在cloudflare，只要添加个二级域名的A记录就行了，但是此时就存在两个问题了。</p><p>一个是免费的SSL证书只能是单域名，通配符的证书都要钱，所以就需要给二级域名单独申请一张证书。</p><p>二就是我发现更改完二级域名后，整个Wordpress的链接指向都乱了，分析和搜索了下需要甚至需要手动改数据库，这个操作很危险，考虑我放弃了这个方案，最终选择保留旧博客的域名，重新申请个域名。</p></li><li><p>新博客：</p><p>选择Hexo，优秀地支持markdown，安装和维护简单，作为黑色爱好者选择了极简的主题<a href="https://github.com/probberechts/hexo-theme-cactus">Cactus</a>，也是因为之前看到P牛的博客。</p></li></ul><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h3><p>官网安装npm，hexo，网上文章太多了不多赘述。然后就是配置主题Cactus，进行了一些魔改，评论系统选择了Disqus（需要科学上网）。</p><p>在部署的时候，出现一个选择，一个很简单的方法是直接在Github中配置个[username].github.io，然后在_config.yml中配置deploy的repository，再将自己的新买的域名解析到[username].github.io，再在仓库的settings配置下域名就可以替换域名了。</p><p>但是这样的话不够优雅，每次都需要</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>并且存在一个备份和同步问题，我要是换了电脑怎么复原，以及怎么在不同电脑上写呢。我研究了网上的方法，很多说在仓库里面新开一个branch，但是这样的话很多配置魔改的文件都会公开，遂放弃。</p><h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><p>最后经过研究参考部署的方便，以及备份和同步，选择了Github提供的Action来做自动部署，优化使用流程只需要push代码就可以自动部署，并且将自己的源代码单独放在一个私有库，生成文件在公开库，同时将魔改后的主题文件单独放在一个库中。具体流程如下：</p><ol><li><p>生成三个库，一个私有库放BlogSource源代码，一个公共库Themes放魔改的主题，一个公共库[username].github.io放真正的生成文件。然后进行生成密钥对，私钥放<code>Settings -&gt; Secrets -&gt; Add a new secret</code>，命名<code>HEXO_DEPLOY_PRI</code>,公钥放github.io的公钥库<code>Settings -&gt; Deploy keys -&gt; Add deploy key</code>，命名<code>HEXO_DEPLOY_PUB</code>，开启<code>Allow write access</code></p></li><li><p>因为我clone后魔改的主题也想要进行管理，所以将其推到Themes库，注意这里push的时候将主题的_config.yml改名放在博客根目录中，不能传到公共库中，在博客根目录生成git后，与主题的git冲突，于是选择使用submodule方式，进行分离管理，命令类似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add [themes_url] themes/cactus</span><br></pre></td></tr></table></figure><p>然后为了能够保证CNAME不被每次覆盖，在source文件下放一个CNAME文件，里面写要CNAME的域名，push源代码到远端。</p></li><li><p>最后也是最重要的生成CI/CD文件，在私有库的Action中选择生成一个Workflow，配置文件例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">GIT_USER:</span> <span class="string">user.name</span></span><br><span class="line">  <span class="attr">GIT_EMAIL:</span> <span class="string">user.email</span></span><br><span class="line">  <span class="attr">THEME_REPO:</span> <span class="string">birdmanwings/cactus-modify</span></span><br><span class="line">  <span class="attr">THEME_BRANCH:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">DEPLOY_REPO:</span> <span class="string">birdmanwings/birdmanwings.github.io</span></span><br><span class="line">  <span class="attr">DEPLOY_BRANCH:</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span> <span class="string">on</span> <span class="string">node</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span> <span class="string">and</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.os</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">os:</span> [<span class="string">ubuntu-latest</span>]</span><br><span class="line">        <span class="attr">node_version:</span> [<span class="number">14.</span><span class="string">x</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">theme</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">themes/cactus</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">deploy</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.DEPLOY_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.DEPLOY_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">.deploy_git</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configuration</span> <span class="string">environment</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">HEXO_DEPLOY_PRI:</span> <span class="string">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">sudo</span> <span class="string">timedatectl</span> <span class="string">set-timezone</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;$HEXO_DEPLOY_PRI&quot;</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">$GIT_USER</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">$GIT_EMAIL</span></span><br><span class="line">          <span class="string">cp</span> <span class="string">_config.theme.yml</span> <span class="string">themes/cactus/_config.yml</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">run</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>需要更改下名字，邮箱，主题地址，分支名称，然后commit就可以了，这里注意主题config，密钥对名称是否正确，之后本地pull下同步下代码，写一个文章push上去后能够发现成功自动部署。</p></li></ol><p>可以看下最后的项目结构类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy_git</span><br><span class="line">├── .git</span><br><span class="line">├── .github</span><br><span class="line">│   └── workflows</span><br><span class="line">│       ├── main.yml</span><br><span class="line">├── _config.landscape.yml</span><br><span class="line">├── _config.theme.yml</span><br><span class="line">├── _config.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── source</span><br><span class="line">│   ├── CNAME</span><br><span class="line">│   ├── _posts</span><br><span class="line">│   │   ├── Hello,World.md</span><br><span class="line">│   ├── about</span><br><span class="line">│   │   └── index.md</span><br><span class="line">│   ├── categories</span><br><span class="line">│   │   ├── index.md</span><br><span class="line">│   └── search</span><br><span class="line">│       ├── index.md</span><br><span class="line">└── themes</span><br><span class="line">    └── cactus</span><br><span class="line">        ├── LICENSE</span><br><span class="line">        ├── README.md</span><br><span class="line">        ├── gulpfile.js</span><br><span class="line">        ├── languages</span><br><span class="line">        ├── layout</span><br><span class="line">        ├── package.json</span><br><span class="line">        ├── scripts</span><br><span class="line">        └── source</span><br></pre></td></tr></table></figure><h3 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h3><p>如何备份恢复呢，先配好git，npm，hexo，然后clone recurvise自己的源代码下来，<code>npm install</code>安装下依赖，然后就可以写文章push自动部署了，跟我们平常做项目管理没有什么区别了。</p><h3 id="阿里云CDN加速"><a href="#阿里云CDN加速" class="headerlink" title="阿里云CDN加速"></a>阿里云CDN加速</h3><p>折腾了几天终于配好了，吐槽下阿里云前端逻辑真的乱，然后网上教程好多还是错的，无语。首先域名需要备案，然后买一个下行流量包和静态HTTPS包，然后申请下全站加速，源站选username.github.io，选择申请。通过后会分配一个CNAME，然后配置CNAME域名，境外和境内分两个线路来配，如下：</p><p><img src="https://image.bdwms.com/Fs0bf19oDln8Cst3gjqY8VyVUW4B"></p><p>Github仓库的custom域名指向bdwms.site。然后因为cdn没有HTTPS，需要申请个免费证书部署到CDN，开启强制HTTPS。等会后看下国内访问速度，一片绿感人。</p><p><img src="https://image.bdwms.com/FmB36fDsTH3KgzELf6JVobQ6-_qO"></p><h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>下一个十年，</p><p>想做一个懂业务的安全人，</p><p>想做一个有思考的技术人，</p><p>想做一个明白爱的成年人，</p><p>再起航，2021～</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/87053283">Git中submodule的使用</a></p></li><li><p><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">利用 Github Actions 自动部署 Hexo 博客</a></p></li><li><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-5">超详细Hexo+Github博客搭建小白教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>静夜思（十九）-追寻一切美好</title>
      <link href="night-thoughts-19/"/>
      <url>night-thoughts-19/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在每一个深夜苦苦思索</p></blockquote><p>这是一篇很长的总结与思考。</p><p>我将自己沉浸在回忆中，记录下脑海中不断浮现的词汇：</p><p>「流星，太阳，戾气，善良，温暖，责任，自备，抑郁，自闭，自责，迷茫，抉择，期许，普通，梦想，懒惰，命运，妥协，坚持，孤独，生命，美好，社会，交流，麻木，自大，偏见，贪婪，本心，意义，生理，环境，虚无，快乐，奋斗，焦虑，愤怒，亲情，友情，爱情，比较，浅薄，躲避，失败，成功，语言……」</p><p>我在深夜中回忆着曾经的一年，四年，乃至全部的二十余年青春。将这些零碎的记忆挖掘出，整理成了这些词汇，我想用它们串联起我的生命，希望能对我的计算有所帮助。</p><h2 id="痛苦与自卑"><a href="#痛苦与自卑" class="headerlink" title="痛苦与自卑"></a>痛苦与自卑</h2><p>毫无疑问我的十八岁是痛苦的。曾经的我一度否认自己的痛苦，害怕承认自己的懦弱，自卑，孤僻等等一切负面，然后这却让我越陷越深。总是想要避开人群，不让自己的灰色能量影响到别人，于是进行自我隔离，生理和心理都是如此。仔细想想从高三开始就很少从心底感到快乐，越来越少和人交流。</p><p>再仔细深究痛苦和自卑的由来，无非不过家庭环境，成长经历，自我选择这几种因素，但是似乎也并没有什么大挫折，可能是缺乏陪伴和理解，以及常常钻牛角尖让自己的性格和状态逐渐滑坡，不断的负反馈导致了最终的结果。明明知道自我否定是不对的，但依然沉溺于悲伤去逃避。</p><p>我也曾尝试过自救，希望高考后能去念心理学，想要去北师大念心理学，不过可惜高考的发挥也是一般，毕竟状态这么差去考试结局也是想当然的，最后用排除法去了一所从来没有听过名字的学校。不过算是不幸中之大幸，在成都竟然找到了新的自己。</p><p>写下这一段并不是为了博取什么同情，只是现在的我知道，只有正视自己的抑郁，不再否认它，才能更好的生活。</p><p>是的，我曾经很痛苦，普通而又真实的痛苦。</p><h2 id="接受自我"><a href="#接受自我" class="headerlink" title="接受自我"></a>接受自我</h2><p>第一件重要的事就是接受自我。那时候的自己绕着学校跑步，可能也是身体最好的时候（笑），天天泡在图书馆自闭式学习，有时也会强迫自己去参加活动，志愿者，演讲等等。明明不怎么喜欢和人过于接近，却还要带着笑脸去沟通，最后甚至成为了青年志愿者协会的负责人，真是有点佩服自己的忍耐力。</p><p>我知道自己不是个自觉的人，在一个环境下就会随波逐流，于是我总是努力将自己扔出自己的舒适圈，去融入到新的地方。感谢这一点小倔强，让自己能够很幸运遇到很多牛人，加入了两个工作室微光和CNSS。在CNSS里面当然是垫底人群，看着很多优秀的人，他们有的从小学就玩计算机，有的是天赋异禀型选手，有的是能够为了热爱的东西付出超出想象的精力，很高兴自己能够从发这些人身上学习到很多，也是因此才能真正迈入互联网这个行业。还有就是在微光工作室的时期，那时候我们什么都没有，几个人被招新进来就是放养，没有人告诉我们应该去做什么，去学习什么，遇到问题怎么解决，应该选择什么样的方向，甚至连座位都是蹭别人的。我们只能自力更生，踩坑摸黑，其中的困难不想再赘述，但是很感谢有那么一群人陪伴我成长，也是让我解开心结的重要助力，感谢。</p><p>人们说接受自己的平庸才会成长，但是我想接受平庸并非懦弱放弃，而是学会敬畏，明白自己所知有限，所行有界，因此既不傲慢自大去想掌控一切，同时切记妄自菲薄。我非常喜欢《头脑特工队》，快乐还是悲伤同样重要，何必害怕去展露悲伤，想笑就笑，想哭就哭，只要尊重别人，不影响到他人，我又何必在乎什么不重要的事情呢。大学四年，我想我逐渐补全了自己的性格缺陷，不再会与人接触感到厌恶，不再总是将错误归结于自己，不再将自己封闭内心高墙中。我渐渐学会了如何取悦自己，如何为自己寻找快乐，如何自爱。</p><p>可能依旧还有很多事情我不懂，很多错误我会犯，很多人我会错过，但是我已经学会了如何爱自己，学会接受自我，请再给我一点时间去努力。</p><h2 id="未来有一个人在等待"><a href="#未来有一个人在等待" class="headerlink" title="未来有一个人在等待"></a>未来有一个人在等待</h2><p>大一的时候，我想过未来我会成为一个什么样的人，又会遇到什么样的人。「未来有一个人在等待」，四年来都是我博客的标题，我相信着自己会遇到一个美好的人，一个简单幼稚的信念一直支撑着我。再回头看看自己写下的承诺，感到青涩但是我并不羞耻，我很开心我一直没有忘记我想要的是什么，实现途中可能有挫折，但是大方向一直未变过。</p><blockquote><p>我为什么要努力？<br>因为，我希望在未来的自己有能力去守护自己所爱，去寻找灵魂失去的那部分，想做那个最坚硬的盾。</p><p>我想当我遇到那个我心爱的姑娘时，自己足够的优秀去追求她，不会被现实的物质阻碍，不会因为没钱没房而没有能力去给她一个真正的承诺。我知道爱我的她也许愿意和我一起承担现实的压力，但是身为一个有担当的男人我不愿她吃一点苦。我想，在我尚未遇到她的时间里，变得足够强大，有能力给她一个最起码物质上富足的家，我畏惧在未来，我们会哭泣着因为生活的窘迫而分离，我害怕明日平庸的我无法与她般配。我努力，我来为她搭好一个家。</p><p>我想当面对亲人遭受疾病的侵袭时，不用因为没有钱而无法提供最好的医疗条件，我不想那些爱我的人遭受病魔的折磨时却束手无策。我见过死亡，那是沉重的，那是轻飘飘的，我永远记得那一张纸厚的破布盖在那个无名女子身上，蓝色的衣角，赤裸的双足，沉重的车轮，今日回想，感到凉意万分，我不会去选择忘记，我要将这种感觉牢记在心中，提醒着我生命的脆弱与可贵。我希望未来的自己足够强大，强大到能与病魔扳手腕，强大到能从死神手中夺回属于自己的爱。我努力，我来为他们驱走所有的疾苦。</p><p>我想在我再次独自面对孤独抑郁时，有能力去拯救自己。我想当我精神空虚时，最起码物质充足（笑），我能了解自己为什么会难过，能不仅仅是沉溺着迷于悲伤的自我安慰中，能够通过阅读思考提升自己的辨识能力。</p><p>——17.11.23</p></blockquote><p>我为自己寻找到了性格中所欠缺的部分，一直没有忘记真正想要的是什么。曾经以为未来的那个人是个具象的她，但是随着我的思考和成长，那个她逐渐在我的脑海中丰满了起来，她本应该就是我，是我所希望成为的一个人，善良，负责，智慧，坚强……这些我所追寻的品质就是未来的她，在未来等待着我。</p><h2 id="迷茫与幸运"><a href="#迷茫与幸运" class="headerlink" title="迷茫与幸运"></a>迷茫与幸运</h2><p>四年来，迷茫总是不断在我的生活中出现，有时很羡慕一些同学可以无忧无虑的享受大学生活，对于我来说从大二结束，就开始奔赴各地去实习了，在学校的时间总是短暂和充实的。工作室的几个人就像是被打着催熟剂一样，在学校，实习，还是正式工作都反复思考着未来，我们互相质问很多东西，担忧很多东西，同样也憧憬很多东西，我知道各自都有想法，有时候还经常被当作混了几年的老油条子（笑，表面镇定，内心还是非常紧张的。</p><p>关于未来的选择，总结下来无非读研，出国，就业三条路，在我们学院很少人直接就业，我也不知道自己的选择是否一定正确。我不想继续读研，因为我知道读研并不能缓解我的焦虑，无论是从能力，还是心理来说可能提升并不大，三年下来也许只是一张文凭。同样我对互联网行业在中国保持着悲观的态度，同样是当年大热的土木工程，从零八年大建设到一三一四年没落，连短短十年的时间都没有，对于互联网这个年轻的行业来说，从一五年逐渐掀起的浪潮至今也有六七年了，我已经没有时间再用三年去赌一个未来，所以这条路在我这里行不通。</p><p>对于出国，去加拿大的两个月的确是我大学中难得的快乐时光。自由与轻松是主旋律，这里没有高度内卷，人均资源的丰富，发达国家的先进的确让人觉得是个适宜居住的好地方，但是跳脱出这样的心情，很遗憾地表示这里并非我的归处，当地人的友好更多还是礼貌，对于亚洲黄种人的歧视还是隐藏在深处，同样个人对家乡的眷恋也让我无法抉择去出国。再美好的东西，不是自己的，也没法强求。</p><p>就业当然也不是完美的选择，我知道中国互联网的发展畸形，但是对于这个充满魅力的世界我实在无法放弃。互联网可能是我第一个热爱的东西，尤记得第一次实习，在长亭科技的时候，可以专心于技术，见到了phithon p牛p师傅，遇到了我的mentor，遇到了各路黑客大神。可以想象么，一个从未亲自前往的世界，通过互联网就可以触手可及，信息不再闭塞被少部分人占有，一个渺小的个体没有大量的生产资本就可以创造巨大的价值。我认为我很幸运可以参与到这样一场社会变革，高考填写志愿时排除了理科，医生，老师等等，一心想做一些实事，很幸运捡漏来了成电，能让自己走上互联网的路。</p><h2 id="保持愤怒，保持激情"><a href="#保持愤怒，保持激情" class="headerlink" title="保持愤怒，保持激情"></a>保持愤怒，保持激情</h2><p>随着年龄的增长，有时会突然发现自己对很多事物丧失了好奇心，「魔术帽中的兔子」不能再令我感到惊奇。这是一件很可怕的事情，当习惯于每天的重复劳动，习惯于一些不公平的事，习惯自己的固化，那么我想我的生命就开始打了折扣，一年中属于自己的时光到底还剩几天，说的话有什么意义，做的事情有什么价值。</p><p>所以我很羡慕那些拥有自己热爱的朋友，他们正是我生活路上最该学习的榜样。大学四年可能我暂时仅仅学会了满足自己的内心，跳出固定的视角来看自己确实不够有趣，在可预见的将来我也会对自己感到枯燥乏味，所以我打算在未来的几年内寻找尝试各种可能性，付出精力去发掘内心的激情。在我看来，人一生如果有一两件值得奋斗，保持快乐的事情就已经是十分幸运了，那目前来看互联网算是我一个热爱的，我也会继续努力去培养下一个。</p><p>至于愤怒，则是一种不妥协，错误的事情永远不会承认其合理，存在并非合理，当我面对不公平，不正义的事情时依旧能说不，用自己的思考去对抗麻木不仁。社会是灰色的，但这不是我放弃是非观念的理由。智慧解决问题的前提是有一颗坚定的心，如果当某天我冷漠不已，那么我一定会痛恨自己。保持愤怒，永远对错的说不。</p><h2 id="关于爱"><a href="#关于爱" class="headerlink" title="关于爱"></a>关于爱</h2><p>关于爱，必须承认我是个初学者。我想的是爱别人首先需要爱自己，也因此很长一段时间一直拒绝别人，因为害怕伤害别人，那时还不会爱自己，没有精力去照顾别人。但是我依然坚定自己的信念，我会保持自己最大的尊重。</p><p>过去很长时间都是一个人，一个人看电影，一个人去旅游，一个人去音乐节，一个人去医院……但是却很少感到孤独，我在思考一个问题，两个人在一起的原因和目的是什么，很难给出一个准确的答案，我只能暂时归纳于几点生理限制，社会责任，精神需求。对于爱，我真的很笨，很迟钝，或许在未来的很长一段时间我还是会处于这种状态，像个傻瓜一样一个人吧。目前看来，我只知道去让自己变得更加优秀，更加积极的去准备未来可能发生的一切，可能还远远不够，但是我会坚持的。</p><p>加油去学会爱吧，想要成为一个懂得爱的成年人。</p><h2 id="物质和精神"><a href="#物质和精神" class="headerlink" title="物质和精神"></a>物质和精神</h2><p>我自认为是一个「积极的悲观者」，面对物质需求总是抱着悲观态度，却还是积极的去准备，当然现实可能既没有那么坏，也没有那么好。我认为大部分的精神需求都是建立在物质需求的基础之上的，当然两者是相互作用的，所以我一直对很多事情怀着否认的态度，例如异地恋，例如家庭背景差距过大的婚姻等等这样的例子。以我的观点，一个健康的循环是物质充盈和精神饱满同时匹配的，当两者错位过多，只会造成悲剧的结果。</p><p>当然我并不是指物质完全决定精神，好比家人一直劝我早点在杭州落户买房，我内心当然知道尽早上车的好处，也的确去实践调查过一番，但是在思来想去很难对这座城市有驻足的念想，这里没有我所爱的人，没有我成长的经历，没有我值得留念的。行动上积极打算，内心却悲观展望，可能这就是我吧，也希望在未来，能遇到对的人，希望这座城市能有让我留下的理由。</p><p>对于现实和理想，我想用最理性的方式去解决问题，坚定不移地去用计划去支撑理想。如何平衡好物质追求与精神追求可能是我这几年里最为困难的事了，在互联网这个精彩到令人眼花缭乱的世界，希望自己依旧能保持一份清明。</p><h2 id="责任与善良"><a href="#责任与善良" class="headerlink" title="责任与善良"></a>责任与善良</h2><p>关于未来十年，我能想到最重要的两个关键词就是责任和善良。</p><p>我想要成为一个负责任的人，能够在面对困难时挺身而出，做个别人能够信赖的人。我能够为自己的言行负责，能够为自己许下的诺言负责，能够为他人托付的信任负责。说一不二，坚韧果决，我选择的责任一定会用尽全力完成。这就是我希望在我三十岁时能够达到的状态。当然，这很困难，无论是从能力与物质基础出发，还是从内心理念来说，都是需要长期的培养才可能形成的品质，漫漫长征路上为自己逐年规划更加细节的目标，在未来的每一年里都能够逐渐的成长。</p><p>另一个关键词就是善良，我总说妈妈是个自来熟，热心肠的人，妈妈也告诉我从未见过面的外婆那时候也是被外人称赞的大好人，所以我当然也想要成为一个好人，成为一个善良的人。「我认为你选择大雄是完全正确的，那个年轻人会为别人的幸福而高兴，为别人的不幸而伤心。这对于一个人来说是最重要的事情」，和大雄一样，我同样希望能够成为一个有同理心的人，在每一次抉择时都能够无愧自己的内心，去选择善良。这个世界已经够黑暗了，我希望自己能保留那一份善意，留给需要的人。</p><p>这就是我的十年愿景，从步入社会的那一天给自己许下的誓言，期待着未来的我吧。</p><h2 id="追寻一切美好"><a href="#追寻一切美好" class="headerlink" title="追寻一切美好"></a>追寻一切美好</h2><p>最后的最后，我回忆了过去的经历，那些依然能在我脑海中闪过的画面总是那么美好：</p><p>是深夜学校的枫叶大道上，一个人仰望星空的感受；</p><p>是离开加拿大的班车上，掠过我眼前的难舍画面；</p><p>是和弟弟在工作室通宵奋斗，一起乱唱的rap；</p><p>是在草莓音乐节，狂欢蹦跳的快乐；</p><p>是夕阳下的西安古城墙，我独自思索的宁静；</p><p>是重庆江边，耳机中Radwimps的《告白》；</p><p>是北京天安门前，只有我一人时的震撼；</p><p>是厦门旅行时的彷徨；</p><p>是杭州河边的不甘心；</p><p>是成都小酒馆的最后一聚，出租车上的《送战友》；</p><p>是向朋友家人哭泣，落下的泪水；</p><p>是我感受到成长的快乐；</p><p>是我对遇到更美好的世界，遇到你的憧憬；</p><p>……</p><p>十四亿分之一，浩瀚与渺小两相交映，我的人生仿佛一道流星划过，不知是否能成为一瞬的微光，点亮你我。</p><p>我将继续前进，去追寻一切的美好。</p><p>再会！</p>]]></content>
      
      
      <categories>
          
          <category> 静夜思 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人家庭影音系统</title>
      <link href="home-video-system/"/>
      <url>home-video-system/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于OpenWrt以及闲置硬件打造一个简易版的家庭影音管理系统。</p></blockquote><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>笔者有收藏电影，MV，音频，照片的需求，在体量还比较小的时候，依赖文件命名分层来进行管理还是足够的。但是当量级达到TB后，简单的文件夹管理已经不够了，存在下面几个问题：</p><ul><li>文件夹层级过深，电影等打标元数据复杂。</li><li>缺乏预览图片，类型打标搜索等能力，数据可视化困难。</li><li>难以随时浏览，必须启动电脑来做数据入口。</li></ul><p>为此，针对以上问题，笔者总结了几点需求：</p><ul><li>自动化打标，分类。</li><li>数据可视化，提供预览能力。</li><li>局域网内随时可访问（暂时没有广域网需求）。</li></ul><p>经过调研，最简单的方案是比较成熟的群辉，但是最近市场硬盘太贵，决定还是自己DIY，依赖已有的能力去搭建一个局域网网络环境。</p><h2 id="基本条件"><a href="#基本条件" class="headerlink" title="基本条件"></a>基本条件</h2><ul><li>路由器：Linksys wrt32x，支持千兆网络，一个USB3.0接口，一个USB2.0接口</li><li>硬盘：闲置的希捷酷鱼4T，并补充了一个绿联硬盘盒</li><li>笔记本：闲置暗夜精灵3，大学用的游戏本，现在主要来做拓展功能</li><li>网络：移动百兆宽带</li></ul><p>路由器是之前双十一半价700入手，一直只是作为普通路由器使用，这次决定进行升级改造，基于OpenWrt加外挂硬盘，并配合docker来进行支持服务，能够拥有更高的可玩性。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="固件编译"><a href="#固件编译" class="headerlink" title="固件编译"></a>固件编译</h3><p>OpenWrt版本选择<a href="https://github.com/coolsnowwolf/lede">lean</a>大的版本，维护良好，插件众多，并开源易定制化，本次采用本地编译的方式。</p><ol><li><p>Ubuntu20.04 vmware安装</p></li><li><p>配置qv2ray代理，配置好v2ray-core等依赖环境，确保能够稳定科学上网。</p></li><li><p>安装proxychains-ng来作为命令行代理，注意设置配置文件中不代理本地IP。</p></li><li><p>配置Golang最新版本，并设置GOPROXY代理，某些插件可能依赖go库（很奇怪proxychains没有代理到go mod，只能单独配置下GOPROXY代理）</p></li><li><p><a href="https://github.com/coolsnowwolf/lede">https://github.com/coolsnowwolf/lede</a> 按介绍进行编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/coolsnowwolf/lede.git</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch python3 python2.7 unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint device-tree-compiler g++-multilib antlr3 gperf wget curl swig rsync realpath</span><br><span class="line"><span class="built_in">cd</span> lede</span><br><span class="line">./scripts/feeds update -a &amp;&amp; ./scripts/feeds install -a</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p><img src="https://image.bdwms.com/FtM5HdZJhnesauWZfY2byUPWIusR"></p></li><li><p>根据<a href="https://ssr.tools/1366%E9%80%89%E6%8B%A9%E7%9B%B8%E5%BA%94%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%AC%94%E8%80%85%E7%9A%84%E6%98%AFwrt32x%E3%80%82">https://ssr.tools/1366选择相应的配置，笔者的是wrt32x。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Target System : Marvell EBU Armada</span><br><span class="line">Subtarget : Marvell Armada 37x&#x2F;38x&#x2F;XP</span><br><span class="line">Target Profile : Linksys WRT32x</span><br></pre></td></tr></table></figure></li><li><p>第一次编译时不选择多余的插件，确保主模块能够顺利编译，首次编译可能需要2到3个小时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 make -j8 download V&#x3D;s 使用代理下载依赖库</span><br><span class="line">make -j1 V&#x3D;s 第一次使用单线程编译方便定位出错</span><br></pre></td></tr></table></figure><p>如果成功编译，输出的文件在bin/target中。</p></li><li><p>第二次重新编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf .&#x2F;tmp &amp;&amp; rm -rf .config 删除原本的配置</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>以安装docker为例子选择所需的选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Target System : Marvell EBU Armada</span><br><span class="line">Subtarget : Marvell Armada 37x&#x2F;38x&#x2F;XP</span><br><span class="line">Target Profile : Linksys WRT32x</span><br><span class="line">Extra packages : automount autosamba ipv6helper</span><br><span class="line">LuCi-&gt;Collections :</span><br><span class="line">luci-lib-docker （luci与docker交互的api,dockerman需要使用的库）</span><br><span class="line">LuCi-&gt;Applications :  </span><br><span class="line">luci-app-docker （lean编写的docker界面，勾选后将会自动勾选dockerd服务端）</span><br><span class="line">Utilities :</span><br><span class="line">docker （docker命令行工具）</span><br><span class="line">dockerd (docker-ce，docker的服务端程序)</span><br></pre></td></tr></table></figure><p>第二次重新编译可以选择多线程编译，如果出错的话可以尝试用单线程编译定位错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j$(($(nproc) + 1)) V&#x3D;s</span><br></pre></td></tr></table></figure><p>如果需要拉取更新后编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">.&#x2F;scripts&#x2F;feeds update -a &amp;&amp; .&#x2F;scripts&#x2F;feeds install -a</span><br><span class="line">make defconfig</span><br><span class="line">make -j8 download</span><br><span class="line">make -j$(($(nproc) + 1)) V&#x3D;s</span><br></pre></td></tr></table></figure><h3 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h3></li></ol><p>对于linksys wrt32x是拥有双分区来保证刷不死特性，具体不在这里赘述，</p><ol><li><p>将img固件从虚拟机中复制出来，如果不在原厂分区，切换到原厂固件分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;sbin&#x2F;fw_printenv -n boot_part 当前分区号</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;fw_setenv boot_part 1 &amp;&amp; reboot 切换分区</span><br><span class="line">&#x2F;usr&#x2F;sbin&#x2F;fw_setenv boot_part 2 &amp;&amp; reboot</span><br></pre></td></tr></table></figure></li><li><p>moxeterm ssh连接然后将img固件上传并升级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysupgrade -n -v ***.img</span><br></pre></td></tr></table></figure></li><li><p>重新连接WiFi，ssh连接后lsblk查看硬盘信息，假如之前硬盘没有分区，利用cfdisk将硬盘划分为三个区，cfdisk分三个区分别给</p><ul><li>overlay(sda2:3G)：作为openwrt的软件层，存储各类工具软件，需要进行扩容。</li><li>docker(sda3:30G)：存储docker的根目录。</li><li>剩余容量存储挂载(sda4)：作为影音存储。</li></ul><p>然后Write进去并重启路由器。</p></li><li><p>格式化硬盘为ext4格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 &#x2F;dev&#x2F;sda2</span><br><span class="line">mkfs.ext4 &#x2F;dev&#x2F;sda3</span><br><span class="line">mkfs.ext4 &#x2F;dev&#x2F;sda4</span><br></pre></td></tr></table></figure></li><li><p>挂载刚刚的三个分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;sda2 &#x2F;mnt&#x2F;sda2</span><br><span class="line">mount &#x2F;dev&#x2F;sda3 &#x2F;mnt&#x2F;sda3</span><br><span class="line">mount &#x2F;dev&#x2F;sda4 &#x2F;mnt&#x2F;sda4</span><br></pre></td></tr></table></figure></li><li><p>备份overlay的配置，否则之后重启路由器后会丢失配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r &#x2F;overlay&#x2F;* &#x2F;mnt&#x2F;sda2</span><br></pre></td></tr></table></figure><p>   如果有upper和work说明正确</p></li><li><p>启用挂载点，在web界面挂载点中挂载overlay的sda2和docker的sda3</p></li><li><p>重启路由器，看系统-软件包是否扩容成功</p><p><img src="https://image.bdwms.com/FrzMbKeWyARBv3JpFPOXtp-mcRq5"></p></li><li><p>/etc/docker/daemon.json更换docker国内源，在面板启动项中重启dockerd，或者/etc/init.d/dockerd restart，重启,docker info查看是否成功</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://b2tx75ys.mirror.aliyuncs.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://dockerhub.azk8s.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span></span><br><span class="line">  ],</span><br><span class="line"><span class="attr">&quot;data-root&quot;</span>: <span class="string">&quot;/opt/&quot;</span>,</span><br><span class="line"><span class="attr">&quot;log-level&quot;</span>: <span class="string">&quot;warn&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用/etc/docker-web启用portainer docker管理界面，其实就是命令，ip:9999就是portainer管理界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart&#x3D;always --name&#x3D;&quot;portainer&quot; -p 9999:9000 -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v portainer_data:&#x2F;data portainer&#x2F;portainer-ce</span><br></pre></td></tr></table></figure><p><img src="https://image.bdwms.com/FhLfYTiVlYFA4CnCkzW8JQYz-YKT"></p></li><li><p>使用Jellyfin镜像作为影音管理系统，Jellyfin的使用不再赘述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull jellyfin&#x2F;jellyfin:latest</span><br><span class="line">mkdir -p &#x2F;dev&#x2F;sda4&#x2F;jellyfin&#x2F;&#123;config,cache,media&#125;</span><br><span class="line">docker run -d --restart&#x3D;always --name&#x3D;&quot;myJellyfin&quot; -p 8096:8096 -v &#x2F;mnt&#x2F;sda4&#x2F;jellyfin&#x2F;config:&#x2F;config -v &#x2F;mnt&#x2F;sda4&#x2F;jellyfin&#x2F;cache:&#x2F;cache -v &#x2F;mnt&#x2F;sda4&#x2F;jellyfin&#x2F;media&#x2F;:&#x2F;media jellyfin&#x2F;jellyfin:latest</span><br></pre></td></tr></table></figure></li><li><p>ip:8096就可以访问到Jellyfin，然后就可以进行常规的配置了</p></li><li><p>网络共享中可以将sda4分享出去，注意权限0777，修改invaliduser，并设置samba密码</p></li></ol><h3 id="网络唤醒"><a href="#网络唤醒" class="headerlink" title="网络唤醒"></a>网络唤醒</h3><ul><li>闲置笔记本惠普暗夜精灵3，两块移动硬盘</li><li>将笔记本作为主机合盖使用，节约空间</li></ul><p>所以基于以上条件使用wake on lan技术作为网络唤醒</p><ol><li>将BIOS系统升级到最新版本，操作参考惠普官网。</li><li>F10进入BIOS开启网络唤醒的选项。</li><li>进入win10的设备管理器，修改有线网卡驱动的选项，开启网络唤醒选项，确保魔术封包支持开启。</li><li>win10下载wake on lan软件，用于测试。</li><li>安卓端下载极致工具箱，配置mac地址，电脑坐在网络段，端口默认9。</li><li>安卓端发送测试包，wake on lan打开封包监控管理工具接受魔术封包，如果能够接受到，基本说明成功。</li><li>网线连接路由器Lan口和电脑网口，关机后后手机端发送网络唤醒请求，理论上可以唤醒成功。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://ssr.tools/1369">Lean Lede编译方法</a></p></li><li><p><a href="https://www.right.com.cn/forum/thread-1180536-1-1.html">WRT32X刷回原厂固件和第三方固件</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/29100706">网络唤醒全攻略(Wake On LAN)</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1Up4y1z7ua">在OpenWRT上安装Docker &amp; OpenWRT插件安装教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自建情报库-财务篇</title>
      <link href="information-database-finance/"/>
      <url>information-database-finance/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自建情报库系列是一套信息收集方法论，目的是为了帮助毕业生建立必备的知识情报体系，从而更好地迈入社会。本系列将会从住房，政策，经济，医疗等方面进行概括性的叙述，形成一条完整的知识链路，作为之后付诸行动的个人信息门户。</p></blockquote><p>“财务管理与其说是理财，不如说是理人。”</p><p>在正式工作之前笔者一直对泛金融类的方向抱有消极态度，高考志愿填报时因认为金融只是消耗分配价值，没有直接创造价值而放弃。但是随着时间流逝，更多的接触社会，却也有了一些不同的看法。在这个物欲横流的社会，毕业生很容易会为钱所困，这也是笔者正在经历并且想要解决的。形形色色的问题扑面而来 ，例如：</p><ul><li>越有钱就会越快乐么？</li><li>为什么我总是月光？</li><li>怎么过上想要的生活？</li><li>害怕35岁被开除怎么办？</li><li>……</li></ul><p>这些问题或多或少与钱相关，交织如麻下显得很复杂 ，因此笔者在这篇文章中准备以基本的理念为原点，逐渐向外拓展，力图勾勒出一个完整的理财印象，并最终能够解答以上的困惑。</p><h2 id="什么是理财"><a href="#什么是理财" class="headerlink" title="什么是理财"></a>什么是理财</h2><p>很多人将理财简单地定义成通过资产管理从而保证增值，但实际上资产管理仅仅是整个理财体系中的一部分。在笔者看来完整的理财包括：</p><ul><li>定义生活目标</li><li>摸清财务状况</li><li>建立理财体系</li><li>动态反馈调整</li></ul><p>从自身的条件出发（包括家庭环境，性格偏向，能力水平等），能够给出一个符合<a href="https://zh.wikipedia.org/wiki/SMART%E5%8E%9F%E5%88%99">SMART原则</a>的目标。之后开始全面摸清个人乃至整个家庭的财务状况，包括收入支出，资产负债等。有了这些基本数据后，就可以根据需求制定具体理财计划，包括现金流如何分配，选择怎样的理财产品，收益风险比如何取舍等等。最后，因为计划的不合理，市场环境的复杂，个人需求的更变各种因素影响下，每年的理财计划必然是需要做调整修正的。</p><p>在这些步骤中，笔者想要着重强调几点：</p><ul><li><p>复杂关联</p><p>理财不仅仅包括现金储蓄，还与投资，房产，保险，教育，养老等众多因素强相关，恰如一串珍珠项链，牵一发而动全身，这就要求从更加宏观的角度去考虑问题，切勿钻入牛角尖。</p></li><li><p>时间周期</p><p>理财具有生命周期性，在不同年龄段需要注意的重点不同。从22岁左右毕业，到30岁左右结婚生子，一直持续到65退休，个人的财务状况都是不断变化的，并且可能伴随着两个家庭的融合，所以会更加复杂，需要抱有动态的理念。这里读者可以关注下即将发布的第七次人口普查结果，判断自己处于哪一人生阶段，进而制定相应的计划。</p><p><img src="https://image.bdwms.com/FghabsMrI7OO9Txu399UTQdz_U-m"></p></li><li><p>非正比相关</p><p>在笔者的观察中，财富与幸福感并非严格意义上的正相关，在某一临界点前，财富的增长对幸福值具有显著的影响，但当超过临界范围后，影响因子就会呈下降态势。由此可以看出来，过度追求财富膨胀是不理智的，但同样幸运的是我们可以调整个人的临界点获取更多的幸福感。</p><p><img src="https://image.bdwms.com/FpSmNxQng1PkUqCfgaNV3JaC7i0V"></p></li></ul><h2 id="金钱观和财务目标"><a href="#金钱观和财务目标" class="headerlink" title="金钱观和财务目标"></a>金钱观和财务目标</h2><p>人物质生活的基础（生理），人与人之间的关系（社会），人内心的欲望驱动（心理），这三者一定程度上都可以通过“钱”这样东西来体现与衡量，因此笔者更愿意将财务管理中的“钱”称作“生活的一般等价物”。而金钱就像一个放大镜，它能帮你充分地展现出你本来的样子，为此更需要保持平常心去对待。</p><p>围绕着财务管理的生活目标同样可以通过时间进行划分。笔者自身初步设定的目标如下：</p><ul><li>一年计划：理清收入支出；划分完成资产负债；了解基金投资方式。</li><li>三年规划：了解主流理财方式；积累原始资金。</li><li>十年愿景：拥有一项稳定副业；被动收入与主动收入持平。</li></ul><p>更加具体的细节不在此展开，一年之后再做复盘。笔者本身抱着稳健的态度，也同样建议没有足够资本的年轻人应该稳扎稳打为主。</p><h2 id="财务状况和消费习惯"><a href="#财务状况和消费习惯" class="headerlink" title="财务状况和消费习惯"></a>财务状况和消费习惯</h2><p>笔者认为梳理财务状况，培养正确消费习惯是年轻人最先需要关注的，很多人月光的原因就是缺乏一个输入输出的规划，形成了不良的消费习惯。</p><p>简单执行三步：</p><ol><li>记账：第一步就是学会记账。无论是手工记账，还是使用APP，都是为了掌握自己每个月的收支金额，花费种类等等。笔者使用松鼠记账已经坚持4个多月，基本掌握了自己的必要支出（房租水电等），非必要支出（娱乐电子等），主动收入，被动收入。</li><li>预算：拥有一定时间维度的数据作为参考后，就可以做预算计划了。划分出必要的生活支出，削减非必要输出，分配可用现金等等。</li><li>储蓄：需要着重强调的是储蓄，因为年轻人可动用的现金流较少，想要积累到第一笔启动资金——“下金蛋的鹅”，那么长期储蓄就是最切合实际的，工资到账的第一时间就将一部分钱转移到指定账户。</li></ol><h2 id="常见投资与重点"><a href="#常见投资与重点" class="headerlink" title="常见投资与重点"></a>常见投资与重点</h2><p>年轻人投资第一要义——<strong>投资自我</strong>。在职业生涯的前期，因为缺乏足够的资本（本金与财务知识），收益回报是很低的，所以笔者不建议花费超过30%的精力在理财上，提升专业技能，积累原始资金，适当了解基本的投资方式才是合理的规划。为此在学习了解过投资知识后，可以根据自身的财务状况，分配一定数量的资金作为试水练手。注意，缺乏了解的投资就是赌博，而赌博必输。</p><p>一些常见的投资方式：</p><p><img src="https://image.bdwms.com/FpPGqyPsSWwJnlHr0dRYgD56Gbah"></p><ul><li>债券：代表一种债权，提前约定收益，收益较低，利息不受经营的影响，风险较小。</li><li>基金：代表一种委托关系，委托专业机构帮你理财，分为多种类型的基金，收益受专业机构的理财能力影响，一般而言，收益小于股票，大于债券，相对应，风险小于股票，大于债券。</li><li>股票：代表一种股权（拥有权），享受经营的分红，收益较高，同时承担经营的风险，风险较大。</li><li>保险：保险的目的是削峰，开始时基本的五险一金就足够了，后期随着家庭形成可以逐步安排各种商业保险。</li><li>房产：需要一定的原始资金，而年轻人一般第一套都是刚需房，这里同样不展开。</li></ul><p>更高风险的项目例如期货，外汇，实体投资暂时不建议涉足。笔者目前的目标就是在第一年中专注基金项目，充分了解基金，大致分配10%到20%的流动现金来试手，收益不设硬性指标，主要目的还是专注于知识的积累。</p><p>几个值得关注的特性：</p><ul><li><p>复利：通过长期投入精力与资金，以原始资本为起点，形成滚雪球式的增长，最终达到财务自由的目标。</p></li><li><p>资产与负债：能够带来现金流的资产，消耗现金流的是负债。但是负债也不一定是糟糕的，例如在国内购置优质房产。但我们最终的目的还是通过资产带来的正向现金流覆盖消费，完成财务自由。</p></li><li><p>风险与收益：风险与收益永远应该围绕自己的人生目标去制定，不做金钱的奴隶追求赌博的快感。</p></li></ul><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>在人们眼中钱本应该是一种再自然、再普通不过的东西了，将财务管理作为生活的工具才是钱的归处。笔者在这篇文章中没有过多地阐述理财投资的执行细节，自身经验知识的不足与个体的差异化是一部分原因，但更重要地还是想要强调以人为本的理念。</p><p>希望诸君都能通过财务管理收获幸福。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/SMART%E5%8E%9F%E5%88%99">SMART原则</a></li><li><a href="https://www.zhihu.com/question/19575803/answer/859738016">个人理财有哪些基本原理和方法？ - 兴哥的回答 - 知乎</a> </li><li><a href="https://book.douban.com/subject/1095634/">《小狗钱钱》</a></li><li><a href="https://book.douban.com/subject/1033778/">《富爸爸穷爸爸》</a></li><li><a href="https://book.douban.com/subject/4249967//">《财务自由之路》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 情报库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自建情报库-医疗篇</title>
      <link href="information-database-medical-health/"/>
      <url>information-database-medical-health/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自建情报库系列是一套信息收集方法论，目的是为了帮助毕业生建立必备的知识情报体系，从而更好地迈入社会。本系列将会从住房，政策，经济，医疗等方面进行概括性的叙述，形成一条完整的知识链路，作为之后付诸行动的个人信息门户。</p></blockquote><p>根据资料显示截止2019底，中国人均预期寿命为77.3岁，如果以本科毕业22岁开始计算，那么乐观情况下笔者还有两万天左右的时间。因此为了能够更好的为祖国健康工作五十年，了解一些基本的医疗健康常识是必须的。笔者在这篇文章中会从基本的医疗健康理念谈起，之后从正式就医和家庭健康两个方面进行展开，组织梳理出一个基本的知识结构，方便读者以及笔者本人自查自纠。</p><h2 id="基本理念"><a href="#基本理念" class="headerlink" title="基本理念"></a>基本理念</h2><p>思想指导行动，没有一个统一的基本思想，我们很难组织起能够长期坚持的实际行动。笔者在这里总结了个人认为最重要的三点：</p><ul><li><p>专业性</p><p>医疗相关问题具有极强的专业性特征，所以我们必须首先明确的就是<strong>谨遵医嘱</strong>，以医生的要求为第一指示，不自我诊断，不相信偏方，不“百度看病”。</p></li><li><p>及时性</p><p>及时性指的是当身体出现不适症状时，不拖延，不怀侥幸心理，宁可信其有不可信其无。及时到医院就诊，查清自身状况，避免将小病拖成大病的惨剧发生。</p></li><li><p>长期性</p><p>强健的身体与心理不是一蹴而就，需要的是个人长期坚持健康生活。例如进行规律锻炼，良好作息，定时检查等等多方面，长期地维护培养。</p></li></ul><h2 id="就医相关"><a href="#就医相关" class="headerlink" title="就医相关"></a>就医相关</h2><p>这一部分主要涉及到基本的医院常识，不同的就医形式是如何具体执行的。注意因为各个地区医院的具体规定不同，以下仅作简单参考，详细步骤请读者自行搜索查阅有关资料。</p><h3 id="医院类别"><a href="#医院类别" class="headerlink" title="医院类别"></a>医院类别</h3><p>中国实行三级医疗服务体系，各个等级分为甲、乙两等，三级甲等为最高级别。选择医院就医时可以参考医院等级，擅长项目，挂号难度等进行综合选择。除医院外，还有为数众多的基层卫生所等机构，截止2019年末，统计数据如下图：</p><p><img src="https://image.bdwms.com/Fg2v1G0pAWSNE0r8tMW46Wv1bhkq"></p><p>目前国内的医疗资源也是处于不充足不平衡的状态，顶级资源富集在一线城市，普通人依旧是很难获取到足够的关注，这也是需要我们长期关注的问题，这里暂不展开谈论。</p><h3 id="门诊指南"><a href="#门诊指南" class="headerlink" title="门诊指南"></a>门诊指南</h3><p>针对不同地区，不同级别的医院其门诊就诊方式可能有所不同，例如浙江省第一医院，坐落于互联网较为发达的杭州，其就诊流程已经大部分电子化，一定程度上简化了流程。基本流程为：<code>办卡（就诊卡）——&gt; 挂号 ——&gt; 取号 ——&gt; 就诊区报道 ——&gt; 就诊</code>。整个过程可能存在些许不同，如现在大部分三甲医院已经支持网上预约挂号。以浙大一院为例，门诊流程如下：</p><p><img src="https://image.bdwms.com/Fg6_9SAjJW-WAXU7akIl8nhtgIdx"></p><h3 id="急诊指南"><a href="#急诊指南" class="headerlink" title="急诊指南"></a>急诊指南</h3><p>急诊一般为紧急性状况准备，大型医院一般配有急诊，情况危急下可以先抢救，后办理手续。但是需要注意的是急诊能够处理的项目没有门诊全面，能够开具的药品也是有限的，所以非紧急情况还是应该预约门诊为先。同样以浙大一院为例，流程图如下：</p><p><img src="https://image.bdwms.com/FvMCQRdJ1ML4hf_eR6QfQRnvSl4T"></p><h3 id="医保相关"><a href="#医保相关" class="headerlink" title="医保相关"></a>医保相关</h3><p>城镇职工在企业工作，一般缴纳工资的2%作为医疗保险中的个人缴纳部分，同时公司需要缴纳相应工资的6%以上作为公司部分（根据不同城市的相关规定）。如果是无工作的城镇居民或者农村新农合，不同地区也要一定的缴费标准，之后政府会在此基础上补助每个人一定的财政补贴作为医保经费。缴纳医保后，公民持有医保卡就可以到指定医院就医并报销一定的费用，并且在购买指定药品也可以使用医保消费。综上医疗保险是政府对公民的一项福利补贴行为，公民应该积极守法缴纳医保。</p><p>此外，除了上述的国家医疗保险，还有花样繁多的商业医疗保险，但是笔者不建议年轻人花费过多的时间和金钱纠结于商业保险上，其价值回报大概率会低于实际付出。</p><h2 id="家庭健康"><a href="#家庭健康" class="headerlink" title="家庭健康"></a>家庭健康</h2><p>对于家庭健康护理，主要依赖于基本的医疗常识以及良好的生活习惯，需要抱以长期坚持的心态去维护。在此笔者主要围绕三块来叙述，当然更多的知识需要在日常生活中去积累，良好的习惯也需要长久培养并不断带来正反馈。</p><h3 id="常备药品"><a href="#常备药品" class="headerlink" title="常备药品"></a>常备药品</h3><p>目前线下药店购药十分方便，并且还有互联网一小时达送药服务，所以对于家庭常备药品，只需要准备几种基本的非处方药以防不时之需。同时在用药时一定要谨慎，谨遵医嘱，仔细阅读说明书，了解副作用。这里参考丁香园给出的建议：<a href="https://dxy.com/article/2275%E3%80%82">https://dxy.com/article/2275。</a></p><h3 id="急救常识"><a href="#急救常识" class="headerlink" title="急救常识"></a>急救常识</h3><p>对于一些急救常识，笔者建议可以做一定的了解，当遇到突发情况时还是应该第一时间拨打120，个人急救措施只是为急救医生争取时间。为此一下罗列了个人认为较为重要的方面：</p><ul><li><strong>心肺复苏</strong></li><li><strong>异物卡喉（海姆立克急救法）</strong></li><li><strong>外伤出血包扎</strong></li><li>烫伤</li><li>猫狗抓咬伤</li><li>酒精中毒</li><li>扭伤骨折</li><li>癫痫</li><li>……</li></ul><p>理论知识可以通过自行搜索进行了解，但是为了更好的实践，可以考取一个急救证。急救证分为两种，一类是通过急救中心，红十字会培训的普通急救证（一般费用为200元），另一类是美国AHA心脏协会认可的急救证（一般费用为800元），同样是由急救中心等机构进行培训，不过多了一些例如烫伤，癫痫等急救知识科普。笔者已经考取了AHA急救证，但是个人建议只需要考取200元的普通急救证就足够了。</p><p><img src="https://image.bdwms.com/FlrEmSwg2KCn75qgUqU_BxBU0gck"></p><h3 id="生活习惯"><a href="#生活习惯" class="headerlink" title="生活习惯"></a>生活习惯</h3><p>个人的生活习惯因人而异，但是依旧可以提炼出基本的准则，针对不同的方面我们都可以使用同一套方法论去分析形成一个闭环。大致步骤如下：</p><ol><li>设定目标</li><li>观察自己</li><li>制定计划</li><li>复盘调整</li></ol><p>笔者以个人作息调整为例，说明是如何调整作息到最适应范围。首先明确目标，笔者因为即将正式工作，需要从大学较为散漫的作息时间（上午11点醒，晚上两点睡）调整到能够支撑个人高精力工作的良好作息。</p><p>有了一个目标后，就需要分析目标，观察自身。如何定义高精力，笔者利用为期一个星期左右的时间，对自己办公效率进行打分，半个小时划分，进行合计并计算均值，结合睡眠时长，睡眠时间区域做关联（当然还有其他因素影响例如锻炼，生病等，但是这里暂时未做考量），最后得出结论，个人最少睡眠时间约在7.5至8个小时，最晚入睡时间应该为12:30。</p><p><img src="https://image.bdwms.com/FpqQG2lbr-OH9_-Xfe20oLmadx9M"></p><p>结束观察后，笔者确定了睡眠作息计划，12:30入睡，8:30起床，午休浅睡眠半小时，实际执行后个人工作效率确实得到一定提升。但是复盘过程中也能看到一些其他问题，例如12:30应该进入浅睡眠状态，而非上床，因为真正入睡还需要半个小时左右，综合考量，最后调整为12:00上床关闭手机。</p><p>以上就是笔者如何利用这样一套方法论去调整自己的作息的，读者有兴趣可以进行尝试。</p><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>生命可贵，年轻人切勿挥霍自己的身体资本！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://news.cctv.com/2020/10/29/ARTIJC6WtEbdNGTWZeWpJNuT201029.shtml">居民人均预期寿命4年提高1岁！看看你身边的这些健康变化</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%8C%BB%E9%99%A2%E7%AD%89%E7%BA%A7">中国医院等级</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%8C%BB%E7%96%97%E4%BF%9D%E9%9A%9C">中国医疗保障</a></li><li><a href="https://www.zhihu.com/question/27579766">生活中有哪些必须知道的急救知识-知乎</a></li><li><a href="https://www.zhihu.com/question/296374184">25 岁，有哪些健康的生活习惯值得养成？-知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 情报库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自建情报库-政策篇</title>
      <link href="information-database-policy/"/>
      <url>information-database-policy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自建情报库系列是一套信息收集方法论，目的是为了帮助毕业生建立必备的知识情报体系，从而更好地迈入社会。本系列将会从住房，政策，经济，医疗等方面进行概括性的叙述，形成一条完整的知识链路，作为之后付诸行动的个人信息门户。</p></blockquote><p>中国作为一个政策导向性极强的中央集权国家，金融，教育，医疗，互联网等等不同行业很大程度上都会受到政策因素的影响，从而决定其发展方向。例如笔者所在的网络安全行业，最致命的并非某些技术性漏洞，而是监管部门的监察。所以笔者认为初入社会的年轻人需要保持一定的政治敏感性，了解与自身相关的政策。</p><p>但是因为一些客观因素，本篇文章很难做到令读者全知全解，例如：</p><ul><li>笔者自身社会经验有限。</li><li>政治政策本身客观的复杂性，时效性。</li><li>个人角度（行业，地位，年龄段等）的不同，导致对政策的不同解读。</li></ul><p>所以在本篇文章，笔者想要从初入社会的年轻人这样一个角色，来尝试回答以下几个问题：</p><ol><li>基本的国家政治体系？</li><li>如何快速搜索到与自身相关的政策信息？</li><li>如何较为准确地解读某项政策？</li></ol><h2 id="政治体系"><a href="#政治体系" class="headerlink" title="政治体系"></a>政治体系</h2><p>了解最基本的政治体系有利于从宏观角度去剖析政策，例如整个国家的战略发展都可以从<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E6%B0%91%E7%BB%8F%E6%B5%8E%E5%92%8C%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%E4%BA%94%E5%B9%B4%E8%A7%84%E5%88%92">五年计划</a>中体现，作为个体更应该顺应时代的洪流去抉择自己的方向，避免因信息差而误入夕阳产业。当然，这里仅仅罗列一些最基本的常识，更多信息可参考官方文件以及课本。</p><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><ul><li>共和国主席（虚职），一般同时兼职中国共产党中央委员会总书记和军事委员会主席（实权职位）。</li><li>两会：中华人民共和国<strong>全国人民代表大会</strong>和中国人民政治协商会议，五年一届，每年一次，制定五年计划指导国家发展，同时全国人大作为中国的权力机关。</li></ul><h3 id="党组织"><a href="#党组织" class="headerlink" title="党组织"></a>党组织</h3><p><strong>中国共产党</strong>为执政党，中国共产党全国代表大会为其最高权力机构；在中国共产党全国代表大会闭会时，由中国共产党<strong>中央委员会</strong>领导党的工作；在中央委员会全体会议和中央政治局全体会议闭会期间，<strong>中央政治局常委会</strong>行使中央政治局的职权</p><h3 id="政治组成"><a href="#政治组成" class="headerlink" title="政治组成"></a>政治组成</h3><ul><li><p>权力机关：全国人民代表大会</p></li><li><p>行政机关：权力执行机关。国务院为最高级别，然后是各个下级政府。</p></li><li><p>监察机关：监督公职人员。</p></li><li><p>司法机关：</p><ul><li>人民法院：负责审判。</li><li>检察院：负责收集证据，起诉。</li><li>公安部：负责抓捕。</li></ul></li><li><p>军事委员会：领导全国武装力量。</p></li></ul><h2 id="如何搜索"><a href="#如何搜索" class="headerlink" title="如何搜索"></a>如何搜索</h2><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><p>政策搜索的重点笔者认为有这几点：</p><ol><li>准确性：准确性指的是对政策全貌精准描述，避免只通过几句话就下定论，这样极其容易造成理解偏颇。</li><li>时效性：政策具有明显的时效限制，一段时间内政策可能会多次变化加码，所以需要我们及时更新信息库。</li><li>关联性：政策出台往往是具有极强的关联性，从不同行业，地区多方面作用来达成目标，例如近年来鼓励生育就是从多个角度进行扶持。</li></ol><p>满足以上三点后，就需要甄别信息源，从而建立自己的信息库。</p><h3 id="信息源"><a href="#信息源" class="headerlink" title="信息源"></a>信息源</h3><ol><li><p>政府官网</p><ul><li><p>国家级：<a href="http://www.gov.cn/guowuyuan/">国务院</a></p></li><li><p>省级：例如：<a href="http://www.zj.gov.cn/">浙江省人民政府</a></p></li><li><p>市级：例如：<a href="http://www.hangzhou.gov.cn/">杭州市人民政府</a></p></li><li><p>具体相关政府网站：例如<a href="http://fgj.hangzhou.gov.cn/col/col1229243551/index.html">杭州市住房保障和房产管理局</a></p></li></ul></li><li><p>先进城市，试点城市：一些先进的城市可能作为政策试点，可以一定程度上参考观察。例如上海房价政策与杭州房价政策就有很大的参考关联。</p></li><li><p>网络平台</p><ul><li><a href="http://www.bailuzhiku.com/">白鹿智库</a></li><li><a href="https://www.chacewang.com/">查册网</a></li><li>…</li></ul><p>一般需要注册花钱，不建议。</p></li></ol><h2 id="如何解读"><a href="#如何解读" class="headerlink" title="如何解读"></a>如何解读</h2><p>理解政策文件是一项复杂庞大的工程，这要求阅读人员拥有足够的相关知识储备，基本的信息敏感度，以及充分的时间，为此笔者罗列了一下几个方式：</p><ol><li><p>政府官方解读</p><p>最为严谨和客观的评价解读方式，对于某项政策发布后，一般政府都会开展相应的政策解读会，例如国务院官网<a href="http://www.gov.cn/zhengce/jiedu/index.htm">政策解读模块</a>，同样对于下级政府机构都会对政策进行相应解读。</p></li><li><p>官方媒体解读</p><p>作为政府发言机构，其解读一般较为严谨，例如紫光阁，人民日报等。</p></li><li><p>网络媒体解读</p><p>质量参差不齐，仅供参考或娱乐，需要读者掌握一定的信息筛选能力。</p></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>以十四五规划为例，截取中间的一部分，笔者简单的进行搜索和解读。</p><p>首先明确目的，五年规划作为指导国家经济和社会发展的总纲领，对于个人成长具有极强的参考价值，其中点明了未来会重点发展的行业方向。回顾过往几轮的五年规划，能够发现其聚焦的重点正是那些飞速发展的行业。例如十二五期间聚焦转型升级提高产业核心竞争力、营造环境推动服务业大发展，关键词是移动互联网，云计算，大数据等。十三五期间聚焦实施创新驱动发展战略、拓展网络经济空间，关键词为互联网+，人工智能，4g等。</p><p>通过国务院官网搜索源文件，通读目录总纲后，我们需要重点关注的就是文件中所提及的行业“热词”。以第五篇《加快数字化发展 建设数字中国》为例，总共分为四个部分：</p><ul><li>打造数字经济新优势</li><li>加快数字社会建设步伐</li><li>提高数字政府建设水平</li><li>营造良好数字生态</li></ul><p>整篇强调的依旧是一些重点项目例如人工智能，云计算，物联网，网络安全等方向，以及新添了近年较为火爆的区块链等技术。读者如果单独从概括来看，这些行业热词似乎与之前并无大的差别。实则不然，仔细对比十三五规划，两者的具体内容有很大的差别。以网络安全方向为例，从2016年国家颁布网络安全法，公安部牵头组织全国护网等一系列行动，使安全行业从之前的鱼龙混杂逐渐向正规化，程序化发展。如果说2016是让安全届的秩序从无到有，从0到1，那么在十四五期间安全行业要求将会更为严格，着重强调了隐私治理，反数据垄断等业务风险，因此作为从业者也应花费部分精力去关注这一部分。这也是上文所提及的时效性，解读政策需要使用发展的眼光。</p><p>与之类似，其他政策都需要精细考虑，确保准确性，时效性，关联性才能让政策从抽象化具象，从文字板书变行动指南。最后限于篇幅以及文章重点，十四五其他方面不在这里展开，更多总结推荐观看B站所长林超的<a href="https://www.bilibili.com/video/BV1zU4y1p7L3">解读概括</a>。</p><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>最后我们需要做的就是更多亲身实践，让思考落于实处，让自己化身为社会海洋里的鲨鱼，从丁点“血腥”中寻觅契机。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E6%94%BF%E6%B2%BB">中国政治体制-维基百科</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9B%BD%E6%B0%91%E7%BB%8F%E6%B5%8E%E5%92%8C%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%E4%BA%94%E5%B9%B4%E8%A7%84%E5%88%92">中华人民共和国国民经济和社会发展五年规划</a></p></li><li><p><a href="http://www.gov.cn/xinwen/2021-03/13/content_5592681.htm">中华人民共和国国民经济和社会发展第十四个五年规划和2035年远景目标纲要</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1zU4y1p7L3">十四五规划65000字，课代表来了！拒绝咸鱼，国家带你飞！—所长林超</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 情报库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静夜思（十八）-莫愁前路无知己</title>
      <link href="night-thoughts-18/"/>
      <url>night-thoughts-18/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在每一个深夜苦苦思索</p></blockquote><p>写于新旧年交际之时，赠诗一句以自勉，莫愁前路无知己，天下谁人不识君。</p><h2 id="回首2020"><a href="#回首2020" class="headerlink" title="回首2020"></a>回首2020</h2><p>2020的最重要的两件事，一个是在长亭实习了整整半年，另一个就是从7月开始一直到10月的秋招了。</p><h3 id="六月长亭"><a href="#六月长亭" class="headerlink" title="六月长亭"></a>六月长亭</h3><p>北京，二月寒冬，初来乍到，藏在出租屋中回炉重造自己。</p><p><img src="https://image.bdwms.com/FoF9MF0w5KmxceZCuMjGBmjWPj0I"></p><p>长亭科技，认识了很多可爱的同事，技术氛围很浓厚，大家的关系都很融洽。第一次了解了公司项目是如何研发的，第一次亲身参与到项目研发。</p><p><img src="https://image.bdwms.com/Fk696l7teLX-3UI_bIEWTQR5QbkM"></p><p>第一次来到天安门，respect。</p><p><img src="https://image.bdwms.com/FlJmIk4wdRbWN9EgAvL1Sfg2Zv03"></p><h3 id="漫漫秋招"><a href="#漫漫秋招" class="headerlink" title="漫漫秋招"></a>漫漫秋招</h3><p>从七月被字节，阿里，百度轮番挂掉怀疑人生，之后调整心态和方法，最终也算是有所收获。</p><p><img src="https://image.bdwms.com/FjZ_uUbckm2rhGsNksdMdJm7VoCh"></p><h2 id="展望2021"><a href="#展望2021" class="headerlink" title="展望2021"></a>展望2021</h2><h3 id="橙色之路"><a href="#橙色之路" class="headerlink" title="橙色之路"></a>橙色之路</h3><p>来到a厂，和长亭的感觉完全不一样，很大，有点累，很多东西需要学，期望能够未来能够快速成长。</p><p><img src="https://image.bdwms.com/FnGfKdiKR8Omf4NKsRpHwM7HpECl"></p><h3 id="自我期许"><a href="#自我期许" class="headerlink" title="自我期许"></a>自我期许</h3><p>接下的一年里，我想要给自己定一些目标，具体的实现步骤暂时不公开，等我完成后写一写</p><ul><li>了解企业安全，熟悉业务，能够独立处理工作问题。</li><li>体重控制在135，保证基本的身体健康。</li><li>熟悉杭州市，研究杭州楼市。</li><li>养一只银渐层。</li><li>拿到日语N3证。</li><li>晋升折纸熟手。</li><li>了解并尝试打造自己个人品牌。</li></ul><h2 id="幻想十年"><a href="#幻想十年" class="headerlink" title="幻想十年"></a>幻想十年</h2><p>幻想一下离开校园的我接下来会有怎样的人生，未来的十年我又会何去何从呢，我会成为一个什么样的人，我会扎根在哪一座城市，我会遇到怎样的她？我时常在幻想着这些，在与现实的不断交互中，不断地调整着目标和期望。就像国家都有五年计划，一个小小的普通人想要把日子过得更明白不是更应该多多计划么。</p><p>在工作上：</p><ul><li>第一年熟悉整个团队的运作，融入团队中，找准自己的定位以及之后发展的方向。</li><li>三年内，能够独立解决问题，成为专业熟手，在相应的领域内有一定的话语权。</li><li>五年内，成为攻坚人员，能够解决难题，形成自己的完整技术栈，方法论，培养自己带队攻坚的能力。</li><li>十年内，成为行业专家，拥有一定的行业知名度，能够从无到有构建相应的能力，做到成体系的建设输出。</li></ul><p>在自我塑造中：</p><ul><li>保证基本的身体健康，控制体重在135至140中，拥有一项坚持的运动。</li><li>保证良好的心理健康，学习并了解基本的心理学知识，对自我有足够的认知与评估。</li><li>拓展自我的兴趣爱好，保持足够的好奇心与实践能力。</li><li>拥有足够的社会经验，生活常识，能够在中国社会做到积极生活。</li></ul><p>在情感上：</p><ul><li>积极陪伴关心父母。</li><li>明确自己的交友标准和原则，维持自己的朋友圈，可以尝试从更多的圈子中拓展自己的朋友。</li><li>明确自己的择偶标准，然后针对性的去拓展交际圈（卑微码农</li></ul><p>经济上：</p><ul><li>一年内，明确自己的理财理念，熟悉自己和家庭的经济状况。</li><li>三年内，掌握基本的理财知识，形成自己的理财方法论和进行一定的实践。</li><li>五年内，熟悉个人理财的基本方法，对多种理财方式都有一定的了解，并对某几个方面拥有自己的实践经验或者运作方法。</li><li>十年内，寻求一种或多种财务副业，争取能够副业收入维持个人家庭生活，甚至做到超过主业收入。</li></ul><h2 id="今日寄语"><a href="#今日寄语" class="headerlink" title="今日寄语"></a>今日寄语</h2><p>思来想去，迟迟无法落笔，不得不感慨自己的语言功底之差，感到羞愧对自己的高中班主任，新的一年中，更加需要多学多看多想多写。纸上得来终觉浅，绝知此事要躬行，写的再多还是需要我一点一点去实践在我的生活中。大年初一的这一天，我满怀希望。</p><p>惟愿诸君一生喜乐安康！</p>]]></content>
      
      
      <categories>
          
          <category> 静夜思 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自建情报库-楼市篇</title>
      <link href="information-database-property-market/"/>
      <url>information-database-property-market/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自建情报库系列是一套信息收集方法论，目的是为了帮助毕业生建立必备的知识情报体系，从而更好地迈入社会。本系列将会从住房，政策，经济，医疗等方面进行概括性的叙述，形成一条完整的知识链路，作为之后付诸行动的个人信息门户。</p></blockquote><p>俗话说兵马未动，粮草先行，在这个信息化时代，情报就是我们出兵北上，征战社会的“粮草”。初入大学时因为缺乏主动意识，带来的巨大信息差导致错过了很多机会。为了吸取教训，弥补遗憾，即将正式迈入社会，独自生活的笔者决定新建自己的情报库，由此决定新开一个专栏。</p><p>同时因为每个人的社会背景与内在属性都是不同的，对于笔者有用的信息可能对其他人就没有参考价值。因此，为了能够提供给读者更多的参考价值，整个系列的文章尽量抽象出笔者的思考过程，做到授人以渔。</p><p>那么作为整个系列的第一篇文章，笔者想要从房产，这个年轻人的第一座大山谈起，无论你现在是否能买得起房，作为中国经济的核心命脉，房产都应该是初入社会的年轻人需要考虑的。当然因为笔者目前也是在调研进行中，所以本篇文章会随着时间推移进行修改。</p><h2 id="背景条件"><a href="#背景条件" class="headerlink" title="背景条件"></a>背景条件</h2><p>首先我们要明确，对于房地产，整个产业的复杂度不是非专业的个人能够完全弄清的，包括很多所谓的经济专家也只是信口开河，牢记没有人能预言未来走向！我们只能根据个人的条件，以点窥面，尽量优化自己的选择。</p><p>所以本篇文章的背景也是从笔者个人的角度和背景出发，思考年轻人购置第一套房需要了解什么，从而针对性地收集情报信息。从面对繁多虚假信息不知道从何下手，到能够条理清晰去梳理脉络。</p><p>而读者想要更好地进情报收集，也需要对自身的条件背景进行充分了解，包括家庭环境，职业发展，个人情感等方面，后面会进行展开说明。</p><h2 id="解析目标"><a href="#解析目标" class="headerlink" title="解析目标"></a>解析目标</h2><p>第一步，思考以下问题：</p><ol><li><p>为什么要买房？</p><p>根据房屋的属性可以分为几种：刚需房，学区房，投资房，置换房。年轻人第一个房子一般都是刚需房，作为自住使用。当然以上几个属性可能会有叠加，也会导致价格上涨乃至翻倍。</p></li><li><p>首付预算多少，还款能力多少？</p><p>决定了能不能买房，以及自己是否有偿还能力。一般普通人都会选择贷款买房，毕竟全款买房的都是土豪。国家提供给每个人一般为两次贷款机会（全国联网互通），第一次为30%，第二次为60%，这都是优质的杠杆机会，毕竟银行不是你想借钱就能借的。从过去几十年的国情来看，普通人能跑赢大盘通货膨胀的最稳定手段就是购置房产。</p></li><li><p>个人发展是否有考虑？</p><p>包括想要在哪个城市发展，职业发展是否有考虑，个人情感是否稳定。工作和婚姻稳定后，购置房产再想要更换城市的代价是很大的，必须结合好自己其他方面的发展来一同考虑。</p></li></ol><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>进一步到了本文重点，如何做信息收集，笔者经过思考和分析决定从三个角度来行动。</p><p>概括下来就是三个字：<strong>房，人，钱</strong>。下面展开来说：</p><h3 id="地区与房屋属性"><a href="#地区与房屋属性" class="headerlink" title="地区与房屋属性"></a>地区与房屋属性</h3><p>第一个关键字：房。更具体的说是从大区域到具体房屋属性进行了解，我们要做到对居住地环境了如指掌。</p><ol><li><p>市：了解全貌</p><ul><li>杭州市地图：了解行政划分，城市中心，地貌等基本因素。</li><li>杭州地铁规划图：即未来交通规划。</li><li>杭州控规图：即城市规划用地，一般在当地房产局可查阅。</li></ul></li><li><p>区域：了解区域化结构</p><ul><li><p>行政划分</p><p>作为基本参考，例如余杭区，虽然行政是一个区但是房价能一个天一个地。但是考虑到上学时，杭州又是按行政区划分。</p></li><li><p>教育划分</p><p>杭州学区划分，学区是房价能够翻倍的唯一因素，虽然好但是导致太贵了很多年轻人无法考虑。参考时注意别被开发商宣传误导欺骗，同时随着时间变化，学区也有可能改变，都要考虑到。</p></li><li><p>物理划分</p><p>交通，城市（副）中心。房子最为重要的属性就是地段，而交通就是决定地段属性好坏的重要标准，包括是否近地铁，近机场等等。除此之外，一个城市不一定越靠近地理中心越好，可能存在多个城市中心，我们都需要考虑，例如杭州的未来科技城就因为阿里在那里。</p></li></ul></li><li><p>一手房 or 二手房</p><p>一手房和二手房是两个完全不同的市场。因为国家限制调控，一手房一般都有限价，会比二手房便宜很多，但是需要摇号，很难买到。所以两者考虑的方面就有所不同，例如一手房需要考虑开发商是否正规，楼盘地段规划等等，二手房需要考虑房主是否完全持有房子，产权是否清晰，中介是否正规等。</p></li><li><p>房屋属性</p><p>到了具体的房屋属性，笔者总结分为主要的四点：</p><ul><li>大小：既由你的钱包决定，并且也有一定决定属性，例如在二手买卖时，小的房子例如两室的会比四室的好卖。</li><li>通勤：包括地铁，路况。作为自主的话肯定越近越好，靠近地铁。</li><li>配套：包括<strong>教育</strong>，医疗，生活设施。其中教育也就是学区可能是影响最大的，不过自主房可能就暂时考虑不到这个了。配套的完善度决定了生活是否方便，例如商场，超时，医院等等。</li><li>舒适性：1.户型＞2.楼层＞3.朝向＞4.得房率＞5.容积率＞6.楼栋位置＞7.物业＞8.小区体量。具体的房子样式，个人看中的因素排名。</li></ul></li></ol><p>除此之外可能个人还有很多特质化要求，比如笔者可能需要一定的易卖性，以及一定的现金流保证，就不会选择太大的户型。</p><p>根据以上这些属性从而衍生出几类房子的定义：刚需房，学区房，投资房，置换房。</p><h3 id="人与政策因素"><a href="#人与政策因素" class="headerlink" title="人与政策因素"></a>人与政策因素</h3><p>第二个关键字：人。我国是一个政策决定型国家，并且政策是多变的，我们需要时刻关注，同时也要结合个人发展来综合考量。</p><ul><li><p>外部因素：</p><ul><li><p>政策：从大到小，可以从官网来查看政策，以及房管局来看楼市政策，当然精力有限我们重点还是关注市级政策。</p><p>国际经济，国务院，浙江省，<strong>杭州市</strong></p></li><li><p>人口流动与转化定居率：看国家统计局和各种历史记录</p><p>人口流入量与转发决定了购房热度，从而影响着房价走势，可以作为一个参考因素。</p></li></ul></li><li><p>内部因素：</p><ul><li>职业发展：在当地城市是否有足够的发展空间，职级晋升等。</li><li>结婚发展：大多数时候是一锤定音的因素，例如笔者不能接受异地恋。</li></ul></li></ul><h3 id="资金"><a href="#资金" class="headerlink" title="资金"></a>资金</h3><p>第三个关键字：钱。没钱都是空头支票，加油挣钱吧，打工人~</p><ul><li><p>外部</p><ul><li>公积金政策</li><li>银行商贷政策</li></ul><p>一般公积金贷款（3.5%）会比商贷便宜（5.x%）很多，但是有上限，并且是根据公积金余额进行计算可贷款额度的，只有两次机会，所以当余额不多时一般选择商贷，避免浪费公积金贷款机会。</p></li><li><p>内部</p><ul><li>首付</li><li>月还款能力</li></ul><p>自行搜索工资计算器，房贷计算器。</p></li><li><p><strong>交付流程是否安全正规</strong></p><p>无论是一手房还是二手房都一定主要资金转账安全，合同签约是否正规，重中之重！</p></li></ul><h3 id="特殊化事件"><a href="#特殊化事件" class="headerlink" title="特殊化事件"></a>特殊化事件</h3><p>除了以上通用的三因素，每个城市和个人都会有特殊的重大事件会影响到楼市，我们都需要关注并了解，例如杭州：</p><ul><li>2022亚运会</li><li>阿里巴巴</li></ul><h2 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h2><p>以上进行的情报收集都是动态，具有一定时效性，不能僵化自己的思路，需要多打听多问，多实际跑楼盘，这也是笔者未来一年内会去做的事情，但是整体框架已经搭了起来，我们需要做的就是去实践评估，行动起来吧，少年！</p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><ul><li><a href="https://hz.ke.com/">贝壳找房</a></li><li><a href="http://fgj.hangzhou.gov.cn/">杭州市住房保障和房产管理局</a></li><li><a href="https://link.zhihu.com/?target=http://jjhygl.hzfc.gov.cn/webty/gpfy/gpfySelectlist.jsp">杭州市二手房交易监管服务平台</a></li><li><a href="https://bbs.hangzhou.com.cn/forum-207-1.html">口水楼市</a></li><li><a href="http://www.hangzhou.gov.cn/">杭州市人民政府</a></li><li><a href="http://www.zj.gov.cn/">浙江省人民政府</a></li><li><a href="http://www.gov.cn/guowuyuan/">国务院</a></li><li><a href="https://data.stats.gov.cn/">国家统计局</a> </li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>年轻人买房要注意什么？ - 土豆技师的回答-杭州二手房例子 - 知乎 <a href="https://www.zhihu.com/question/21731231/answer/1189064676">https://www.zhihu.com/question/21731231/answer/1189064676</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/142977813">2021年杭州购房政策最新版</a>   （杭州2021最新政策） </p></li><li><p><a href="https://www.shenlanbao.com/zhinan/120090210504573901">买房子需要注意什么？2020最全买房攻略来了！</a>   </p></li><li><p><a href="https://zhuanlan.zhihu.com/p/60016447">一手房VS二手房的买房攻略</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/35053921">一套有效的方法定位房价</a>  （需要查找的资料，包括政策，人口，房价走势）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 情报库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个人的秘密-端到端加密</title>
      <link href="e2ee/"/>
      <url>e2ee/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是端到端加密"><a href="#什么是端到端加密" class="headerlink" title="什么是端到端加密"></a>什么是端到端加密</h2><p>在加密网络通信中（例如TLS），可以防止攻击者破解加密报文，伪造身份。我们假设一个场景：存在两个客户端A和B，它们通过服务器S进行消息传递，从而实现通信。我们可以观察在这个过程中，客户端A与服务器S做一次消息传递，加密消息发送到服务端时会进行解密，当要发送给客户端B时，再进行一次加密然后传输，这也是常见IM的通信方式。</p><p><img src="https://image.bdwms.com/FuPdRD-5x6JDJ-twQbnhC0uNuFzn"></p><p>整个过程中，明文会存储在服务器，当攻击者攻破服务器，或者服务器本身就是恶意的，那么客户之间的通信消息就会泄漏。那么是否存在一种方式，只有通信双方能够加解密，作为传递信息的第三者（包括提供服务的运营商）无法获知明文呢？</p><p>端到端加密（End-to-end encryption，E2EE）正是为了解决这个问题所产生的。书面定义：</p><blockquote><p>是一种只有参与通讯的用户可以读取信息的通信系统。 总的来说，它可以防止潜在的窃听者——包括电信供应商、互联网服务供应商甚至是该通讯系统的提供者——获取能够用以解密通讯的密钥</p></blockquote><p><img src="https://image.bdwms.com/FsloogA_7i-1j3xjYAGESskUdDRG"></p><p>今天我就想围绕着端到端加密的设计来做分析，回答一些我认为比较关键的问题，而不仅仅是复述过程（网上很多文章只是简单介绍了该概念和流程，而没有说明为什么要这样设计），当然因为本人的能力有限，如有错误请指正。</p><h2 id="业界现状"><a href="#业界现状" class="headerlink" title="业界现状"></a>业界现状</h2><p>伴随着美国棱镜门监控事件，人们越来越看重个人隐私保护，将自己的机密通话消息托管给服务商不再可信。为此诞生了很多端到端通信的IM应用，号称能够实现只有两个人知晓的加密通信，其中主流的几个包括Telegram，Whatsapp，Skype等，能力图如下：</p><p><img src="https://image.bdwms.com/Fmt3m8FcP5srMMrRjsqKDpdwSKgZ"></p><p>而对于如何做到端到端加密，除了Telegram自己设计了一套MTProto协议（我暂时还没研究，因为它的资料不是那么全），大部分应用使用的都是Signal协议作为它们的基础。</p><p>Signal作为一个开源的协议，已经被众多安全专家肯定了它的安全性，并且Signal团队也开源了相关库和客户端，服务端代码，是值得信赖的。但是在其上实现的其他应用是否值得相信又是值得商榷的，比如Whatsapp被Facebook收购，Facebook又曾经加入过棱镜计划，并且Whatsapp本身是不开源的，虽然它宣扬自己是基于Signal实现的完全端到端加密，但是究竟如何还是耐人寻味。</p><p>以上就是端到端加密的一些背景，下面我将会介绍和分析协议中最为核心的部分，看看Signal是如何实现端到端加密通信的。</p><h2 id="Signal协议简介"><a href="#Signal协议简介" class="headerlink" title="Signal协议简介"></a>Signal协议简介</h2><p>Signal协议主要由几个部分组成，在官方文档中有四篇文章分别为：</p><ul><li><a href="https://signal.org/docs/specifications/xeddsa/">XEdDSA and VXEdDSA</a>：介绍了如何将做ECDH密钥交换的椭圆曲线，转换为可以做数字签名。</li><li><a href="https://signal.org/docs/specifications/x3dh/">X3DH</a>：将DH算法进行拓展。用于在两个客户端建立共享密钥，提供异步通信能力，身份验证（但是不防中间人，很奇怪是吧，后面我会解释），一定的前向安全性，以及可否认性。</li><li><a href="https://signal.org/docs/specifications/doubleratchet/">Double Ratchet</a>：双棘轮算法，结合了对称密钥棘轮和DH棘轮，保证了前向安全和后向安全。</li><li><a href="https://signal.org/docs/specifications/sesame/">Sesame</a>：用来做多设备多用户的同步管理。</li></ul><p>受篇幅限制，我决定挑出X3DH和Double Ratchet来做分析，个人认为这也是Signal协议中最为核心的点。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="DH类算法"><a href="#DH类算法" class="headerlink" title="DH类算法"></a>DH类算法</h3><p>Diffie–Hellman和基于椭圆曲线的Diffie–Hellman算法，用于两方进行密钥协商，详细介绍请看<a href="https://blog.csdn.net/qmickecs/article/details/76585303">离散对数和椭圆曲线加密原理</a>，简化表述：<br>第一种基于有限域上的离散对数问题：<br><strong>已知x和G，求G^x mod p是简单的；反过来已知G^x mod p和G，求x是困难的。</strong></p><p>第二种是基于椭圆曲线上的离散对数问题，即ECDH类，口语化表达类似：<br><strong>已知x和G，求xG是简单的（椭圆曲线上的运算，不是简单的数乘）；反过来已知xG和G，求x是困难的。</strong></p><p>所以一般我们把x作为私钥，xG（G^x）为公钥，使用的过程类似：</p><ol><li>服务端拥有私钥a，客户端拥有私钥b，第一次服务端发送公钥aG和参数G。</li><li>客户端接受到后计算bG，发送自己的公钥bG至服务端。</li><li>此时客户端拥有aG和b，服务端拥有bG和a，双方经过计算a(bG)=b(aG)=abG，得出相同的会话数据。</li></ol><p>此时中间人只能截获aG，bG和G，无法求出abG，因为想要求出的话记必须通过aG和G（bG和G）计算出a（b），但是从上文的条件可以看出这是困难的，由此这就是DH类算法的原理。</p><p><img src="https://image.bdwms.com/FpcwsX8mQoxRoZVp1cPJ5bMnpTFv"></p><h3 id="前向安全，后向安全"><a href="#前向安全，后向安全" class="headerlink" title="前向安全，后向安全"></a>前向安全，后向安全</h3><blockquote><p>前向安全：长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。</p><p>后向安全：长期使用的主密钥泄漏不会导致之后的会话密钥泄漏。</p></blockquote><p>通俗点说就是某个密钥泄漏不会对之前或者之后的加密消息有影响，例如在TLS中如果使用ECDHE，DHE就可以保证前向安全，因为协商的私钥都是临时生成的。</p><h2 id="Signal之X3DH协议"><a href="#Signal之X3DH协议" class="headerlink" title="Signal之X3DH协议"></a>Signal之X3DH协议</h2><h3 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h3><p>回想下端到端加密的目的，我们要实现一个只有通信双方能够加解密的过程，包括提供消息转发的服务器也不知道明文，那么服务端不会存储明文，通信的客户单A和B就需要直接协商出一个对称密钥来做加密传输，也就是说设计的协议需要提供离线<strong>异步协商对称密钥</strong>的能力。</p><p>并且为了保证通信双方的身份不与消息强绑定，协议需要提供<strong>可否认性</strong>，即两方都可以否认之间曾经存在会话，这与TLS的不可否认性正好相反，加大了第三方取证的难度。</p><p>最后为了安全性，<strong>对抗密钥泄漏</strong>可能造成的安全问题，例如前向安全，身份伪造等，协议还添加了额外的过程来做防御。</p><p>总之X3DH的最终目的就是协商出一个对称密钥，并保证上面所说的的几个特性，接下来我们来看下相关的定义概念。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>首先约定会用到的角色，密码学函数以及相关参数。</p><p>三个角色：</p><ul><li>Alice：会话的发起者。</li><li>Bob：会话的响应者。</li><li>Server：存储Alice发送给Bob的消息，以及存储一些客户端信息用于密钥协商。</li></ul><p>密码学函数：</p><ul><li>DH(PK1,PK2)：使用PK1和PK2相对应的公私钥进行ECDH的计算，生成一个共享密钥。</li><li>Sig(PK,M)：使用PK对应的私钥对M做签名，验证的时候时候用相应的公钥。</li><li>KDF(KM)：KM是包含密钥的序列，利用HKDF密钥派生函数做拓展衍生出新的密钥。</li></ul><p>会使用到的参数密钥：</p><table><thead><tr><th>Name</th><th>Definition</th></tr></thead><tbody><tr><td>IKA</td><td>Alice的身份密钥</td></tr><tr><td>EKA</td><td>Alice的临时密钥</td></tr><tr><td>IKB</td><td>Bob的身份密钥</td></tr><tr><td>SPKB</td><td>Bob的被签名预密钥</td></tr><tr><td>OPKB</td><td>Bob的一次性预密钥</td></tr></tbody></table><p>这些都是成对出现的公私钥，但是为了简化描述，我们这里只关注公钥的使用。</p><p>通信的双方都会持有一个身份密钥例如Alice的IKA，Bob的IKB。</p><p>Bob持有一个被IKB签名的预密钥SPKB，SPKB会周期性地替换。同时Bob还会有一组一次性预密钥OPKB，每发起一次X3DH协商，就会消耗一个OPKB。（之所以叫预密钥是因为SPKB和OPKB都会在Alice发起会话之前发送到服务器）</p><p>每一次发起X3DH协议，Alice都会生成一个临时密钥EKA。</p><p>经过一次X3DH密钥协商，Alice和Bob会协商出一个32字节的共享密钥SK，这个SK（或者用HKDF函数拓展这个SK）会用在后面的其他协议。</p><h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p>基本流程为三个部分：</p><ol><li>Bob将自己的IKB和prekey发送到服务端。</li><li>Alice从服务器获取一组Bob的公钥，然后使用它生成SK，之后发送初始化信息发送给Bob。</li><li>Bob接受初始化消息，并验证生成相应的SK。</li></ol><p>然后我们来看下具体的步骤，首先Bob生成相应的公私钥：</p><ul><li>Bob的身份密钥IKB</li><li>Bob的被签名预密钥SPKB</li><li>Bob的预密钥签名Sig(IKB,Encode(SPKB))，就是用IKB对SPKB做一个签名生成的信息</li><li>Bob的一组临时预密钥OPKB1，OPKB2，OPKB3…</li></ul><p>然后Bob发送这些到服务器上（Alice其实也会生成发送一组上列信息上传给服务器，但是在一次会话中只会用到Alice的身份密钥IKA），Bob会周期性地更换SPKB，并替换之前旧的SPKB，可能会继续持有一段时间SPKB的私钥以处理延时的消息，之后会删除私钥以保证前向安全（Bob同样会删除一次性预密钥的私钥当收到相应的初始化消息后）</p><p><img src="https://image.bdwms.com/Fk0ETNDhliXg1lnoYC9zWBqgb_Jm"></p><p>之后正式开始协商过程，Alice首先会向服务器请求Bob的相关信息，包括：</p><ul><li>Bob的身份公钥IKB</li><li>Bob的被签名预密钥SPKB</li><li>Bob的预密钥签名Sig(IKB,Encode(SPKB))</li><li>Bob的一次性预密钥（可选的，当服务器中还有的时候发送）</li></ul><p>然后Alice会生成一组临时密钥EKA，进行密钥计算</p><p><img src="https://image.bdwms.com/FpFG1oXDRRgK4RsEdKjX8tTIzn8G"></p><p>没有OPKB的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DH1 &#x3D; DH(IKA, SPKB)</span><br><span class="line">DH2 &#x3D; DH(EKA, IKB)</span><br><span class="line">DH3 &#x3D; DH(EKA, SPKB)</span><br><span class="line">SK &#x3D; KDF(DH1 || DH2 || DH3)</span><br></pre></td></tr></table></figure><p>有OPKB的时候，多了个DH4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DH4 &#x3D; DH(EKA, OPKB)</span><br><span class="line">SK &#x3D; KDF(DH1 || DH2 || DH3 || DH4)</span><br></pre></td></tr></table></figure><p>其中DH1和DH2提供相互认证，DH3和DH4提供前向安全，后面我会解释。</p><p>之后Alice删除EKA的私钥和中间计算的DH值，并使用身份信息计算一个“associated data”即AD，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AD &#x3D; Encode(IKA) || Encode(IKB)</span><br></pre></td></tr></table></figure><p><img src="https://image.bdwms.com/FkpAO81vOvXytc1IBD3-_ligehZB"></p><p>随后Alice发送初始化消息，包含：</p><ul><li>Alice的身份密钥IKA</li><li>Alice的临时密钥EKA</li><li>Alice使用的Bob的被签名预密钥的标志号（如果使用了OPKB，那么还有OPKB的标志号）</li><li>一段初始化文本，AEAD模式加密，其中AD作为输入的associated data，使用SK（或HKDF函数拓展SK）作为加密的密钥</li></ul><p>Bob接受初始化消息后，就能得知Alice的身份密钥，EKA所代表的临时公钥，Alice使用的SPKB和OPKB，通过相同的方式计算出SK和AD（同样计算完后删除中间的DH值），然后解密初始化文本，如果解密成功，会删除一次性密钥的私钥，保证前向安全性。</p><p><img src="https://image.bdwms.com/FnqmNz5WOFDmV1ainf1IhqDazzng"></p><p>这样子最终Alice和Bob就持有了相同的SK或由HKDF函数拓展SK的新密钥。</p><h3 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h3><p>虽然上面阐述了一遍X3DH的过程，但是想必大部分人看完后都是一头雾水。这些参数的作用是什么，为什么这样设计计算过程，这样的交换是如何实现设计目标的等等，接下来我就会结合官方文档和自己的理解进行解释。</p><ol><li><p>DH1和DH2是如何完成相互认证的，DH3和DH4如何提供前向安全的？</p><p>Bob和Alice都会上传自己的身份密钥，通过两次DH计算，即Alice通过Pri_Alice和Pub_Bob(IKB)进行计算，Bob通过Pri_Bob和Pub_Alice(IKA)进行计算，就能确保对方的确持有相应的私钥。</p><p>DH3通过EKA和SPKB进行计算，因为EKA是每次临时生成的，并且其私钥会在计算出DH结果后丢弃，所以能提供前向安全性。同理OPKB也是只使用一次，并且在计算出结果后丢弃私钥，提供更强的前向安全性。</p></li><li><p>X3DH的可否认性？</p><p>首先说明可否性指的是通信双方即Alice和Bob无法向第三方例如Carol证明两者间曾进行过会话。形象点说Alice想要举报Bob，但是Alice不能够证明给法官Carol说Alice和Bob两人间曾经通过信，就算Alice展示两者的会话消息，Bob也可以否认说这是Alice自己伪造的。</p><p>为什么呢？首先Bob的身份密钥IKB和被签名预密钥SPKB都是公开的，任何人都可以获取，因此Alice可以自己单独计算出SK，并发送给Bob初始化消息，但是此时Bob是可以选择不计算出SK的，Alice并没有显示的证据（例如TLS中Server主动的数字签名下发给客户端），所以无法证明Bob持有同样的密钥。同样因为EKA在使用完后会丢弃私钥，Bob同样无法证明Alice是持有相同的SK密钥。综上X3DH的相互认证是不可向第三方证明的，具有可否认性。</p></li><li><p>存在中间人攻击？</p><p>我们通过上面的分析，会发现一个问题：Alice和Bob在进行相互认证的时候，Bob其实只是收到了一个身份密钥，就算它成功计算出相同的SK，那又怎么证明这个身份密钥确实是Alice的呢？可能存在一个中间人David截获了Alice和Bob的对话，并替换Alice的身份密钥IKA为自己的IKD，Bob只会知道它通信的对端的确持有IKD的私钥，而无法得知对端是否为Alice。</p><p>也就是说X3DH的相互认证只能说是一个身份的绑定，而不能确保通信对端的确是真正想通信的人，这也是上面<strong>可否认性带来的必然结果</strong>，在像TLS的协议中是存在一个可信第三方进行显示证明通信双方身份的，但X3DH是不存在这样的角色。因此为了解决这个问题，在Alice和Bob建立对话后会用带外通信的方式进行身份确认IKA和IKB，例如扫二维码，比较公钥指纹等手段来避免中间人攻击。</p></li><li><p>临时预密钥有什么作用，为什么它是可选的？</p><p>笼统的说是为了前向安全性。详细点说，当不存在OPKB的时候，Bob会长期持有IKB和一定时间内持有SPKB，当攻击者攻破Bob后能拿到IKB和SPKB，并通过观察网络流量记录拿到之前的EKA，这样攻击者就能解密之前的消息了，因此当没有OPKB的时候前向安全会下降。当然OPKB被消耗完时，EKA一般会经过TLS加密，还是能保证一定程度的前向安全的，所以OPKB也不是说必须有。</p></li><li><p>为什么需要SPKB呢，SPKB为什么一定需要被IKB签名呢？</p><p>当不存在SPKB的时候，只有OPKB，如果存在攻击者恶意DDOS发起会话，会迅速消耗OPKB，当消耗完后，就无法与B正常通信了（虽然可以通过服务端进行一些限频等手段防DDOS，但还是更应该从协议层来做一定的防范）。那么为什么SPKB需要被IKB签名呢，官方文档是这么解释的，虽然看起来省略签名的步骤会提高效率，但是可能服务器是恶意的，Alice发起通信后提供给Alice的是伪造的预密钥，然后服务器恶意泄漏B的IKB就可能可以计算出SK了，从而解析Alice想要发送的信息。</p></li></ol><p>以上就是我觉得官方文档中没有解释清楚的，还有几个问题例如重放攻击，密钥泄漏危害讲的比较清楚了，可以直接参考<a href="https://signal.org/docs/specifications/x3dh/">官方文档</a>。</p><h2 id="Signal之双棘轮"><a href="#Signal之双棘轮" class="headerlink" title="Signal之双棘轮"></a>Signal之双棘轮</h2><h3 id="设计目的-1"><a href="#设计目的-1" class="headerlink" title="设计目的"></a>设计目的</h3><p>对于X3DH，保证了一定的前向安全，但是还不足够，为了在真正意义上实现前向安全和后向安全，Signal协议设计了一个双棘轮（Double Ratchet），即用对称密钥棘轮棘轮（Symmetric-key ratchet）保证前向安全，DH棘轮保证后向安全。</p><h3 id="KDF链"><a href="#KDF链" class="headerlink" title="KDF链"></a>KDF链</h3><p>KDF链是保证前向安全的核心</p><p><img src="https://image.bdwms.com/FiJ3s3vnlHhYcuVbaMUm86m-2r0H"></p><p>两个输入一个为密钥，一个是输入材料，输出切分为两部分，一部分作为下一轮的输入密钥，一部分作为本轮输出key，这样子保证了足够的前向安全，弹性，入侵恢复（<a href="https://signal.org/docs/specifications/doubleratchet/#kdf-chains">参考文档</a>）。</p><h3 id="Symmetric-key棘轮"><a href="#Symmetric-key棘轮" class="headerlink" title="Symmetric-key棘轮"></a>Symmetric-key棘轮</h3><p><img src="https://image.bdwms.com/Fj5q6pnm-ekb5E-NyGI09UQ7LO6s"></p><p>每个消息都使用唯一的message key加密，message key从chain链中导出保证了前向安全，但是因为输入的是constant所以无法保证后向安全，如果攻击者拿到了chain key就可以计算出之后的message key。在双棘轮中会有三个链分别为Root Chain，Sending Chain和Receiving Chain。</p><h3 id="DH棘轮"><a href="#DH棘轮" class="headerlink" title="DH棘轮"></a>DH棘轮</h3><p>DH棘轮保证后向安全，因为每次都会重新计算DH密钥。Bob发送公钥至Alice，Alice使用Bob的公钥Pub_B和自己的私钥Pri_A计算出一个DH1，然后Alice发送自己的公钥Pub_A，Bob结合自己的私钥Pri_A计算出相同的DH1。之后Bob生成新的密钥对，发送自己新的公钥Pub_B2，重复上面的过程，这样每一次都会计算出一个新的DH结果，保证了中间某次密钥泄漏，不会影响后面的消息加解密，这就是DH棘轮。</p><p><img src="https://image.bdwms.com/Fk4VYjCBKmc4C-F9Ly_69GIgKOVv"></p><p>然后会利用一个来回生成两组发送和接受链。</p><p><img src="https://image.bdwms.com/FkFdHpvNC0MepPUWB-qJ0KjUHI41"></p><h3 id="双棘轮的组合"><a href="#双棘轮的组合" class="headerlink" title="双棘轮的组合"></a>双棘轮的组合</h3><p>综上，通过组合以上两个棘轮就保证了前向安全和后向安全，DH棘轮生成的DH作为Root Chain的输入，来产生Sending Chain和Receiving Chain。</p><p><img src="https://image.bdwms.com/FqSh4YL63VL3QsoY5yjCWrfJVM9L"></p><p>然后看下实际的交互情况，会从Root Chain导出Sending Chain和Receiving Chain，然后Sending Chain和Receiving Chain会生成每个消息单独的message key。</p><p><img src="https://image.bdwms.com/FguqVlzdQnO4gZZoi5Mcc09j3X7l"></p><h3 id="失序处理"><a href="#失序处理" class="headerlink" title="失序处理"></a>失序处理</h3><p>当消息乱序发送时，会在消息头中维护消息序列和上一个链的长度，然后失序到达时保存未到的消息的对应的message key，例如下面B4到了B2和B3没到，头信息为N=1,Pn=2，所以可以推算出哪些没到，并保存这些消息的对应密钥。</p><p><img src="https://image.bdwms.com/FvTSBrq41uZsyEA6ykg3YSsy5P5A"></p><h3 id="X3DH结合双棘轮"><a href="#X3DH结合双棘轮" class="headerlink" title="X3DH结合双棘轮"></a>X3DH结合双棘轮</h3><p>X3DH商量的SK作为Root key，协商出的AD作为棘轮加密时用的AD，Bob的Prekey作为Bob初始棘轮公钥。X3DH的主要任务就是为了生成这个root chain的key。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上的描述我们大致了解了Signal协议是如何做到端到端加密的，真正意义上解决了第三者插入会话的问题，并且提供了可否认性，加强了前后向安全与对抗密钥泄漏。但是对于还有很多问题没有回答，比如如何做到多设备管理（Sesame），如何进行群组会话支持端到端加密（参考WhatsApp白皮书），如何做到多服务器负载均衡下的通信。同时我们要知道，就算在协议设计上没有问题，但是可能因为攻击者直接攻破接管了客户端等等类似的问题，影响到端到端通信之间的安全，所以要铭记一点：没有绝对的安全，我们只能尽量接近安全。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://faq.whatsapp.com/general/security-and-privacy/end-to-end-encryption/?lang=en">WhatsApp E2EE</a></p></li><li><p><a href="https://faq.whatsapp.com/general/security-and-privacy/end-to-end-encryption/?lang=en">WhatsApp白皮书翻译</a></p></li><li><p><a href="https://signal.org/docs/specifications/x3dh/">X3DH官方文档</a></p></li><li><p><a href="https://signal.org/docs/specifications/doubleratchet/">双棘轮官方文档</a></p></li><li><p><a href="https://blog.csdn.net/qmickecs/article/details/76585303">离散对数和椭圆曲线加密原理</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从TLS看安全协议设计（下）</title>
      <link href="TLS-design-part-two/"/>
      <url>TLS-design-part-two/</url>
      
        <content type="html"><![CDATA[<p>TLS1.3作为升级的版本，根据需求主要是在两个方面做了整改，一个是安全方面，一个就是性能，下面我们就来看一下。</p><h2 id="升级之处"><a href="#升级之处" class="headerlink" title="升级之处"></a>升级之处</h2><p>安全：</p><ul><li>删除了不安全的密码组件，例如MD5。</li><li>为了前向安全性，密钥协商过程不再使用RSA和静态DH，ECDH，只选用DHE或者ECDHE。</li><li>设计了新的密钥派生函数HKDF代替了PRF函数。</li><li>记录层进行加密和MAC时固定为AEAD模式。</li></ul><p>性能：</p><ul><li>重新设计了握手层流程，让冷启动从2RTT变化1RTT。</li><li>设计了PSK会话恢复机制代替了原来的Session会话恢复机制。</li><li>0-RTT</li></ul><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>对于TLS1.3的流程如下，最主要分为两种方式，一种是基于key_share和signature_algorithms来选择加密的算法，另一种是基于预共享密钥PSK的会话恢复。</p><h3 id="握手层冷启动"><a href="#握手层冷启动" class="headerlink" title="握手层冷启动"></a>握手层冷启动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Key  ^ ClientHello</span><br><span class="line">Exch | + key_share*</span><br><span class="line">     | + signature_algorithms*</span><br><span class="line">     | + psk_key_exchange_modes*</span><br><span class="line">     v + pre_shared_key*       --------&gt;</span><br><span class="line">                                                  ServerHello  ^ Key</span><br><span class="line">                                                 + key_share*  | Exch</span><br><span class="line">                                            + pre_shared_key*  v</span><br><span class="line">                                        &#123;EncryptedExtensions&#125;  ^  Server</span><br><span class="line">                                        &#123;CertificateRequest*&#125;  v  Params</span><br><span class="line">                                               &#123;Certificate*&#125;  ^</span><br><span class="line">                                         &#123;CertificateVerify*&#125;  | Auth</span><br><span class="line">                                                   &#123;Finished&#125;  v</span><br><span class="line">                               &lt;--------  [Application Data*]</span><br><span class="line">     ^ &#123;Certificate*&#125;</span><br><span class="line">Auth | &#123;CertificateVerify*&#125;</span><br><span class="line">     v &#123;Finished&#125;              --------&gt;</span><br><span class="line">                                                     &lt;--------  [NewSessionTicket]</span><br><span class="line">       [Application Data]      &lt;-------&gt;  [Application Data]</span><br></pre></td></tr></table></figure><p>我们首先来看第一种</p><ol><li>客户端发送ClinetHello，在key_share和signature_algorithms中声明自己支持的DHE或者ECDHE算法类型对应的具体参数。</li><li>服务端返回ServerHello，选择自己支持的算法和自己的参数。</li><li>服务端发送EncryptedExtensions，包含不需要建立加密上下文并且和证书无关的拓展。注意从本条消息开始都会被加密传输。</li><li>如果想要验证客户端认证，服务端就会发送CertificateRequest消息。</li><li>服务端发送Certificate消息，包含自己的证书。</li><li>服务端发送CertificateVerify消息。对之前握手的消息做Hash后用证书私钥进行签名，进行显示认证表明自己持有证书私钥。</li><li>服务端发送Finished消息对之前握手消息做校验，以及验证协商密钥的正确性。</li><li>此时服务端已经可以发送加密的应用数据了。</li><li>如果需要客户端验证，就会发送客户端Certificate消息。</li><li>如果客户端发送了Certificate消息，就会发送CertificateVerify来表明客户端持有证书私钥。</li><li>客户端同样发送Finished消息，进行校验。</li><li>客户端可以发送加密的应用消息。</li></ol><p>我们观察整个流程，冷启动仅需要1-RTT。因为在ClientHello时已经携带了DHE（ECDHE）的参数，让第一次握手有更多的作用。这也是因为在密钥协商时抛弃了RSA算法，因为对于RSA需要服务端先下发公钥，所以需要至少2-RTT。</p><h3 id="握手层热启动"><a href="#握手层热启动" class="headerlink" title="握手层热启动"></a>握手层热启动</h3><p>我们再看一下会话恢复的情况。对于1.3使用的是PSK机制，其中PSK可以从上次握手时生成，或者由使用者预置。</p><p>看一下流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ClientHello</span><br><span class="line">    + key_share*</span><br><span class="line">    + pre_shared_key          --------&gt;</span><br><span class="line">                                                    ServerHello</span><br><span class="line">                                               + pre_shared_key</span><br><span class="line">                                                   + key_share*</span><br><span class="line">                                          &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                     &#123;Finished&#125;</span><br><span class="line">                              &lt;--------     [Application Data*]</span><br><span class="line">    &#123;Finished&#125;                --------&gt;</span><br><span class="line">    [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line">    +表示携带的参数，*表示可选</span><br></pre></td></tr></table></figure><p>客户端携带PSK发送给服务端，服务端如果接受就返回ServerHello，以及加密的EncryptedExtensions，Finished消息。之后两者就能进行应用数据传输，整个流程需要一个1-RTT。</p><h3 id="记录层"><a href="#记录层" class="headerlink" title="记录层"></a>记录层</h3><p>流程为数据分段，填充（为了隐藏流量），加密和完整性保护（AEAD），添加消息头。</p><p>与1.2最主要的不同就是抛弃的块模式和流模式，固定为AEAD，并对AEAD做了一些调整，这里就不展开说了。</p><h2 id="变化分析"><a href="#变化分析" class="headerlink" title="变化分析"></a>变化分析</h2><h3 id="HKDF密钥派生函数"><a href="#HKDF密钥派生函数" class="headerlink" title="HKDF密钥派生函数"></a>HKDF密钥派生函数</h3><p>1.3重新设计了密钥派生函数，对于HKDF函数分为Extract和Expand过程，Extract过程增加密钥材料的随机性,Expand进行拓展，在1.2中PRF函数只有Expand的过程，它默认密钥材料的随机性是足够的，然而这是不一定的可能ECC协商出来的随机分布是不够均匀的。</p><p>Extract过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Extract(salt, IKM) -&gt; PRK</span><br><span class="line">salt盐可选，没有时用<span class="number">0</span>填充HashLen长度</span><br><span class="line">IKM：Input Keying Material</span><br><span class="line">PRK: 生成的伪随机key</span><br><span class="line"></span><br><span class="line">PRK = HMAC-Hash(salt, IKM)      </span><br></pre></td></tr></table></figure><p>Expand过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Expand(PRK, info, L) -&gt; OKM</span><br><span class="line">PRK伪随机key</span><br><span class="line">info可选一般标志上下文信息</span><br><span class="line">L期望输出的字节数</span><br><span class="line"></span><br><span class="line"> OKM生成方式：</span><br><span class="line"> N = <span class="built_in">ceil</span>(L/HashLen)</span><br><span class="line"> T = T(<span class="number">1</span>) | T(<span class="number">2</span>) | T(<span class="number">3</span>) | ... | T(N)</span><br><span class="line"> OKM = first L octets of T</span><br><span class="line"></span><br><span class="line"> where:</span><br><span class="line"> T(<span class="number">0</span>) = empty <span class="built_in">string</span> (zero length)</span><br><span class="line"> T(<span class="number">1</span>) = HMAC-Hash(PRK, T(<span class="number">0</span>) | info | <span class="number">0x01</span>)</span><br><span class="line"> T(<span class="number">2</span>) = HMAC-Hash(PRK, T(<span class="number">1</span>) | info | <span class="number">0x02</span>)</span><br><span class="line"> T(<span class="number">3</span>) = HMAC-Hash(PRK, T(<span class="number">2</span>) | info | <span class="number">0x03</span>)</span><br><span class="line"> ...   </span><br></pre></td></tr></table></figure><p>以及最终使用的Derive-Secret函数与Expand所对应的关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Expand-Label(Secret, Label, Context, Length) =</span><br><span class="line">            HKDF-Expand(Secret, HkdfLabel, Length)</span><br><span class="line"></span><br><span class="line">Where HkdfLabel is specified as:</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">  uint16 length = Length;</span><br><span class="line">  opaque label&lt;<span class="number">7.</span><span class="number">.255</span>&gt; = <span class="string">&quot;tls13 &quot;</span> + Label;</span><br><span class="line">  opaque context&lt;<span class="number">0.</span><span class="number">.255</span>&gt; = Context;</span><br><span class="line">&#125; HkdfLabel;</span><br><span class="line"></span><br><span class="line">Derive-Secret(Secret, Label, Messages) =</span><br><span class="line">  HKDF-Expand-Label(Secret, Label,</span><br><span class="line">       Transcript-Hash(Messages), Hash.length)</span><br><span class="line">  </span><br><span class="line">Transcript-Hash级联握手消息做Hash运算</span><br></pre></td></tr></table></figure><h3 id="密钥变化"><a href="#密钥变化" class="headerlink" title="密钥变化"></a>密钥变化</h3><p>1.3对于密钥做了更加详细的分类，在每一个使用部分的密钥实际上都是不同的，都会通过HKDF函数做变化，这也是密码学上的安全要求，一个密钥只使用在一种功能上。</p><p>一次握手的密钥变化如下，很复杂，可以只大概了解下有什么密钥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">0</span></span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line">PSK -&gt;  HKDF-Extract = Early Secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;ext binder&quot;</span> | <span class="string">&quot;res binder&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">          |                     = binder_key</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;c e traffic&quot;</span>, ClientHello)</span><br><span class="line">          |                     = client_early_traffic_secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;e exp master&quot;</span>, ClientHello)</span><br><span class="line">          |                     = early_exporter_master_secret</span><br><span class="line">          v</span><br><span class="line">    Derive-Secret(., <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line">(EC)DHE -&gt; HKDF-Extract = Handshake Secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;c hs traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...ServerHello)</span><br><span class="line">          |                     = client_handshake_traffic_secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;s hs traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...ServerHello)</span><br><span class="line">          |                     = server_handshake_traffic_secret</span><br><span class="line">          v</span><br><span class="line">    Derive-Secret(., <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line"><span class="number">0</span> -&gt; HKDF-Extract = Master Secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;c ap traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...server Finished)</span><br><span class="line">          |                     = client_application_traffic_secret_0</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;s ap traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...server Finished)</span><br><span class="line">          |                     = server_application_traffic_secret_0</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;exp master&quot;</span>,</span><br><span class="line">          |                     ClientHello...server Finished)</span><br><span class="line">          |                     = exporter_master_secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;res master&quot;</span>,</span><br><span class="line">                                ClientHello...client Finished)</span><br><span class="line">                                = resumption_master_secret</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ol><li>HKDF-Extract 画在图上，它为从顶部获取 Salt 参数，从左侧获取 IKM 参数，它的输出是底部，和右侧输出的名称。</li><li>Derive-Secret 的 Secret 参数由传入的箭头指示。例如，Early Secret 是生成 client_early_traffic_secret 的 Secret。</li><li>“0” 表示将 Hash.length 字节的字符串设置为零。</li></ol><p>其中有三个Secret，是从Extract中得来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Early Secret = HKDF-Extract(salt, IKM) = HKDF-Extract(<span class="number">0</span>, PSK) (有PSK的情况)= HKDF-Extract(<span class="number">0</span>,<span class="number">0</span>) （没有PSK的情况）</span><br><span class="line">                                          </span><br><span class="line">Handshake Secret = HKDF-Extract(salt, IKM) = HKDF-Extract(Derive-Secret(Early Secret, <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>), (EC)DHE)</span><br><span class="line"></span><br><span class="line">Master Secret = HKDF-Extract(salt, IKM) = HKDF-Extract(Derive-Secret(Handshake Secret, <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>八个可能用到的密钥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client_early_traffic_secret = Derive-Secret(Early Secret, <span class="string">&quot;c e traffic&quot;</span>, ClientHello)</span><br><span class="line">early_exporter_master_secret = Derive-Secret(Early Secret, <span class="string">&quot;e exp master&quot;</span>, ClientHello)</span><br><span class="line"></span><br><span class="line">client_handshake_traffic_secret = Derive-Secret(Handshake Secret, <span class="string">&quot;c hs traffic&quot;</span>, ClientHello...ServerHello)</span><br><span class="line">server_handshake_traffic_secret = Derive-Secret(Handshake Secret, <span class="string">&quot;s hs traffic&quot;</span>, ClientHello...ServerHello)</span><br><span class="line"></span><br><span class="line">client_application_traffic_secret_0 = Derive-Secret(Master Secret, <span class="string">&quot;c ap traffic&quot;</span>, ClientHello...server Finished)</span><br><span class="line">server_application_traffic_secret_0 = Derive-Secret(Master Secret, <span class="string">&quot;s ap traffic&quot;</span>, ClientHello...server Finished)</span><br><span class="line"></span><br><span class="line">exporter_master_secret = Derive-Secret(Master Secret, <span class="string">&quot;exp master&quot;</span>, ClientHello...server Finished)</span><br><span class="line">resumption_master_secret = Derive-Secret(Master Secret, <span class="string">&quot;res master&quot;</span>, ClientHello...client Finished)</span><br></pre></td></tr></table></figure><ol><li>early_exporter_master_secret和exporter_master_secre导出密钥，用户可以自定义使用方式。</li><li>resumption_master_secret用于会话恢复。</li><li>client_early_traffic_secret用于加密early_data，在0-RTT模式中使用。</li><li>client_handshake_traffic_secret和server_handshake_traffic_secret用于握手时的加密。</li><li>client_application_traffic_secret_0和server_application_traffic_secret_0用于加密应用流量数据。</li></ol><p>3，4，5的密钥想要加密数据还需要一次Expand过程生成write_key和iv来作为真正加密数据的密钥，生成方式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sender]_write_key = HKDF-Expand-Label(Secret, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;&quot;</span>, key_length)</span><br><span class="line">[sender]_write_iv  = HKDF-Expand-Label(Secret, <span class="string">&quot;iv&quot;</span>, <span class="string">&quot;&quot;</span>, iv_length)</span><br></pre></td></tr></table></figure><h3 id="PSK会话恢复机制"><a href="#PSK会话恢复机制" class="headerlink" title="PSK会话恢复机制"></a>PSK会话恢复机制</h3><p>1.3中使用PSK机制代替了Session机制，那么PSK是如何生成并使用的？</p><p>先看下Server发送的NewSessionTicket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">          uint32 ticket_lifetime;</span><br><span class="line">          uint32 ticket_age_add;</span><br><span class="line">          opaque ticket_nonce&lt;<span class="number">0.</span><span class="number">.255</span>&gt;;</span><br><span class="line">          opaque ticket&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">          Extension extensions&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-2</span>&gt;;</span><br><span class="line">      &#125; NewSessionTicket;</span><br></pre></td></tr></table></figure><p>其中ticket的值是从上一节提到的resumptition_master_secret中计算出来的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PskIdentity.identity = ticket </span><br><span class="line">                          = HKDF-Expand-Label(resumption_master_secret, <span class="string">&quot;resumption&quot;</span>, ticket_nonce, Hash.length)</span><br></pre></td></tr></table></figure><p>客户端接受到NewSessionTicket后会计算一个binder值，Truncate会取出ClientHello1中的binder_list，避免陷入无限循环。利用这个值来绑定上下文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PskBinderEntry = HMAC(binder_key, Transcript-Hash(Truncate(ClientHello1)))</span><br><span class="line">                   = HMAC(Derive-Secret(HKDF-Extract(<span class="number">0</span>, PSK), <span class="string">&quot;ext binder&quot;</span> | <span class="string">&quot;res binder&quot;</span>, <span class="string">&quot;&quot;</span>), Transcript-Hash(Truncate(ClientHello1)))</span><br><span class="line"></span><br><span class="line">其中binder_key = Derive-Secret(HKDF-Extract(<span class="number">0</span>, PSK), <span class="string">&quot;ext binder&quot;</span> | <span class="string">&quot;res binder&quot;</span>, <span class="string">&quot;&quot;</span>)                   </span><br></pre></td></tr></table></figure><p>然后Client在会话恢复时将identity和binder包含在ClientHello的拓展中发送给Server，Server再验证binder的完整性，比对identity，选择是否接受PSK，从而生成新的handshake_traffic和application密钥进行会话恢复。</p><p>可以看到如果仅仅是这样的会话恢复，相对于1.2来说只是更安全（因为不再使用master_secret做传递，而是利用HKDF派生），性能上没有大的提升，所以就会涉及到下面的0-RTT。</p><h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h3><p>对于TLS1.3还有一个很大的变化，那就是0-RTT模式。什么是0-RTT呢，就是基于PSK会话恢复时，PSK会作为Early Secret的IKM，然后从Early Secret生成client_early_traffic_secret，再由client_early_traffic_secret生成key和iv用来加密0-RTT发送的early_data。Client在ClientHello中携带early_data拓展选项，并发送由client_early_traffic_secret加密的数据，如果服务端接受early_data，那么就成功完成了0-RTT传输。</p><p>但是0-RTT为了效率降低了安全性，存在重放问题，因为在客户端发送early_data时，只有客户端参数决定，服务端没有参与到其中，那么中间人就可以截获这个ClientHello包以及加密数据，而服务端每次都能成功解析这个包，中间人就可以进行重放ddos或者重复敏感操作。除了这种最简单的重放，还有针对分布式系统的重放攻击，这里就不展开说了。</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>通过上面的分析，我们可以看出TLS具有极强的通用性与可拓展性，但是针对一些具体的使用场景能否进行特殊化的改造，这里我们以微信mmtls作为例子来分析下。我们回顾TLS的过程，身份认证的过程是采用建立PKI体系，做到全球的通用性，但是针对完全可控的微信程序，可以直接将签名的公钥预埋在客户端中，这样就不用建立或者申请证书，通过强制更新客户端，来做公钥的维护，这样就很大程度简略的流程并提升了效率。</p><p>还有针对0-RTT的问题，对于TLS1.3本身协议上来说是无解的，更多的只能从应用层来做缓解，例如cloudflare针对0-RTT将禁止非幂等的操作像POST，PUT，只允许不带参数的GET请求。mmtls也是根据这些应用行为，有选择性的使用0-RTT模式，例如只在端连接使用。chrome甚至选择不解决0-RTT重放，因为大部分浏览器的操作都是GET先，安全性交由其他方面来做。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个TLS完成了密码学上的安全，并结合了软件工程的理念，做到了分层抽象，模块化等等优秀的设计，在通用性上也确保了更多的场景能够被覆盖，提升了互联网的安全性，基本完成了它的设计目标。</p><p>当然作为使用者，当我们自己在设计（魔改）安全协议的时候，依然需要小心谨慎，密码学的快速发展已经让大部分程序员很难理解其原理，甚至正确使用密码学黑盒工具也是困难的，所以我们更需要的是怀着严谨的态度去使用密码学工具，紧跟主流，避免陷入闭门造车的困境。还有根据本身的应用场景我们是否能够吸取TLS的精华，结合自己的业务需求去做特质化，省略一些臃肿的包袱，做到定制优化都是可以考虑的。</p><p>TLS中的奥义远远不止我所阐述的，短短两篇文章也不能尽善尽美地描绘，希望能够对每一个读者有所帮助，更加有条理地理解其奥义。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tools.ietf.org/html/rfc5246">TLS1.2 RFC</a></li><li><a href="https://halfrost.com/">冰霜之地</a></li><li><a href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/">TLS协议分析 与 现代加密通信协议设计</a></li><li><a href="https://blog.shell909090.org/blog/archives/2873/">安全协议的设计</a></li><li><a href="https://cloud.tencent.com/developer/article/1005518">微信mmtls</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从TLS看安全协议设计（上）</title>
      <link href="TLS-design-part-one/"/>
      <url>TLS-design-part-one/</url>
      
        <content type="html"><![CDATA[<p>在开始正文前，我想先谈谈为什么要写这篇文章，为什么要对TLS协议进行分析？</p><p>打开网站时我们经常能看到左上角的小绿锁，而TLS正是隐藏在后面的原由。对于大部分程序员，多多少少都可以聊一聊TLS的几分样貌，但是能真正的从其整体发散到细节，从理念落地到实践，以更高的角度去理解TLS是很少的。因此这里想要从我个人的角度，去理清TLS，解读这个将密码科学和软件工程良好结合的优秀设计，也希望能够给读者有所帮助。</p><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><h3 id="为什么需要TLS"><a href="#为什么需要TLS" class="headerlink" title="为什么需要TLS?"></a>为什么需要TLS?</h3><p>在不存在SSL/TLS的互联网中，消息通过例如HTTP明文传递，作为一个攻击者可以截获任意的包，那么他就可以获取报文中的信息，并对报文进行修改，伪装成对端进行窃听或者控制传输。</p><p>在上文的描述中，我们可以看出明文传输存在的最显著问题：数据没有加密，消息易被篡改，身份能被伪造。这也对应着信息安全中的<strong>机密性</strong>，<strong>完整性</strong>，<strong>身份认证</strong>。</p><p>除了这三个最明显的问题，还有其他很多待解决的问题，例如如何确保用户不能抵赖之前发送的消息，即<strong>不可否认性</strong>；如何在设计时，降低所需的传输时间，提升<strong>性能</strong>；如何做到协议的<strong>通用性</strong>和<strong>可拓展性</strong>。这一系列的问题缺乏一个统一的解决方案，很多情况下仅是通过应用层的一些手段去不完善的处理，这些需求也就促成了SSL/TLS的诞生与发展。</p><p>围绕着这些需求，从90年代SSL1.0设计之初，一直走到了08年TLS1.2版本正式发布，整个协议才趋于成熟，又伴随着安全研究的升级对抗以及对性能提升的要求，1.3版本也在几年的商讨中于18年诞生。而这几年业界也是逐渐从1.2版本向1.3升级。当然因为历史遗留原因目前主流的还是1.2版本，因此我的分析也将从1.2版本开始，再迈向1.3，为读者浅析TLS的前世今生。</p><p><img src="https://image.bdwms.com/FvB5KJRP8BMLJtatrdl8yHLHZFKZ"></p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>在阅读这一部分时，可以不先完全理解其细节，在浏览后面章节必要时，再返回本章进行对照理解。</p><p>因为TLS是建立在密码学之上的协议，想要将TLS理解清楚，对密码学应有一定了解，但是具体深入密码学的细节不是本文重点所在，所以我简单归纳了几个需要了解的点和一些特性，实现细节的话请参看所给资料链接或自行搜索。</p><h3 id="密码学基本工具"><a href="#密码学基本工具" class="headerlink" title="密码学基本工具"></a>密码学基本工具</h3><ul><li>对称加密：加密和解密时使用同一密钥，常用有AES，(DES,RC4等都被证明不安全了)，然后还涉及到加密模式，例如流式加密（RC4使用的就是流式）,块加密模式（CBC等模式）。<strong>加解密效率高，密钥配送管理不便</strong>。</li><li>非对称加密：公私钥体系。常见的有RSA（基于大整数的质因数分解难题）和ECC（基于椭圆曲线上的离散对数难题）,以及DH（基于有限域上的离散对数难题），后两者在使用过程中类似一个协商，而RSA更类似一个单方面的加密传输过程。<strong>加解密效率低，密钥派发管理方便</strong>。</li><li>单向散列函数：输入消息不同，输出Hash值不同，保证消息的<strong>一致性</strong>，<strong>完整性</strong>。</li><li>消息认证码MAC：比单项散列函数多了个共享秘钥，保证消息的<strong>一致性</strong>，<strong>完整性</strong>，并且通过密钥加解密确保<strong>身份认证</strong>。但是因为使用的是共享秘钥不能“第三方证明”和“防抵赖”。</li><li>数字签名：利用私钥对hash值签名，公钥认证。保证消息的<strong>一致性</strong>，<strong>完整性</strong>，<strong>认证</strong>，并且能<strong>防止抵赖</strong>。</li><li>伪随机数生成器：模拟产生随机数列的算法。</li></ul><p>以上就是常用的密码学工具，在接下来的流程中会分别涉及到，如果对相关的工具有困惑可以自行查阅资料。</p><h3 id="RSA-ECC-DH"><a href="#RSA-ECC-DH" class="headerlink" title="RSA ECC DH"></a>RSA ECC DH</h3><p>这里想要对最常用的非对称加密算法做个简单的介绍，因为后面讲解时会利用到其特性。</p><p>对于常用的非对称加密算法，可以简单的分为两种类型，一种是基于RSA，一种是类DH（包括原生的DH和基于ECC的DH，即ECDH），简单来看一下两者的使用和区别。</p><ul><li><p>RSA</p><p>基于大整数进行质因数分解的困难，具体原理可以看阮一峰的<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">《RSA算法原理》</a>，这里说下使用方法：</p><p>存在一对公私钥：公钥(E,N)，私钥(D,N)，明文加密和密文解密类似下列的运算</p><p>密文 = 明文^E mod N   </p><p>明文 = 密文^D mod N  </p><p>使用的过程类似：</p><p>服务端下发公钥给客户端，客户端利用公钥加密一段会话数据后返回给服务端，服务端利用自己的私钥进行解密。</p><p><img src="https://image.bdwms.com/FgWFJLCGyoonFMeoZxHodhv6io3d"></p></li><li><p>DH（ECDH）</p><p>分为两种，一种是基于有限域上的离散对数问题，即DH类（Diffie-Hellman），具体原理自行搜索，这里只做口语化表达：</p><p><strong>已知x和G，求G^x mod p是简单的；反过来已知G^x mod p和G，求x是困难的。</strong></p><p>第二种是基于椭圆曲线上的离散对数问题，即ECDH类，口语化表达类似：</p><p><strong>已知x和G，求xG是简单的（椭圆曲线上的运算，不是简单的数乘）；反过来已知xG和G，求x是困难的。</strong></p><p>所以一般我们把x作为私钥，xG（G^x）为公钥</p><p>使用的过程类似：</p><p>服务端拥有私钥a，客户端拥有私钥b，第一次服务端发送公钥aG和参数G，客户端接受到后计算bG，发送给服务端，此时客户端拥有aG和b，服务端拥有bG和a，双方经过计算a(bG)=b(aG)=abG，得出相同的会话数据，但此时中间人只能截获aG，bG和G，无法求出abG，因为想要求出的话记必须通过aG和G（bG和G）计算出a（b），但是从上文的条件可以看出这是困难的，由此这就是DH类的原理。</p><p><img src="https://image.bdwms.com/FpcwsX8mQoxRoZVp1cPJ5bMnpTFv"></p></li></ul><p>我们通过以上的简介不难发现一点，两类算法最大的区别就是RSA做加密传输的时候，整个的会话数据是由客户端决定的，而服务端没有参与到生成的过程，更类似于一个<strong>加密传输</strong>的过程。而DH类客户端和服务端双方都需要参与到生成的过程中，单方面是无法决定会话数据的，也就是说相较于RSA，DH（ECDH）更类似一个<strong>密钥协商</strong>的过程。</p><p>针对上面的特性，也就衍生出下一个需要关注问题——前向安全，这也是为什么TLS1.3会抛弃RSA作为密钥协商的算法。</p><h3 id="前向安全"><a href="#前向安全" class="headerlink" title="前向安全"></a>前向安全</h3><p>官方定义是：长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。简单点来说就是我的长期持有的私钥泄漏了不会对之前的会话消息造成影响，那么对于上述两种算法，其又有什么不同呢？</p><p>显然，对于RSA来说，如果我们一直使用同一对公私钥，当私钥泄漏时，攻击者就可以轻易解密之前的会话消息，也就是说RSA时不具有前向安全的。不可能每次会话都更新RSA公私钥，因为每次更新下发公钥是不现实的，效率太低了，不可接受。</p><p>对于DH（ECDH），如果双方每次通话的私钥a，b都是固定的，那么生成的abG也是固定的，如果泄漏，也无法保证前向安全。但是我们可以通过每次会话时都利用随机数发生器生成临时的a和b（这个效率是可接受的），这样每次计算出来的结果都不一样，这就保证了前向安全，这也就是DHE和ECDHE，其中E表示的就是临时的意思。</p><p>基于上述拥有的密码学工具，以及相应的设计目的和需求，我们应该怎么设计呢，假如你是一个协议开发者，你如何协调使用好所拥有的能力，完成一个精巧的架构呢？让我们先来看看TLS是如何操作的，由全局到细节，由问题推方法，我们来细细品味。</p><h2 id="协议架构"><a href="#协议架构" class="headerlink" title="协议架构"></a>协议架构</h2><p>TLS1.2主要分为两个层级，上层的握手层（以及一些辅助协议，例如密钥切换通知，告警协议）和下层的记录层。</p><p><img src="https://image.bdwms.com/FrxN1tlsNbsfyfNbH4sQ9fZgAGwx"></p><p>首先为什么TLS会设计成分层架构呢？最主要的原因就是公钥加密算法和对称加密算法的优劣性。当使用对称密钥的方式进行加密时，双方持有相同密钥，根据选定算法对信息加密，然后传输给对端进行解密。整个加解密的过程建立在双方持有相同的密钥，但是对于互联网多方交互的环境下，是不可能做到服务端与每个客户端直接持有一个对称密钥的，无论是维护密钥的成本，还是密钥派发时的安全保证，都是不可接受的。</p><p>因此为了解决密钥的派发管理问题，一般是采用公钥加密的方式，服务端将公钥派发出去，客户端利用公钥加密信息后返回给服务端，服务端再用自己的私钥进行解密。但是在真正设计时并没有选择完全使用两端采用公钥加密的方式进行加密沟通，因为公钥加解密的速度是非常慢的。</p><p>综合以上两点，TLS分为两层，握手层采用公钥加密的方式协商一段数据作为加密素材，传递给记录层做为对称加密的密钥材料，记录层生成对称密钥加密应用数据，既解决了密钥管理的问题，也保证了效率。同时这也有利于解耦各种需求，并化简整个问题的复杂度，将TLS分层模块化，每一部分完成一定的需求，并让之后的升级更新更加方便。</p><h2 id="推演思路"><a href="#推演思路" class="headerlink" title="推演思路"></a>推演思路</h2><p>了解了TLS最基本的架构后我们按照握手层和记录层的顺序进行推理分析，由需求得出方案，再根据连贯的问题，补充完善之前的方案。</p><h3 id="握手层"><a href="#握手层" class="headerlink" title="握手层"></a>握手层</h3><p>先从握手从来看，对于握手层，需要完成的最基本需求是利用非对称加密完成“材料”数据的传输，如客户端C向服务端S发送会话请求，服务端同意后下发自己的公钥S_Pub，客户端利用公钥加密数据Data传输给服务端，服务端利用自己的私钥S_Pri解密，得到数据。</p><p>但是以上步骤存在一个问题就是假设存在一个可以截取数据的中间人，是无法保证对端身份可信的。例如下图中间人M截获S_Pub，替换为自己的公钥M_Pub，客户端使用M_Pub作为公钥加密后发送数据，中间人能用自己的M_Pri解密并修改数据，再用S_Pub加密后发送给服务端，从而造成中间人攻击。</p><p><img src="https://image.bdwms.com/FvHsGjuxiuWLnIXz04eK4pLkoOm4"></p><p>之所以产生这个问题是因为缺乏身份认证，解决身份认证问题一般是利用消息认证码MAC或数字签名。对于消息认证码需要对称密钥，此时还不存在所以选用数字签名进行认证。假设数字签名的公私钥对位Sign_Pub和Sign_Pri，利用Sign_Pri对S_Pub进行数字签名，客户端利用Sign_Pub对数字签名进行认证（中间人是无法阻止客户端获取到Sign_Pub的）。</p><p>但是又如何确保数字签名的公钥是可信的呢？TLS给出的方案就是PKI证书体系，建立可信第三方CA，然后在客户端预装可信CA的公钥（存在一个证书链体系，不是只有一个CA）。服务端通过下发证书，客户端通过预装公钥验证证书签名以及一些其他信息，确认了服务端身份，这样就能解决身份认证的问题并且保证了服务器公钥的完整性。TLS还支持双向认证，即服务端请求验证客户端身份，但一般只需要验证一方就可以解决中间人问题了。</p><p>记录层会通过握手层传输过来的数据Data生成用于加密应用数据的对称密钥，在此之前为了保证刚刚握手的完整性，还需要做消息校验并用协商生成的对称密钥加密，作为双方第一个对称加密的包。通过这个消息就能验证协商出的对称密钥是否正确，以及之前握手消息没有被篡改。之后记录层就可以正式加密传输应用数据了。</p><p>完成这样一次会话过程后，我们还需要思考一个问题：每次会话都需要重新生成新的密钥，这样是否很浪费，我们是否能复用之前的密钥。由此TLS产生了会话恢复机制，包括使用Session_id和Session_ticket两种手段。</p><p>以上就是从我个人理解的角度，观察TLS握手层一步一步的设计缘由，当然这其中隐藏了很多具体的实现细节，比如每一步的密钥是如何生成的，应该如何使用，如何减少私钥泄漏后的影响，为什么会话恢复有两种模式等等很多有意思的问题，在接下的分析中我会挑选一些我认为比较重要的进行解析。</p><p>总结下以上步骤，整体思路如下图：</p><p><img src="https://image.bdwms.com/FgkGgBr3d1jnp_3ycicaEH7BkSCB"></p><h3 id="记录层"><a href="#记录层" class="headerlink" title="记录层"></a>记录层</h3><p>对于记录层步骤主要为分段，压缩（可选，因为存在安全问题一般不开启），加密和消息认证MAC（存在三种模式，stream ,block,aead）,添加消息头。在这一层会利用握手层传输的密钥材料，生成对称密钥，MAC密钥等必备参数。完成对数据的对称加密和生成消息认证码（AEAD模式将两者结合起来了），这就是这一层做的最主要的事情。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="握手层冷启动"><a href="#握手层冷启动" class="headerlink" title="握手层冷启动"></a>握手层冷启动</h3><p>通过上面的推演，我们大致了解了每一层的目的以及大致的步骤，这里我们来看一下具体的实现。</p><p>对于第一次冷启动的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello                  --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                               Certificate*</span><br><span class="line">                                         ServerKeyExchange*</span><br><span class="line">                                        CertificateRequest*</span><br><span class="line">                             &lt;--------      ServerHelloDone</span><br><span class="line">Certificate*</span><br><span class="line">ClientKeyExchange</span><br><span class="line">CertificateVerify*</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                     --------&gt;</span><br><span class="line">                                         [ChangeCipherSpec]</span><br><span class="line">                             &lt;--------             Finished</span><br><span class="line">Application Data             &lt;-------&gt;     Application Data</span><br><span class="line">*表示可选发送</span><br><span class="line">[]表示独立消息，这里为了防阻塞单独通知密钥协议已切换，有冗余在<span class="number">1.3</span>中删除</span><br></pre></td></tr></table></figure><ol><li>客户端发送ClientHello携带自己支持的加密组件以及随机值，服务端收到后选择支持的加密组件并携带服务端随机值返回一个ServerHello消息。</li><li>之后服务端发送Certifacate消息，包含证书信息，以及当Certificate信息不足时，发送ServerKeyExchange消息包含补充信息。</li><li>因为TLS支持双向认证，如果服务端需要对客户端身份进行认证的话，就会发送CertifacateRequest消息。</li><li>服务端发送ServerHelloDone表明自己已经发送完成。</li><li>当客户端收到CertificateRequest请求后，如果支持认证就发送Certificate消息包含自己的证书。如果没有收到验证请求，就不发送此条消息。</li><li>客户端发送ClientKeyExchange，交换密钥材料。例如使用RSA，就会生成由46字节的随机值和2字节的版本号组成的Pre_master_secret，使用服务端公钥加密后，在本条消息包含发送。</li><li>如果客户端发送了Certificate消息，就需要发送一条CertificateVerify消息来对之前的握手做Hash并用自己的证书私钥进行签名，表明自己确实拥有客户端证书私钥以验证身份，并保证了之前握手消息未被篡改。</li><li>之后会发送ChangeCipherSpec通知对端已经切换密钥了（为了防阻塞不在本消息流中）</li><li>客户端发送Finished消息，通过结合之前握手消息的Hash，Master_secret等生成验证数据，并利用协商出来的Session_key加密传输给对端。Finished消息是第一条使用协商出来的对称密钥加密的消息，通过这条消息验证了密钥的正确性以及之前握手消息未被篡改。</li><li>同样服务端也发送Finished消息，注意在做Hash时的握手消息包含上条客户端发送的Finished消息。</li><li>双方通过握手以及密钥派生计算已经拥有了相同的Session_key，可以进行正式的应用数据加密传输了。</li></ol><h3 id="握手层热启动"><a href="#握手层热启动" class="headerlink" title="握手层热启动"></a>握手层热启动</h3><p>分为Session_id和Session_ticket两种。第一种使用Session_id，发送ClientHello时会客户端会携带会话唯一标示，服务端同意后发送ServerHello以及Finished，根据保存的主密钥Master_secrert等信息以及新的随机值重新计算会话密钥来进行应用数据加密。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Client                                                Server</span><br><span class="line"></span><br><span class="line">ClientHello                   --------&gt;</span><br><span class="line">                                                 ServerHello</span><br><span class="line">                                          [ChangeCipherSpec]</span><br><span class="line">                              &lt;--------             Finished</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                      --------&gt;</span><br><span class="line">Application Data              &lt;-------&gt;     Application Data</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>但是因为存在分布式Session同步以及存储性能的限制，一般选用下面的Session_ticket手段，这十分类似HTTP中的Cookie和Session机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">第一次：</span><br><span class="line">   ClientHello</span><br><span class="line">   (empty SessionTicket extension)--------&gt;</span><br><span class="line">                                                   ServerHello</span><br><span class="line">                                (empty SessionTicket extension)</span><br><span class="line">                                                  Certificate*</span><br><span class="line">                                            ServerKeyExchange*</span><br><span class="line">                                           CertificateRequest*</span><br><span class="line">                                &lt;--------      ServerHelloDone</span><br><span class="line">   Certificate*</span><br><span class="line">   ClientKeyExchange</span><br><span class="line">   CertificateVerify*</span><br><span class="line">   [ChangeCipherSpec]</span><br><span class="line">   Finished                     --------&gt;</span><br><span class="line">            NewSessionTicket</span><br><span class="line">                                            [ChangeCipherSpec]</span><br><span class="line">                                &lt;--------             Finished</span><br><span class="line">   Application Data             &lt;-------&gt;     Application Data</span><br><span class="line">第二次：</span><br><span class="line">   ClientHello</span><br><span class="line">   (SessionTicket extension)     --------&gt;</span><br><span class="line">                                                    ServerHello</span><br><span class="line">                                 (empty SessionTicket extension)</span><br><span class="line">                                               NewSessionTicket</span><br><span class="line">                                             [ChangeCipherSpec]</span><br><span class="line">                                 &lt;--------             Finished</span><br><span class="line">   [ChangeCipherSpec]</span><br><span class="line">   Finished                      --------&gt;</span><br><span class="line">   Application Data              &lt;-------&gt;     Application Data</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>可以看到在第一次中服务端会发送一个NewSessionTicket消息，将会话信息加密并MAC在其中，客户端在第二次中携带ticket，服务端成功解密并验证完整性后，如果同意就会直接省略密钥协商的过程，从而节省了传输时间。</p><h3 id="记录层-1"><a href="#记录层-1" class="headerlink" title="记录层"></a>记录层</h3><p>从握手层得到数据如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ConnectionEnd          entity;</span><br><span class="line">    PRFAlgorithm           prf_algorithm;</span><br><span class="line">    BulkCipherAlgorithm    bulk_cipher_algorithm;</span><br><span class="line">    CipherType             cipher_type;</span><br><span class="line">    uint8                  enc_key_length;</span><br><span class="line">    uint8                  block_length;</span><br><span class="line">    uint8                  fixed_iv_length;</span><br><span class="line">    uint8                  record_iv_length;</span><br><span class="line">    MACAlgorithm           mac_algorithm;  <span class="comment">/*mac 算法*/</span></span><br><span class="line">    uint8                  mac_length;     <span class="comment">/*mac 值的长度*/</span></span><br><span class="line">    uint8                  mac_key_length; <span class="comment">/*mac 算法密钥的长度*/</span></span><br><span class="line">    CompressionMethod      compression_algorithm;</span><br><span class="line">    opaque                 master_secret[<span class="number">48</span>];</span><br><span class="line">    opaque                 client_random[<span class="number">32</span>];</span><br><span class="line">    opaque                 server_random[<span class="number">32</span>];</span><br><span class="line">&#125; SecurityParameters;</span><br></pre></td></tr></table></figure><p>利用PRF密钥派生函数生成以下数据用来加密和MAC。同时因为根据密码学的研究，客户端写/服务端读，服务端写/客户端读，这两种流向是不能使用同一个会话密钥的，会产生安全问题，所以生成两组write key。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client write MAC key*</span><br><span class="line">server write MAC key*</span><br><span class="line">client write encryption key</span><br><span class="line">server write encryption key</span><br><span class="line">client write IV</span><br><span class="line">server write IV</span><br><span class="line">*表示可选，AEAD模式无需MAC</span><br></pre></td></tr></table></figure><p>记录层的流程为数据分段，压缩（可选，因为存在安全问题一般禁用），加密和完整性保护，添加消息头。</p><p>我们这里重点关注加密和完整性保护。在密码学中存在三种加密和MAC的组合方式。</p><ul><li>Encrypt-and-MAC：明文加密和明文MAC拼接在一起。</li><li>MAC-then-Encrypt：对明文MAC后拼接在明文后，对整个进行加密。</li><li>Encrypt-then-MAC：对明文加密后在对密文MAC，将MAC内容拼接在密文后。</li></ul><p>TLS中采用的是第二种，但是随着发展发现了很多问题，例如Padding Oracle漏洞等。对于具体的做法又分为块模式+Hmac，流模式+Hmac，以及AEAD模式。块和流模式采用的是MAC then encrypt，之后为了从密码学上直接解决这个问题，密码学专家便提出了将加密和完整性保护融合在一个算法中即AEAD，彻底解决以上问题，因此更推荐使用AEAD模式例如aes-256-gcm。</p><h3 id="密钥派生函数与密钥变化"><a href="#密钥派生函数与密钥变化" class="headerlink" title="密钥派生函数与密钥变化"></a>密钥派生函数与密钥变化</h3><p>以上就是1.2的基本流程，针对密钥这一块需要单独强调一下。</p><p>我们先看下PRF函数，它通过输入的材料可以通过递归的Hash生成无限长的随机输出，我们可以截取任意长度作为我们的产出需求，看一下具体的表现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> P_hash(secret, seed) = HMAC_hash(secret, A(<span class="number">1</span>) + seed) +</span><br><span class="line">                           HMAC_hash(secret, A(<span class="number">2</span>) + seed) +</span><br><span class="line">                           HMAC_hash(secret, A(<span class="number">3</span>) + seed) + ...</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">A(<span class="number">0</span>) = seed</span><br><span class="line">A(i) = HMAC_hash(secret, A(i<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><p>因此在TLS中的表现形式就为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRF(secret, label, seed) = P_&lt;hash&gt;(secret, label + seed)</span><br></pre></td></tr></table></figure><p>我们有了这样一个派生密钥的工具后，我们在来看下具体的密钥变化。在整个过程中主要涉及三个密钥：</p><p><code>Premaster_secret -&gt; Master_secret -&gt; Session_key</code></p><p>其中Premaster_secret是在握手交换时完成的，采用不同的密钥协商算法会有不同变化，如下：</p><ul><li>RSA：客户端生成随机值作为Premaster_secret。</li><li>静态DH，ECDH：服务端公钥包含在证书中，客户端看是否包含在证书，不在的话就用ClientKeyExchange中，通过计算得出Premaster_secret。</li><li>动态DHE，ECDHE：公钥分别由服务端ServerKeyExchange，客户端ClientKeyExchange消息中，并计算得出Premaster_secret.</li></ul><p>之后使用Premaster_seceret通过PRF函数生成48字节的Master_secret</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret, <span class="string">&quot;master secret&quot;</span>,</span><br><span class="line">                            ClientHello.random + ServerHello.random)</span><br><span class="line">                            [<span class="number">0.</span><span class="number">.47</span>];</span><br></pre></td></tr></table></figure><p>Master_secret才是真正传递给记录层的，之后记录层利用Master_secret生成Session_key，然后切分为对称密钥，IV，MAC密钥来处理真正的应用数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key_block = PRF(SecurityParameters.master_secret,</span><br><span class="line">                <span class="string">&quot;key expansion&quot;</span>,</span><br><span class="line">                SecurityParameters.server_random +</span><br><span class="line">                SecurityParameters.client_random);</span><br></pre></td></tr></table></figure><p>这些变化的理由，我个人思考如下：</p><ul><li><p>为什么不直接使用Premaster_secret生成Session_key呢？</p><p>因为Premaster_secret的格式不同,RSA是48位，ECC类基于具体算法，我们想要得到固定格式的熵源，所以利用PRF函数计算出Master_secret，并且保证secret的随机性不仅仅受单一方影响，比如rsa做秘钥交换时仅仅是客户端发送48字节的值</p></li><li><p>为什么不直接使用Master_secret加密呢？</p><p>长度不够；利用主密钥生成会话密钥会让攻击者进行计算破解难度更大</p></li></ul><p>更多问题限于篇幅请看我之前的文章：<a href="https://www.bdwms.com/?p=946">TLS相关FAQ</a></p><h2 id="回顾与展望"><a href="#回顾与展望" class="headerlink" title="回顾与展望"></a>回顾与展望</h2><p>说到这里，我们暂停一下我们的脚步，首先来回顾一下TLS1.2是怎么完成它开始的设计目标的。</p><ul><li>机密性：非对称和对称加密的结合使用。</li><li>身份认证：证书体系的建立。</li><li>完整性保护：握手阶段的CertificateVerify，Finished消息做校验，记录层对消息做MAC。</li><li>性能：基于Session的会话恢复机制。</li><li>通用性：凡是基于RFC文档实现的，理论上上都是可以做到多种设备的兼容，并且采用的证书体系也是全球通用的。</li><li>可拓展性：在握手的会话中支持插件机制。</li></ul><p>除了以上特性TLS在其他种种方面也是做到基本可用成型，做到了对网络传输安全的保障。当然，这些年来随之密码学的研究深入，以及技术迭代的发展，由此产生了更高的要求，TLS1.2在一些方面已经不能满足业界了，我们简单看下它的主要问题在哪：</p><ul><li>不安全的密码组件，模式和配置。例如RC4,MD5等一种算法被破解，块加密，流加密模式的不安全因素。</li><li>伴随着斯诺登泄密事件，前向安全性更加被重视。</li><li>1.2冷启动至少需要2RTT，热启动需要1RTT，对于很多短链接的场景下，耗时过长是不可接受的。</li></ul><p>为了改善这些问题，1.3版本做了巨大的改变，甚至一定程度上放弃了前向兼容来保证架构的重新调整，让我们在一篇文章中看下TLS1.3究竟有何神奇之处。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来准备一篇文章写完整个TLS1.2和1.3的，但是发现就算省略了很多细节，仅仅是1.2也已经6000多字了，决定还是分上下两篇，方便读者阅读。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tools.ietf.org/html/rfc5246">TLS1.2 RFC</a></li><li><a href="https://halfrost.com/">冰霜之地</a></li><li><a href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/">TLS协议分析 与 现代加密通信协议设计</a></li><li><a href="https://blog.shell909090.org/blog/archives/2873/">安全协议的设计</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>再起航，2021</title>
      <link href="Hello-2021/"/>
      <url>Hello-2021/</url>
      
        <content type="html"><![CDATA[<p>2021起始，告别了我的旧博客，来到了我的新家。</p><p>Hello, World!</p><h2 id="告别过去"><a href="#告别过去" class="headerlink" title="告别过去"></a>告别过去</h2><h3 id="为什么要更换博客"><a href="#为什么要更换博客" class="headerlink" title="为什么要更换博客"></a>为什么要更换博客</h3><ul><li>Wordpress对markdown原生支持不好，尝试了n种插件后发现兼容性或者效果展示也不尽人意。</li><li>旧博客采用的是宝塔+Wordpress+Cloudflare，外加上各种插件，较容易存在安全问题，频繁升级维护很麻烦。</li><li>回望过去两年多来，陆陆续续写了130多篇的博客，但是其质量限于本人的水平，以及写作时较为随意，导致整体的质量不高。并且随着我的大学时光即将结束，慢慢进入社畜的节奏，无法维持高频度的更新，由此想要更加精炼自己的文章。所以最终决定抛下旧包袱，开启新的篇章。</li></ul><h3 id="方案分析选择"><a href="#方案分析选择" class="headerlink" title="方案分析选择"></a>方案分析选择</h3><p>既然决定了要更换博客，那么肯定就要进行好好分析，分为两个部分，一个是新博客如何选择，旧博客如何处理，经过我的尝试，最后完成了本次更新升级。</p><ul><li><p>旧博客：</p><p>一开始的想法是做二级域名，将旧博客指向二级域名，例如backup.bdwms.com。方法很简单，因为我的域名统一托管在cloudflare，只要添加个二级域名的A记录就行了，但是此时就存在两个问题了。</p><p>一个是免费的SSL证书只能是单域名，通配符的证书都要钱，所以就需要给二级域名单独申请一张证书。</p><p>二就是我发现更改完二级域名后，整个Wordpress的链接指向都乱了，分析和搜索了下需要甚至需要手动改数据库，这个操作很危险，考虑我放弃了这个方案，最终选择保留旧博客的域名，重新申请个域名。</p></li><li><p>新博客：</p><p>选择Hexo，优秀地支持markdown，安装和维护简单，作为黑色爱好者选择了极简的主题<a href="https://github.com/probberechts/hexo-theme-cactus">Cactus</a>，也是因为之前看到P牛的博客。</p></li></ul><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h3><p>官网安装npm，hexo，网上文章太多了不多赘述。然后就是配置主题Cactus，进行了一些魔改，评论系统选择了Disqus（需要科学上网）。</p><p>在部署的时候，出现一个选择，一个很简单的方法是直接在Github中配置个[username].github.io，然后在_config.yml中配置deploy的repository，再将自己的新买的域名解析到[username].github.io，再在仓库的settings配置下域名就可以替换域名了。</p><p>但是这样的话不够优雅，每次都需要</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>并且存在一个备份和同步问题，我要是换了电脑怎么复原，以及怎么在不同电脑上写呢。我研究了网上的方法，很多说在仓库里面新开一个branch，但是这样的话很多配置魔改的文件都会公开，遂放弃。</p><h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><p>最后经过研究参考部署的方便，以及备份和同步，选择了Github提供的Action来做自动部署，优化使用流程只需要push代码就可以自动部署，并且将自己的源代码单独放在一个私有库，生成文件在公开库，同时将魔改后的主题文件单独放在一个库中。具体流程如下：</p><ol><li><p>生成三个库，一个私有库放BlogSource源代码，一个公共库Themes放魔改的主题，一个公共库[username].github.io放真正的生成文件。然后进行生成密钥对，私钥放<code>Settings -&gt; Secrets -&gt; Add a new secret</code>，命名<code>HEXO_DEPLOY_PRI</code>,公钥放github.io的公钥库<code>Settings -&gt; Deploy keys -&gt; Add deploy key</code>，命名<code>HEXO_DEPLOY_PUB</code>，开启<code>Allow write access</code></p></li><li><p>因为我clone后魔改的主题也想要进行管理，所以将其推到Themes库，注意这里push的时候将主题的_config.yml改名放在博客根目录中，不能传到公共库中，在博客根目录生成git后，与主题的git冲突，于是选择使用submodule方式，进行分离管理，命令类似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add [themes_url] themes/cactus</span><br></pre></td></tr></table></figure><p>然后为了能够保证CNAME不被每次覆盖，在source文件下放一个CNAME文件，里面写要CNAME的域名，push源代码到远端。</p></li><li><p>最后也是最重要的生成CI/CD文件，在私有库的Action中选择生成一个Workflow，配置文件例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">GIT_USER:</span> <span class="string">user.name</span></span><br><span class="line">  <span class="attr">GIT_EMAIL:</span> <span class="string">user.email</span></span><br><span class="line">  <span class="attr">THEME_REPO:</span> <span class="string">birdmanwings/cactus-modify</span></span><br><span class="line">  <span class="attr">THEME_BRANCH:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">DEPLOY_REPO:</span> <span class="string">birdmanwings/birdmanwings.github.io</span></span><br><span class="line">  <span class="attr">DEPLOY_BRANCH:</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span> <span class="string">on</span> <span class="string">node</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span> <span class="string">and</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.os</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">os:</span> [<span class="string">ubuntu-latest</span>]</span><br><span class="line">        <span class="attr">node_version:</span> [<span class="number">14.</span><span class="string">x</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">theme</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">themes/cactus</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">deploy</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.DEPLOY_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.DEPLOY_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">.deploy_git</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configuration</span> <span class="string">environment</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">HEXO_DEPLOY_PRI:</span> <span class="string">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">sudo</span> <span class="string">timedatectl</span> <span class="string">set-timezone</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;$HEXO_DEPLOY_PRI&quot;</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">$GIT_USER</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">$GIT_EMAIL</span></span><br><span class="line">          <span class="string">cp</span> <span class="string">_config.theme.yml</span> <span class="string">themes/cactus/_config.yml</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">run</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>需要更改下名字，邮箱，主题地址，分支名称，然后commit就可以了，这里注意主题config，密钥对名称是否正确，之后本地pull下同步下代码，写一个文章push上去后能够发现成功自动部署。</p></li></ol><p>可以看下最后的项目结构类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy_git</span><br><span class="line">├── .git</span><br><span class="line">├── .github</span><br><span class="line">│   └── workflows</span><br><span class="line">│       ├── main.yml</span><br><span class="line">├── _config.landscape.yml</span><br><span class="line">├── _config.theme.yml</span><br><span class="line">├── _config.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── source</span><br><span class="line">│   ├── CNAME</span><br><span class="line">│   ├── _posts</span><br><span class="line">│   │   ├── Hello,World.md</span><br><span class="line">│   ├── about</span><br><span class="line">│   │   └── index.md</span><br><span class="line">│   ├── categories</span><br><span class="line">│   │   ├── index.md</span><br><span class="line">│   └── search</span><br><span class="line">│       ├── index.md</span><br><span class="line">└── themes</span><br><span class="line">    └── cactus</span><br><span class="line">        ├── LICENSE</span><br><span class="line">        ├── README.md</span><br><span class="line">        ├── gulpfile.js</span><br><span class="line">        ├── languages</span><br><span class="line">        ├── layout</span><br><span class="line">        ├── package.json</span><br><span class="line">        ├── scripts</span><br><span class="line">        └── source</span><br></pre></td></tr></table></figure><h3 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h3><p>如何备份恢复呢，先配好git，npm，hexo，然后clone recurvise自己的源代码下来，<code>npm install</code>安装下依赖，然后就可以写文章push自动部署了，跟我们平常做项目管理没有什么区别了。</p><h3 id="阿里云CDN加速"><a href="#阿里云CDN加速" class="headerlink" title="阿里云CDN加速"></a>阿里云CDN加速</h3><p>折腾了几天终于配好了，吐槽下阿里云前端逻辑真的乱，然后网上教程好多还是错的，无语。首先域名需要备案，然后买一个下行流量包和静态HTTPS包，然后申请下全站加速，源站选username.github.io，选择申请。通过后会分配一个CNAME，然后配置CNAME域名，境外和境内分两个线路来配，这样就可以国内外都满速访问，如下：</p><p><img src="https://image.bdwms.com/FsxgKiVLfFYKlLCfIdxcd1KUOIIe"></p><p>Github仓库的custom域名指向bdwms.site。然后因为cdn没有HTTPS，需要申请个免费证书部署到CDN，开启强制HTTPS。等会后看下国内访问速度，一片绿感人。</p><p><img src="https://image.bdwms.com/FmB36fDsTH3KgzELf6JVobQ6-_qO"></p><h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>下一个十年，</p><p>想做一个懂业务的安全人，</p><p>想做一个有思考的技术人，</p><p>想做一个明白爱的成年人，</p><p>再起航，2021～</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/87053283">Git中submodule的使用</a></p></li><li><p><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">利用 Github Actions 自动部署 Hexo 博客</a></p></li><li><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-5">超详细Hexo+Github博客搭建小白教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从TLS看安全协议设计（下）</title>
      <link href="2021/01/16/%E4%BB%8ETLS%E7%9C%8B%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>2021/01/16/%E4%BB%8ETLS%E7%9C%8B%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>TLS1.3作为升级的版本，根据需求主要是在两个方面做了整改，一个是安全方面，一个就是性能，下面我们就来看一下。</p><h2 id="升级之处"><a href="#升级之处" class="headerlink" title="升级之处"></a>升级之处</h2><p>安全：</p><ul><li>删除了不安全的密码组件，例如MD5。</li><li>为了前向安全性，密钥协商过程不再使用RSA和静态DH，ECDH，只选用DHE或者ECDHE。</li><li>设计了新的密钥派生函数HKDF代替了PRF函数。</li><li>记录层进行加密和MAC时固定为AEAD模式。</li></ul><p>性能：</p><ul><li>重新设计了握手层流程，让冷启动从2RTT变化1RTT。</li><li>设计了PSK会话恢复机制代替了原来的Session会话恢复机制。</li><li>0-RTT</li></ul><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>对于TLS1.3的流程如下，最主要分为两种方式，一种是基于key_share和signature_algorithms来选择加密的算法，另一种是基于预共享密钥PSK的会话恢复。</p><h3 id="握手层冷启动"><a href="#握手层冷启动" class="headerlink" title="握手层冷启动"></a>握手层冷启动</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Key  ^ ClientHello</span><br><span class="line">Exch | + key_share*</span><br><span class="line">     | + signature_algorithms*</span><br><span class="line">     | + psk_key_exchange_modes*</span><br><span class="line">     v + pre_shared_key*       --------&gt;</span><br><span class="line">                                                  ServerHello  ^ Key</span><br><span class="line">                                                 + key_share*  | Exch</span><br><span class="line">                                            + pre_shared_key*  v</span><br><span class="line">                                        &#123;EncryptedExtensions&#125;  ^  Server</span><br><span class="line">                                        &#123;CertificateRequest*&#125;  v  Params</span><br><span class="line">                                               &#123;Certificate*&#125;  ^</span><br><span class="line">                                         &#123;CertificateVerify*&#125;  | Auth</span><br><span class="line">                                                   &#123;Finished&#125;  v</span><br><span class="line">                               &lt;--------  [Application Data*]</span><br><span class="line">     ^ &#123;Certificate*&#125;</span><br><span class="line">Auth | &#123;CertificateVerify*&#125;</span><br><span class="line">     v &#123;Finished&#125;              --------&gt;</span><br><span class="line">                                                     &lt;--------  [NewSessionTicket]</span><br><span class="line">       [Application Data]      &lt;-------&gt;  [Application Data]</span><br></pre></td></tr></table></figure><p>我们首先来看第一种</p><ol><li>客户端发送ClinetHello，在key_share和signature_algorithms中声明自己支持的DHE或者ECDHE算法类型对应的具体参数。</li><li>服务端返回ServerHello，选择自己支持的算法和自己的参数。</li><li>服务端发送EncryptedExtensions，包含不需要建立加密上下文并且和证书无关的拓展。注意从本条消息开始都会被加密传输。</li><li>如果想要验证客户端认证，服务端就会发送CertificateRequest消息。</li><li>服务端发送Certificate消息，包含自己的证书。</li><li>服务端发送CertificateVerify消息。对之前握手的消息做Hash后用证书私钥进行签名，进行显示认证表明自己持有证书私钥。</li><li>服务端发送Finished消息对之前握手消息做校验，以及验证协商密钥的正确性。</li><li>此时服务端已经可以发送加密的应用数据了。</li><li>如果需要客户端验证，就会发送客户端Certificate消息。</li><li>如果客户端发送了Certificate消息，就会发送CertificateVerify来表明客户端持有证书私钥。</li><li>客户端同样发送Finished消息，进行校验。</li><li>客户端可以发送加密的应用消息。</li></ol><p>我们观察整个流程，冷启动仅需要1-RTT。因为在ClientHello时已经携带了DHE（ECDHE）的参数，让第一次握手有更多的作用。这也是因为在密钥协商时抛弃了RSA算法，因为对于RSA需要服务端先下发公钥，所以需要至少2-RTT。</p><h3 id="握手层热启动"><a href="#握手层热启动" class="headerlink" title="握手层热启动"></a>握手层热启动</h3><p>我们再看一下会话恢复的情况。对于1.3使用的是PSK机制，其中PSK可以从上次握手时生成，或者由使用者预置。</p><p>看一下流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ClientHello</span><br><span class="line">    + key_share*</span><br><span class="line">    + pre_shared_key          --------&gt;</span><br><span class="line">                                                    ServerHello</span><br><span class="line">                                               + pre_shared_key</span><br><span class="line">                                                   + key_share*</span><br><span class="line">                                          &#123;EncryptedExtensions&#125;</span><br><span class="line">                                                     &#123;Finished&#125;</span><br><span class="line">                              &lt;--------     [Application Data*]</span><br><span class="line">    &#123;Finished&#125;                --------&gt;</span><br><span class="line">    [Application Data]        &lt;-------&gt;      [Application Data]</span><br><span class="line">    +表示携带的参数，*表示可选</span><br></pre></td></tr></table></figure><p>客户端携带PSK发送给服务端，服务端如果接受就返回ServerHello，以及加密的EncryptedExtensions，Finished消息。之后两者就能进行应用数据传输，整个流程需要一个1-RTT。</p><h3 id="记录层"><a href="#记录层" class="headerlink" title="记录层"></a>记录层</h3><p>流程为数据分段，填充（为了隐藏流量），加密和完整性保护（AEAD），添加消息头。</p><p>与1.2最主要的不同就是抛弃的块模式和流模式，固定为AEAD，并对AEAD做了一些调整，这里就不展开说了。</p><h2 id="变化分析"><a href="#变化分析" class="headerlink" title="变化分析"></a>变化分析</h2><h3 id="HKDF密钥派生函数"><a href="#HKDF密钥派生函数" class="headerlink" title="HKDF密钥派生函数"></a>HKDF密钥派生函数</h3><p>1.3重新设计了密钥派生函数，对于HKDF函数分为Extract和Expand过程，Extract过程增加密钥材料的随机性,Expand进行拓展，在1.2中PRF函数只有Expand的过程，它默认密钥材料的随机性是足够的，然而这是不一定的可能ECC协商出来的随机分布是不够均匀的。</p><p>Extract过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Extract(salt, IKM) -&gt; PRK</span><br><span class="line">salt盐可选，没有时用<span class="number">0</span>填充HashLen长度</span><br><span class="line">IKM：Input Keying Material</span><br><span class="line">PRK: 生成的伪随机key</span><br><span class="line"></span><br><span class="line">PRK = HMAC-Hash(salt, IKM)      </span><br></pre></td></tr></table></figure><p>Expand过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Expand(PRK, info, L) -&gt; OKM</span><br><span class="line">PRK伪随机key</span><br><span class="line">info可选一般标志上下文信息</span><br><span class="line">L期望输出的字节数</span><br><span class="line"></span><br><span class="line"> OKM生成方式：</span><br><span class="line"> N = <span class="built_in">ceil</span>(L/HashLen)</span><br><span class="line"> T = T(<span class="number">1</span>) | T(<span class="number">2</span>) | T(<span class="number">3</span>) | ... | T(N)</span><br><span class="line"> OKM = first L octets of T</span><br><span class="line"></span><br><span class="line"> where:</span><br><span class="line"> T(<span class="number">0</span>) = empty <span class="built_in">string</span> (zero length)</span><br><span class="line"> T(<span class="number">1</span>) = HMAC-Hash(PRK, T(<span class="number">0</span>) | info | <span class="number">0x01</span>)</span><br><span class="line"> T(<span class="number">2</span>) = HMAC-Hash(PRK, T(<span class="number">1</span>) | info | <span class="number">0x02</span>)</span><br><span class="line"> T(<span class="number">3</span>) = HMAC-Hash(PRK, T(<span class="number">2</span>) | info | <span class="number">0x03</span>)</span><br><span class="line"> ...   </span><br></pre></td></tr></table></figure><p>以及最终使用的Derive-Secret函数与Expand所对应的关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HKDF-Expand-Label(Secret, Label, Context, Length) =</span><br><span class="line">            HKDF-Expand(Secret, HkdfLabel, Length)</span><br><span class="line"></span><br><span class="line">Where HkdfLabel is specified as:</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">  uint16 length = Length;</span><br><span class="line">  opaque label&lt;<span class="number">7.</span><span class="number">.255</span>&gt; = <span class="string">&quot;tls13 &quot;</span> + Label;</span><br><span class="line">  opaque context&lt;<span class="number">0.</span><span class="number">.255</span>&gt; = Context;</span><br><span class="line">&#125; HkdfLabel;</span><br><span class="line"></span><br><span class="line">Derive-Secret(Secret, Label, Messages) =</span><br><span class="line">  HKDF-Expand-Label(Secret, Label,</span><br><span class="line">       Transcript-Hash(Messages), Hash.length)</span><br><span class="line">  </span><br><span class="line">Transcript-Hash级联握手消息做Hash运算</span><br></pre></td></tr></table></figure><h3 id="密钥变化"><a href="#密钥变化" class="headerlink" title="密钥变化"></a>密钥变化</h3><p>1.3对于密钥做了更加详细的分类，在每一个使用部分的密钥实际上都是不同的，都会通过HKDF函数做变化，这也是密码学上的安全要求，一个密钥只使用在一种功能上。</p><p>一次握手的密钥变化如下，很复杂，可以只大概了解下有什么密钥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">0</span></span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line">PSK -&gt;  HKDF-Extract = Early Secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;ext binder&quot;</span> | <span class="string">&quot;res binder&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">          |                     = binder_key</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;c e traffic&quot;</span>, ClientHello)</span><br><span class="line">          |                     = client_early_traffic_secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;e exp master&quot;</span>, ClientHello)</span><br><span class="line">          |                     = early_exporter_master_secret</span><br><span class="line">          v</span><br><span class="line">    Derive-Secret(., <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line">(EC)DHE -&gt; HKDF-Extract = Handshake Secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;c hs traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...ServerHello)</span><br><span class="line">          |                     = client_handshake_traffic_secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;s hs traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...ServerHello)</span><br><span class="line">          |                     = server_handshake_traffic_secret</span><br><span class="line">          v</span><br><span class="line">    Derive-Secret(., <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line"><span class="number">0</span> -&gt; HKDF-Extract = Master Secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;c ap traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...server Finished)</span><br><span class="line">          |                     = client_application_traffic_secret_0</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;s ap traffic&quot;</span>,</span><br><span class="line">          |                     ClientHello...server Finished)</span><br><span class="line">          |                     = server_application_traffic_secret_0</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;exp master&quot;</span>,</span><br><span class="line">          |                     ClientHello...server Finished)</span><br><span class="line">          |                     = exporter_master_secret</span><br><span class="line">          |</span><br><span class="line">          +-----&gt; Derive-Secret(., <span class="string">&quot;res master&quot;</span>,</span><br><span class="line">                                ClientHello...client Finished)</span><br><span class="line">                                = resumption_master_secret</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ol><li>HKDF-Extract 画在图上，它为从顶部获取 Salt 参数，从左侧获取 IKM 参数，它的输出是底部，和右侧输出的名称。</li><li>Derive-Secret 的 Secret 参数由传入的箭头指示。例如，Early Secret 是生成 client_early_traffic_secret 的 Secret。</li><li>“0” 表示将 Hash.length 字节的字符串设置为零。</li></ol><p>其中有三个Secret，是从Extract中得来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Early Secret = HKDF-Extract(salt, IKM) = HKDF-Extract(<span class="number">0</span>, PSK) (有PSK的情况)= HKDF-Extract(<span class="number">0</span>,<span class="number">0</span>) （没有PSK的情况）</span><br><span class="line">                                          </span><br><span class="line">Handshake Secret = HKDF-Extract(salt, IKM) = HKDF-Extract(Derive-Secret(Early Secret, <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>), (EC)DHE)</span><br><span class="line"></span><br><span class="line">Master Secret = HKDF-Extract(salt, IKM) = HKDF-Extract(Derive-Secret(Handshake Secret, <span class="string">&quot;derived&quot;</span>, <span class="string">&quot;&quot;</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>八个可能用到的密钥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client_early_traffic_secret = Derive-Secret(Early Secret, <span class="string">&quot;c e traffic&quot;</span>, ClientHello)</span><br><span class="line">early_exporter_master_secret = Derive-Secret(Early Secret, <span class="string">&quot;e exp master&quot;</span>, ClientHello)</span><br><span class="line"></span><br><span class="line">client_handshake_traffic_secret = Derive-Secret(Handshake Secret, <span class="string">&quot;c hs traffic&quot;</span>, ClientHello...ServerHello)</span><br><span class="line">server_handshake_traffic_secret = Derive-Secret(Handshake Secret, <span class="string">&quot;s hs traffic&quot;</span>, ClientHello...ServerHello)</span><br><span class="line"></span><br><span class="line">client_application_traffic_secret_0 = Derive-Secret(Master Secret, <span class="string">&quot;c ap traffic&quot;</span>, ClientHello...server Finished)</span><br><span class="line">server_application_traffic_secret_0 = Derive-Secret(Master Secret, <span class="string">&quot;s ap traffic&quot;</span>, ClientHello...server Finished)</span><br><span class="line"></span><br><span class="line">exporter_master_secret = Derive-Secret(Master Secret, <span class="string">&quot;exp master&quot;</span>, ClientHello...server Finished)</span><br><span class="line">resumption_master_secret = Derive-Secret(Master Secret, <span class="string">&quot;res master&quot;</span>, ClientHello...client Finished)</span><br></pre></td></tr></table></figure><ol><li>early_exporter_master_secret和exporter_master_secre导出密钥，用户可以自定义使用方式。</li><li>resumption_master_secret用于会话恢复。</li><li>client_early_traffic_secret用于加密early_data，在0-RTT模式中使用。</li><li>client_handshake_traffic_secret和server_handshake_traffic_secret用于握手时的加密。</li><li>client_application_traffic_secret_0和server_application_traffic_secret_0用于加密应用流量数据。</li></ol><p>3，4，5的密钥想要加密数据还需要一次Expand过程生成write_key和iv来作为真正加密数据的密钥，生成方式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sender]_write_key = HKDF-Expand-Label(Secret, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;&quot;</span>, key_length)</span><br><span class="line">[sender]_write_iv  = HKDF-Expand-Label(Secret, <span class="string">&quot;iv&quot;</span>, <span class="string">&quot;&quot;</span>, iv_length)</span><br></pre></td></tr></table></figure><h3 id="PSK会话恢复机制"><a href="#PSK会话恢复机制" class="headerlink" title="PSK会话恢复机制"></a>PSK会话恢复机制</h3><p>1.3中使用PSK机制代替了Session机制，那么PSK是如何生成并使用的？</p><p>先看下Server发送的NewSessionTicket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">          uint32 ticket_lifetime;</span><br><span class="line">          uint32 ticket_age_add;</span><br><span class="line">          opaque ticket_nonce&lt;<span class="number">0.</span><span class="number">.255</span>&gt;;</span><br><span class="line">          opaque ticket&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span><br><span class="line">          Extension extensions&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-2</span>&gt;;</span><br><span class="line">      &#125; NewSessionTicket;</span><br></pre></td></tr></table></figure><p>其中ticket的值是从上一节提到的resumptition_master_secret中计算出来的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PskIdentity.identity = ticket </span><br><span class="line">                          = HKDF-Expand-Label(resumption_master_secret, <span class="string">&quot;resumption&quot;</span>, ticket_nonce, Hash.length)</span><br></pre></td></tr></table></figure><p>客户端接受到NewSessionTicket后会计算一个binder值，Truncate会取出ClientHello1中的binder_list，避免陷入无限循环。利用这个值来绑定上下文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PskBinderEntry = HMAC(binder_key, Transcript-Hash(Truncate(ClientHello1)))</span><br><span class="line">                   = HMAC(Derive-Secret(HKDF-Extract(<span class="number">0</span>, PSK), <span class="string">&quot;ext binder&quot;</span> | <span class="string">&quot;res binder&quot;</span>, <span class="string">&quot;&quot;</span>), Transcript-Hash(Truncate(ClientHello1)))</span><br><span class="line"></span><br><span class="line">其中binder_key = Derive-Secret(HKDF-Extract(<span class="number">0</span>, PSK), <span class="string">&quot;ext binder&quot;</span> | <span class="string">&quot;res binder&quot;</span>, <span class="string">&quot;&quot;</span>)                   </span><br></pre></td></tr></table></figure><p>然后Client在会话恢复时将identity和binder包含在ClientHello的拓展中发送给Server，Server再验证binder的完整性，比对identity，选择是否接受PSK，从而生成新的handshake_traffic和application密钥进行会话恢复。</p><p>可以看到如果仅仅是这样的会话恢复，相对于1.2来说只是更安全（因为不再使用master_secret做传递，而是利用HKDF派生），性能上没有大的提升，所以就会涉及到下面的0-RTT。</p><h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h3><p>对于TLS1.3还有一个很大的变化，那就是0-RTT模式。什么是0-RTT呢，就是基于PSK会话恢复时，PSK会作为Early Secret的IKM，然后从Early Secret生成client_early_traffic_secret，再由client_early_traffic_secret生成key和iv用来加密0-RTT发送的early_data。Client在ClientHello中携带early_data拓展选项，并发送由client_early_traffic_secret加密的数据，如果服务端接受early_data，那么就成功完成了0-RTT传输。</p><p>但是0-RTT为了效率降低了安全性，存在重放问题，因为在客户端发送early_data时，只有客户端参数决定，服务端没有参与到其中，那么中间人就可以截获这个ClientHello包以及加密数据，而服务端每次都能成功解析这个包，中间人就可以进行重放ddos或者重复敏感操作。除了这种最简单的重放，还有针对分布式系统的重放攻击，这里就不展开说了。</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>通过上面的分析，我们可以看出TLS具有极强的通用性与可拓展性，但是针对一些具体的使用场景能否进行特殊化的改造，这里我们以微信mmtls作为例子来分析下。我们回顾TLS的过程，身份认证的过程是采用建立PKI体系，做到全球的通用性，但是针对完全可控的微信程序，可以直接将签名的公钥预埋在客户端中，这样就不用建立或者申请证书，通过强制更新客户端，来做公钥的维护，这样就很大程度简略的流程并提升了效率。</p><p>还有针对0-RTT的问题，对于TLS1.3本身协议上来说是无解的，更多的只能从应用层来做缓解，例如cloudflare针对0-RTT将禁止非幂等的操作像POST，PUT，只允许不带参数的GET请求。mmtls也是根据这些应用行为，有选择性的使用0-RTT模式，例如只在端连接使用。chrome甚至选择不解决0-RTT重放，因为大部分浏览器的操作都是GET先，安全性交由其他方面来做。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个TLS完成了密码学上的安全，并结合了软件工程的理念，做到了分层抽象，模块化等等优秀的设计，在通用性上也确保了更多的场景能够被覆盖，提升了互联网的安全性，基本完成了它的设计目标。</p><p>当然作为使用者，当我们自己在设计（魔改）安全协议的时候，依然需要小心谨慎，密码学的快速发展已经让大部分程序员很难理解其原理，甚至正确使用密码学黑盒工具也是困难的，所以我们更需要的是怀着严谨的态度去使用密码学工具，紧跟主流，避免陷入闭门造车的困境。还有根据本身的应用场景我们是否能够吸取TLS的精华，结合自己的业务需求去做特质化，省略一些臃肿的包袱，做到定制优化都是可以考虑的。</p><p>TLS中的奥义远远不止我所阐述的，短短两篇文章也不能尽善尽美地描绘，希望能够对每一个读者有所帮助，更加有条理地理解其奥义。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tools.ietf.org/html/rfc5246">TLS1.2 RFC</a></li><li><a href="https://halfrost.com/">冰霜之地</a></li><li><a href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/">TLS协议分析 与 现代加密通信协议设计</a></li><li><a href="https://blog.shell909090.org/blog/archives/2873/">安全协议的设计</a></li><li><a href="https://cloud.tencent.com/developer/article/1005518">微信mmtls</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从TLS看安全协议设计（上）</title>
      <link href="2021/01/10/%E4%BB%8ETLS%E7%9C%8B%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>2021/01/10/%E4%BB%8ETLS%E7%9C%8B%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在开始正文前，我想先谈谈为什么要写这篇文章，为什么要对TLS协议进行分析？</p><p>打开网站时我们经常能看到左上角的小绿锁，而TLS正是隐藏在后面的原由。对于大部分程序员，多多少少都可以聊一聊TLS的几分样貌，但是能真正的从其整体发散到细节，从理念落地到实践，以更高的角度去理解TLS是很少的。因此这里想要从我个人的角度，去理清TLS，解读这个将密码科学和软件工程良好结合的优秀设计，也希望能够给读者有所帮助。</p><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><h3 id="为什么需要TLS"><a href="#为什么需要TLS" class="headerlink" title="为什么需要TLS?"></a>为什么需要TLS?</h3><p>在不存在SSL/TLS的互联网中，消息通过例如HTTP明文传递，作为一个攻击者可以截获任意的包，那么他就可以获取报文中的信息，并对报文进行修改，伪装成对端进行窃听或者控制传输。</p><p>在上文的描述中，我们可以看出明文传输存在的最显著问题：数据没有加密，消息易被篡改，身份能被伪造。这也对应着信息安全中的<strong>机密性</strong>，<strong>完整性</strong>，<strong>身份认证</strong>。</p><p>除了这三个最明显的问题，还有其他很多待解决的问题，例如如何确保用户不能抵赖之前发送的消息，即<strong>不可否认性</strong>；如何在设计时，降低所需的传输时间，提升<strong>性能</strong>；如何做到协议的<strong>通用性</strong>和<strong>可拓展性</strong>。这一系列的问题缺乏一个统一的解决方案，很多情况下仅是通过应用层的一些手段去不完善的处理，这些需求也就促成了SSL/TLS的诞生与发展。</p><p>围绕着这些需求，从90年代SSL1.0设计之初，一直走到了08年TLS1.2版本正式发布，整个协议才趋于成熟，又伴随着安全研究的升级对抗以及对性能提升的要求，1.3版本也在几年的商讨中于18年诞生。而这几年业界也是逐渐从1.2版本向1.3升级。当然因为历史遗留原因目前主流的还是1.2版本，因此我的分析也将从1.2版本开始，再迈向1.3，为读者浅析TLS的前世今生。</p><p><img src="http://image.bdwms.com/FvB5KJRP8BMLJtatrdl8yHLHZFKZ"></p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>在阅读这一部分时，可以不先完全理解其细节，在浏览后面章节必要时，再返回本章进行对照理解。</p><p>因为TLS是建立在密码学之上的协议，想要将TLS理解清楚，对密码学应有一定了解，但是具体深入密码学的细节不是本文重点所在，所以我简单归纳了几个需要了解的点和一些特性，实现细节的话请参看所给资料链接或自行搜索。</p><h3 id="密码学基本工具"><a href="#密码学基本工具" class="headerlink" title="密码学基本工具"></a>密码学基本工具</h3><ul><li>对称加密：加密和解密时使用同一密钥，常用有AES，(DES,RC4等都被证明不安全了)，然后还涉及到加密模式，例如流式加密（RC4使用的就是流式）,块加密模式（CBC等模式）。<strong>加解密效率高，密钥配送管理不便</strong>。</li><li>非对称加密：公私钥体系。常见的有RSA（基于大整数的质因数分解难题）和ECC（基于椭圆曲线上的离散对数难题）,以及DH（基于有限域上的离散对数难题），后两者在使用过程中类似一个协商，而RSA更类似一个单方面的加密传输过程。<strong>加解密效率低，密钥派发管理方便</strong>。</li><li>单向散列函数：输入消息不同，输出Hash值不同，保证消息的<strong>一致性</strong>，<strong>完整性</strong>。</li><li>消息认证码MAC：比单项散列函数多了个共享秘钥，保证消息的<strong>一致性</strong>，<strong>完整性</strong>，并且通过密钥加解密确保<strong>身份认证</strong>。但是因为使用的是共享秘钥不能“第三方证明”和“防抵赖”。</li><li>数字签名：利用私钥对hash值签名，公钥认证。保证消息的<strong>一致性</strong>，<strong>完整性</strong>，<strong>认证</strong>，并且能<strong>防止抵赖</strong>。</li><li>伪随机数生成器：模拟产生随机数列的算法。</li></ul><p>以上就是常用的密码学工具，在接下来的流程中会分别涉及到，如果对相关的工具有困惑可以自行查阅资料。</p><h3 id="RSA-ECC-DH"><a href="#RSA-ECC-DH" class="headerlink" title="RSA ECC DH"></a>RSA ECC DH</h3><p>这里想要对最常用的非对称加密算法做个简单的介绍，因为后面讲解时会利用到其特性。</p><p>对于常用的非对称加密算法，可以简单的分为两种类型，一种是基于RSA，一种是类DH（包括原生的DH和基于ECC的DH，即ECDH），简单来看一下两者的使用和区别。</p><ul><li><p>RSA</p><p>基于大整数进行质因数分解的困难，具体原理可以看阮一峰的<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">《RSA算法原理》</a>，这里说下使用方法：</p><p>存在一对公私钥：公钥(E,N)，私钥(D,N)，明文加密和密文解密类似下列的运算</p><p>密文 = 明文^E mod N   </p><p>明文 = 密文^D mod N  </p><p>使用的过程类似：</p><p>服务端下发公钥给客户端，客户端利用公钥加密一段会话数据后返回给服务端，服务端利用自己的私钥进行解密。</p><p><img src="http://image.bdwms.com/FgWFJLCGyoonFMeoZxHodhv6io3d"></p></li><li><p>DH（ECDH）</p><p>分为两种，一种是基于有限域上的离散对数问题，即DH类（Diffie-Hellman），具体原理自行搜索，这里只做口语化表达：</p><p><strong>已知x和G，求G^x mod p是简单的；反过来已知G^x mod p和G，求x是困难的。</strong></p><p>第二种是基于椭圆曲线上的离散对数问题，即ECDH类，口语化表达类似：</p><p><strong>已知x和G，求xG是简单的（椭圆曲线上的运算，不是简单的数乘）；反过来已知xG和G，求x是困难的。</strong></p><p>所以一般我们把x作为私钥，xG（G^x）为公钥</p><p>使用的过程类似：</p><p>服务端拥有私钥a，客户端拥有私钥b，第一次服务端发送公钥aG和参数G，客户端接受到后计算bG，发送给服务端，此时客户端拥有aG和b，服务端拥有bG和a，双方经过计算a(bG)=b(aG)=abG，得出相同的会话数据，但此时中间人只能截获aG，bG和G，无法求出abG，因为想要求出的话记必须通过aG和G（bG和G）计算出a（b），但是从上文的条件可以看出这是困难的，由此这就是DH类的原理。</p><p><img src="http://image.bdwms.com/FpcwsX8mQoxRoZVp1cPJ5bMnpTFv"></p></li></ul><p>我们通过以上的简介不难发现一点，两类算法最大的区别就是RSA做加密传输的时候，整个的会话数据是由客户端决定的，而服务端没有参与到生成的过程，更类似于一个<strong>加密传输</strong>的过程。而DH类客户端和服务端双方都需要参与到生成的过程中，单方面是无法决定会话数据的，也就是说相较于RSA，DH（ECDH）更类似一个<strong>密钥协商</strong>的过程。</p><p>针对上面的特性，也就衍生出下一个需要关注问题——前向安全，这也是为什么TLS1.3会抛弃RSA作为密钥协商的算法。</p><h3 id="前向安全"><a href="#前向安全" class="headerlink" title="前向安全"></a>前向安全</h3><p>官方定义是：长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。简单点来说就是我的长期持有的私钥泄漏了不会对之前的会话消息造成影响，那么对于上述两种算法，其又有什么不同呢？</p><p>显然，对于RSA来说，如果我们一直使用同一对公私钥，当私钥泄漏时，攻击者就可以轻易解密之前的会话消息，也就是说RSA时不具有前向安全的。不可能每次会话都更新RSA公私钥，因为每次更新下发公钥是不现实的，效率太低了，不可接受。</p><p>对于DH（ECDH），如果双方每次通话的私钥a，b都是固定的，那么生成的abG也是固定的，如果泄漏，也无法保证前向安全。但是我们可以通过每次会话时都利用随机数发生器生成临时的a和b（这个效率是可接受的），这样每次计算出来的结果都不一样，这就保证了前向安全，这也就是DHE和ECDHE，其中E表示的就是临时的意思。</p><p>基于上述拥有的密码学工具，以及相应的设计目的和需求，我们应该怎么设计呢，假如你是一个协议开发者，你如何协调使用好所拥有的能力，完成一个精巧的架构呢？让我们先来看看TLS是如何操作的，由全局到细节，由问题推方法，我们来细细品味。</p><h2 id="协议架构"><a href="#协议架构" class="headerlink" title="协议架构"></a>协议架构</h2><p>TLS1.2主要分为两个层级，上层的握手层（以及一些辅助协议，例如密钥切换通知，告警协议）和下层的记录层。</p><p><img src="http://image.bdwms.com/FrxN1tlsNbsfyfNbH4sQ9fZgAGwx"></p><p>首先为什么TLS会设计成分层架构呢？最主要的原因就是公钥加密算法和对称加密算法的优劣性。当使用对称密钥的方式进行加密时，双方持有相同密钥，根据选定算法对信息加密，然后传输给对端进行解密。整个加解密的过程建立在双方持有相同的密钥，但是对于互联网多方交互的环境下，是不可能做到服务端与每个客户端直接持有一个对称密钥的，无论是维护密钥的成本，还是密钥派发时的安全保证，都是不可接受的。</p><p>因此为了解决密钥的派发管理问题，一般是采用公钥加密的方式，服务端将公钥派发出去，客户端利用公钥加密信息后返回给服务端，服务端再用自己的私钥进行解密。但是在真正设计时并没有选择完全使用两端采用公钥加密的方式进行加密沟通，因为公钥加解密的速度是非常慢的。</p><p>综合以上两点，TLS分为两层，握手层采用公钥加密的方式协商一段数据作为加密素材，传递给记录层做为对称加密的密钥材料，记录层生成对称密钥加密应用数据，既解决了密钥管理的问题，也保证了效率。同时这也有利于解耦各种需求，并化简整个问题的复杂度，将TLS分层模块化，每一部分完成一定的需求，并让之后的升级更新更加方便。</p><h2 id="推演思路"><a href="#推演思路" class="headerlink" title="推演思路"></a>推演思路</h2><p>了解了TLS最基本的架构后我们按照握手层和记录层的顺序进行推理分析，由需求得出方案，再根据连贯的问题，补充完善之前的方案。</p><h3 id="握手层"><a href="#握手层" class="headerlink" title="握手层"></a>握手层</h3><p>先从握手从来看，对于握手层，需要完成的最基本需求是利用非对称加密完成“材料”数据的传输，如客户端C向服务端S发送会话请求，服务端同意后下发自己的公钥S_Pub，客户端利用公钥加密数据Data传输给服务端，服务端利用自己的私钥S_Pri解密，得到数据。</p><p>但是以上步骤存在一个问题就是假设存在一个可以截取数据的中间人，是无法保证对端身份可信的。例如下图中间人M截获S_Pub，替换为自己的公钥M_Pub，客户端使用M_Pub作为公钥加密后发送数据，中间人能用自己的M_Pri解密并修改数据，再用S_Pub加密后发送给服务端，从而造成中间人攻击。</p><p><img src="http://image.bdwms.com/FvHsGjuxiuWLnIXz04eK4pLkoOm4"></p><p>之所以产生这个问题是因为缺乏身份认证，解决身份认证问题一般是利用消息认证码MAC或数字签名。对于消息认证码需要对称密钥，此时还不存在所以选用数字签名进行认证。假设数字签名的公私钥对位Sign_Pub和Sign_Pri，利用Sign_Pri对S_Pub进行数字签名，客户端利用Sign_Pub对数字签名进行认证（中间人是无法阻止客户端获取到Sign_Pub的）。</p><p>但是又如何确保数字签名的公钥是可信的呢？TLS给出的方案就是PKI证书体系，建立可信第三方CA，然后在客户端预装可信CA的公钥（存在一个证书链体系，不是只有一个CA）。服务端通过下发证书，客户端通过预装公钥验证证书签名以及一些其他信息，确认了服务端身份，这样就能解决身份认证的问题并且保证了服务器公钥的完整性。TLS还支持双向认证，即服务端请求验证客户端身份，但一般只需要验证一方就可以解决中间人问题了。</p><p>记录层会通过握手层传输过来的数据Data生成用于加密应用数据的对称密钥，在此之前为了保证刚刚握手的完整性，还需要做消息校验并用协商生成的对称密钥加密，作为双方第一个对称加密的包。通过这个消息就能验证协商出的对称密钥是否正确，以及之前握手消息没有被篡改。之后记录层就可以正式加密传输应用数据了。</p><p>完成这样一次会话过程后，我们还需要思考一个问题：每次会话都需要重新生成新的密钥，这样是否很浪费，我们是否能复用之前的密钥。由此TLS产生了会话恢复机制，包括使用Session_id和Session_ticket两种手段。</p><p>以上就是从我个人理解的角度，观察TLS握手层一步一步的设计缘由，当然这其中隐藏了很多具体的实现细节，比如每一步的密钥是如何生成的，应该如何使用，如何减少私钥泄漏后的影响，为什么会话恢复有两种模式等等很多有意思的问题，在接下的分析中我会挑选一些我认为比较重要的进行解析。</p><p>总结下以上步骤，整体思路如下图：</p><p><img src="http://image.bdwms.com/FgkGgBr3d1jnp_3ycicaEH7BkSCB"></p><h3 id="记录层"><a href="#记录层" class="headerlink" title="记录层"></a>记录层</h3><p>对于记录层步骤主要为分段，压缩（可选，因为存在安全问题一般不开启），加密和消息认证MAC（存在三种模式，stream ,block,aead）,添加消息头。在这一层会利用握手层传输的密钥材料，生成对称密钥，MAC密钥等必备参数。完成对数据的对称加密和生成消息认证码（AEAD模式将两者结合起来了），这就是这一层做的最主要的事情。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="握手层冷启动"><a href="#握手层冷启动" class="headerlink" title="握手层冷启动"></a>握手层冷启动</h3><p>通过上面的推演，我们大致了解了每一层的目的以及大致的步骤，这里我们来看一下具体的实现。</p><p>对于第一次冷启动的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">ClientHello                  --------&gt;</span><br><span class="line">                                                ServerHello</span><br><span class="line">                                               Certificate*</span><br><span class="line">                                         ServerKeyExchange*</span><br><span class="line">                                        CertificateRequest*</span><br><span class="line">                             &lt;--------      ServerHelloDone</span><br><span class="line">Certificate*</span><br><span class="line">ClientKeyExchange</span><br><span class="line">CertificateVerify*</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                     --------&gt;</span><br><span class="line">                                         [ChangeCipherSpec]</span><br><span class="line">                             &lt;--------             Finished</span><br><span class="line">Application Data             &lt;-------&gt;     Application Data</span><br><span class="line">*表示可选发送</span><br><span class="line">[]表示独立消息，这里为了防阻塞单独通知密钥协议已切换，有冗余在<span class="number">1.3</span>中删除</span><br></pre></td></tr></table></figure><ol><li>客户端发送ClientHello携带自己支持的加密组件以及随机值，服务端收到后选择支持的加密组件并携带服务端随机值返回一个ServerHello消息。</li><li>之后服务端发送Certifacate消息，包含证书信息，以及当Certificate信息不足时，发送ServerKeyExchange消息包含补充信息。</li><li>因为TLS支持双向认证，如果服务端需要对客户端身份进行认证的话，就会发送CertifacateRequest消息。</li><li>服务端发送ServerHelloDone表明自己已经发送完成。</li><li>当客户端收到CertificateRequest请求后，如果支持认证就发送Certificate消息包含自己的证书。如果没有收到验证请求，就不发送此条消息。</li><li>客户端发送ClientKeyExchange，交换密钥材料。例如使用RSA，就会生成由46字节的随机值和2字节的版本号组成的Pre_master_secret，使用服务端公钥加密后，在本条消息包含发送。</li><li>如果客户端发送了Certificate消息，就需要发送一条CertificateVerify消息来对之前的握手做Hash并用自己的证书私钥进行签名，表明自己确实拥有客户端证书私钥以验证身份，并保证了之前握手消息未被篡改。</li><li>之后会发送ChangeCipherSpec通知对端已经切换密钥了（为了防阻塞不在本消息流中）</li><li>客户端发送Finished消息，通过结合之前握手消息的Hash，Master_secret等生成验证数据，并利用协商出来的Session_key加密传输给对端。Finished消息是第一条使用协商出来的对称密钥加密的消息，通过这条消息验证了密钥的正确性以及之前握手消息未被篡改。</li><li>同样服务端也发送Finished消息，注意在做Hash时的握手消息包含上条客户端发送的Finished消息。</li><li>双方通过握手以及密钥派生计算已经拥有了相同的Session_key，可以进行正式的应用数据加密传输了。</li></ol><h3 id="握手层热启动"><a href="#握手层热启动" class="headerlink" title="握手层热启动"></a>握手层热启动</h3><p>分为Session_id和Session_ticket两种。第一种使用Session_id，发送ClientHello时会客户端会携带会话唯一标示，服务端同意后发送ServerHello以及Finished，根据保存的主密钥Master_secrert等信息以及新的随机值重新计算会话密钥来进行应用数据加密。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Client                                                Server</span><br><span class="line"></span><br><span class="line">ClientHello                   --------&gt;</span><br><span class="line">                                                 ServerHello</span><br><span class="line">                                          [ChangeCipherSpec]</span><br><span class="line">                              &lt;--------             Finished</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                      --------&gt;</span><br><span class="line">Application Data              &lt;-------&gt;     Application Data</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>但是因为存在分布式Session同步以及存储性能的限制，一般选用下面的Session_ticket手段，这十分类似HTTP中的Cookie和Session机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">第一次：</span><br><span class="line">   ClientHello</span><br><span class="line">   (empty SessionTicket extension)--------&gt;</span><br><span class="line">                                                   ServerHello</span><br><span class="line">                                (empty SessionTicket extension)</span><br><span class="line">                                                  Certificate*</span><br><span class="line">                                            ServerKeyExchange*</span><br><span class="line">                                           CertificateRequest*</span><br><span class="line">                                &lt;--------      ServerHelloDone</span><br><span class="line">   Certificate*</span><br><span class="line">   ClientKeyExchange</span><br><span class="line">   CertificateVerify*</span><br><span class="line">   [ChangeCipherSpec]</span><br><span class="line">   Finished                     --------&gt;</span><br><span class="line">            NewSessionTicket</span><br><span class="line">                                            [ChangeCipherSpec]</span><br><span class="line">                                &lt;--------             Finished</span><br><span class="line">   Application Data             &lt;-------&gt;     Application Data</span><br><span class="line">第二次：</span><br><span class="line">   ClientHello</span><br><span class="line">   (SessionTicket extension)     --------&gt;</span><br><span class="line">                                                    ServerHello</span><br><span class="line">                                 (empty SessionTicket extension)</span><br><span class="line">                                               NewSessionTicket</span><br><span class="line">                                             [ChangeCipherSpec]</span><br><span class="line">                                 &lt;--------             Finished</span><br><span class="line">   [ChangeCipherSpec]</span><br><span class="line">   Finished                      --------&gt;</span><br><span class="line">   Application Data              &lt;-------&gt;     Application Data</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>可以看到在第一次中服务端会发送一个NewSessionTicket消息，将会话信息加密并MAC在其中，客户端在第二次中携带ticket，服务端成功解密并验证完整性后，如果同意就会直接省略密钥协商的过程，从而节省了传输时间。</p><h3 id="记录层-1"><a href="#记录层-1" class="headerlink" title="记录层"></a>记录层</h3><p>从握手层得到数据如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ConnectionEnd          entity;</span><br><span class="line">    PRFAlgorithm           prf_algorithm;</span><br><span class="line">    BulkCipherAlgorithm    bulk_cipher_algorithm;</span><br><span class="line">    CipherType             cipher_type;</span><br><span class="line">    uint8                  enc_key_length;</span><br><span class="line">    uint8                  block_length;</span><br><span class="line">    uint8                  fixed_iv_length;</span><br><span class="line">    uint8                  record_iv_length;</span><br><span class="line">    MACAlgorithm           mac_algorithm;  <span class="comment">/*mac 算法*/</span></span><br><span class="line">    uint8                  mac_length;     <span class="comment">/*mac 值的长度*/</span></span><br><span class="line">    uint8                  mac_key_length; <span class="comment">/*mac 算法密钥的长度*/</span></span><br><span class="line">    CompressionMethod      compression_algorithm;</span><br><span class="line">    opaque                 master_secret[<span class="number">48</span>];</span><br><span class="line">    opaque                 client_random[<span class="number">32</span>];</span><br><span class="line">    opaque                 server_random[<span class="number">32</span>];</span><br><span class="line">&#125; SecurityParameters;</span><br></pre></td></tr></table></figure><p>利用PRF密钥派生函数生成以下数据用来加密和MAC。同时因为根据密码学的研究，客户端写/服务端读，服务端写/客户端读，这两种流向是不能使用同一个会话密钥的，会产生安全问题，所以生成两组write key。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client write MAC key*</span><br><span class="line">server write MAC key*</span><br><span class="line">client write encryption key</span><br><span class="line">server write encryption key</span><br><span class="line">client write IV</span><br><span class="line">server write IV</span><br><span class="line">*表示可选，AEAD模式无需MAC</span><br></pre></td></tr></table></figure><p>记录层的流程为数据分段，压缩（可选，因为存在安全问题一般禁用），加密和完整性保护，添加消息头。</p><p>我们这里重点关注加密和完整性保护。在密码学中存在三种加密和MAC的组合方式。</p><ul><li>Encrypt-and-MAC：明文加密和明文MAC拼接在一起。</li><li>MAC-then-Encrypt：对明文MAC后拼接在明文后，对整个进行加密。</li><li>Encrypt-then-MAC：对明文加密后在对密文MAC，将MAC内容拼接在密文后。</li></ul><p>TLS中采用的是第二种，但是随着发展发现了很多问题，例如Padding Oracle漏洞等。对于具体的做法又分为块模式+Hmac，流模式+Hmac，以及AEAD模式。块和流模式采用的是MAC then encrypt，之后为了从密码学上直接解决这个问题，密码学专家便提出了将加密和完整性保护融合在一个算法中即AEAD，彻底解决以上问题，因此更推荐使用AEAD模式例如aes-256-gcm。</p><h3 id="密钥派生函数与密钥变化"><a href="#密钥派生函数与密钥变化" class="headerlink" title="密钥派生函数与密钥变化"></a>密钥派生函数与密钥变化</h3><p>以上就是1.2的基本流程，针对密钥这一块需要单独强调一下。</p><p>我们先看下PRF函数，它通过输入的材料可以通过递归的Hash生成无限长的随机输出，我们可以截取任意长度作为我们的产出需求，看一下具体的表现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> P_hash(secret, seed) = HMAC_hash(secret, A(<span class="number">1</span>) + seed) +</span><br><span class="line">                           HMAC_hash(secret, A(<span class="number">2</span>) + seed) +</span><br><span class="line">                           HMAC_hash(secret, A(<span class="number">3</span>) + seed) + ...</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">A(<span class="number">0</span>) = seed</span><br><span class="line">A(i) = HMAC_hash(secret, A(i<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><p>因此在TLS中的表现形式就为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRF(secret, label, seed) = P_&lt;hash&gt;(secret, label + seed)</span><br></pre></td></tr></table></figure><p>我们有了这样一个派生密钥的工具后，我们在来看下具体的密钥变化。在整个过程中主要涉及三个密钥：</p><p><code>Premaster_secret -&gt; Master_secret -&gt; Session_key</code></p><p>其中Premaster_secret是在握手交换时完成的，采用不同的密钥协商算法会有不同变化，如下：</p><ul><li>RSA：客户端生成随机值作为Premaster_secret。</li><li>静态DH，ECDH：服务端公钥包含在证书中，客户端看是否包含在证书，不在的话就用ClientKeyExchange中，通过计算得出Premaster_secret。</li><li>动态DHE，ECDHE：公钥分别由服务端ServerKeyExchange，客户端ClientKeyExchange消息中，并计算得出Premaster_secret.</li></ul><p>之后使用Premaster_seceret通过PRF函数生成48字节的Master_secret</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master_secret = PRF(pre_master_secret, <span class="string">&quot;master secret&quot;</span>,</span><br><span class="line">                            ClientHello.random + ServerHello.random)</span><br><span class="line">                            [<span class="number">0.</span><span class="number">.47</span>];</span><br></pre></td></tr></table></figure><p>Master_secret才是真正传递给记录层的，之后记录层利用Master_secret生成Session_key，然后切分为对称密钥，IV，MAC密钥来处理真正的应用数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key_block = PRF(SecurityParameters.master_secret,</span><br><span class="line">                <span class="string">&quot;key expansion&quot;</span>,</span><br><span class="line">                SecurityParameters.server_random +</span><br><span class="line">                SecurityParameters.client_random);</span><br></pre></td></tr></table></figure><p>这些变化的理由，我个人思考如下：</p><ul><li><p>为什么不直接使用Premaster_secret生成Session_key呢？</p><p>因为Premaster_secret的格式不同,RSA是48位，ECC类基于具体算法，我们想要得到固定格式的熵源，所以利用PRF函数计算出Master_secret，并且保证secret的随机性不仅仅受单一方影响，比如rsa做秘钥交换时仅仅是客户端发送48字节的值</p></li><li><p>为什么不直接使用Master_secret加密呢？</p><p>长度不够；利用主密钥生成会话密钥会让攻击者进行计算破解难度更大</p></li></ul><p>更多问题限于篇幅请看我之前的文章：<a href="https://www.bdwms.com/?p=946">TLS相关FAQ</a></p><h2 id="回顾与展望"><a href="#回顾与展望" class="headerlink" title="回顾与展望"></a>回顾与展望</h2><p>说到这里，我们暂停一下我们的脚步，首先来回顾一下TLS1.2是怎么完成它开始的设计目标的。</p><ul><li>机密性：非对称和对称加密的结合使用。</li><li>身份认证：证书体系的建立。</li><li>完整性保护：握手阶段的CertificateVerify，Finished消息做校验，记录层对消息做MAC。</li><li>性能：基于Session的会话恢复机制。</li><li>通用性：凡是基于RFC文档实现的，理论上上都是可以做到多种设备的兼容，并且采用的证书体系也是全球通用的。</li><li>可拓展性：在握手的会话中支持插件机制。</li></ul><p>除了以上特性TLS在其他种种方面也是做到基本可用成型，做到了对网络传输安全的保障。当然，这些年来随之密码学的研究深入，以及技术迭代的发展，由此产生了更高的要求，TLS1.2在一些方面已经不能满足业界了，我们简单看下它的主要问题在哪：</p><ul><li>不安全的密码组件，模式和配置。例如RC4,MD5等一种算法被破解，块加密，流加密模式的不安全因素。</li><li>伴随着斯诺登泄密事件，前向安全性更加被重视。</li><li>1.2冷启动至少需要2RTT，热启动需要1RTT，对于很多短链接的场景下，耗时过长是不可接受的。</li></ul><p>为了改善这些问题，1.3版本做了巨大的改变，甚至一定程度上放弃了前向兼容来保证架构的重新调整，让我们在一篇文章中看下TLS1.3究竟有何神奇之处。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来准备一篇文章写完整个TLS1.2和1.3的，但是发现就算省略了很多细节，仅仅是1.2也已经6000多字了，决定还是分上下两篇，方便读者阅读。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tools.ietf.org/html/rfc5246">TLS1.2 RFC</a></li><li><a href="https://halfrost.com/">冰霜之地</a></li><li><a href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/">TLS协议分析 与 现代加密通信协议设计</a></li><li><a href="https://blog.shell909090.org/blog/archives/2873/">安全协议的设计</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>再起航，2021</title>
      <link href="2021/01/09/%E5%86%8D%E8%B5%B7%E8%88%AA%EF%BC%8C2021/"/>
      <url>2021/01/09/%E5%86%8D%E8%B5%B7%E8%88%AA%EF%BC%8C2021/</url>
      
        <content type="html"><![CDATA[<p>2021起始，告别了我的旧博客，来到了我的新家。</p><p>Hello, World!</p><h2 id="告别过去"><a href="#告别过去" class="headerlink" title="告别过去"></a>告别过去</h2><h3 id="为什么要更换博客"><a href="#为什么要更换博客" class="headerlink" title="为什么要更换博客"></a>为什么要更换博客</h3><ul><li>Wordpress对markdown原生支持不好，尝试了n种插件后发现兼容性或者效果展示也不尽人意。</li><li>旧博客采用的是宝塔+Wordpress+Cloudflare，外加上各种插件，较容易存在安全问题，频繁升级维护很麻烦。</li><li>回望过去两年多来，陆陆续续写了130多篇的博客，但是其质量限于本人的水平，以及写作时较为随意，导致整体的质量不高。并且随着我的大学时光即将结束，慢慢进入社畜的节奏，无法维持高频度的更新，由此想要更加精炼自己的文章。所以最终决定抛下旧包袱，开启新的篇章。</li></ul><h3 id="方案分析选择"><a href="#方案分析选择" class="headerlink" title="方案分析选择"></a>方案分析选择</h3><p>既然决定了要更换博客，那么肯定就要进行好好分析，分为两个部分，一个是新博客如何选择，旧博客如何处理，经过我的尝试，最后完成了本次更新升级。</p><ul><li><p>旧博客：</p><p>一开始的想法是做二级域名，将旧博客指向二级域名，例如backup.bdwms.com。方法很简单，因为我的域名统一托管在cloudflare，只要添加个二级域名的A记录就行了，但是此时就存在两个问题了。</p><p>一个是免费的SSL证书只能是单域名，通配符的证书都要钱，所以就需要给二级域名单独申请一张证书。</p><p>二就是我发现更改完二级域名后，整个Wordpress的链接指向都乱了，分析和搜索了下需要甚至需要手动改数据库，这个操作很危险，考虑我放弃了这个方案，最终选择保留旧博客的域名，重新申请个域名。</p></li><li><p>新博客：</p><p>选择Hexo，优秀地支持markdown，安装和维护简单，作为黑色爱好者选择了极简的主题<a href="https://github.com/probberechts/hexo-theme-cactus">Cactus</a>，也是因为之前看到P牛的博客。</p></li></ul><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h3><p>官网安装npm，hexo，网上文章太多了不多赘述。然后就是配置主题Cactus，进行了一些魔改，评论系统选择了Disqus（需要科学上网）。</p><p>在部署的时候，出现一个选择，一个很简单的方法是直接在Github中配置个[username].github.io，然后在_config.yml中配置deploy的repository，再将自己的新买的域名解析到[username].github.io，再在仓库的settings配置下域名就可以替换域名了。</p><p>但是这样的话不够优雅，每次都需要</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>并且存在一个备份和同步问题，我要是换了电脑怎么复原，以及怎么在不同电脑上写呢。我研究了网上的方法，很多说在仓库里面新开一个branch，但是这样的话很多配置魔改的文件都会公开，遂放弃。</p><h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><p>最后经过研究参考部署的方便，以及备份和同步，选择了Github提供的Action来做自动部署，优化使用流程只需要push代码就可以自动部署，并且将自己的源代码单独放在一个私有库，生成文件在公开库，同时将魔改后的主题文件单独放在一个库中。具体流程如下：</p><ol><li><p>生成三个库，一个私有库放BlogSource源代码，一个公共库Themes放魔改的主题，一个公共库[username].github.io放真正的生成文件。然后进行生成密钥对，私钥放<code>Settings -&gt; Secrets -&gt; Add a new secret</code>，命名<code>HEXO_DEPLOY_PRI</code>,公钥放github.io的公钥库<code>Settings -&gt; Deploy keys -&gt; Add deploy key</code>，命名<code>HEXO_DEPLOY_PUB</code>，开启<code>Allow write access</code></p></li><li><p>因为我clone后魔改的主题也想要进行管理，所以将其推到Themes库，注意这里push的时候将主题的_config.yml改名放在博客根目录中，不能传到公共库中，在博客根目录生成git后，与主题的git冲突，于是选择使用submodule方式，进行分离管理，命令类似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add [themes_url] themes/cactus</span><br></pre></td></tr></table></figure><p>然后为了能够保证CNAME不被每次覆盖，在source文件下放一个CNAME文件，里面写要CNAME的域名，push源代码到远端。</p></li><li><p>最后也是最重要的生成CI/CD文件，在私有库的Action中选择生成一个Workflow，配置文件例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">GIT_USER:</span> <span class="string">user.name</span></span><br><span class="line">  <span class="attr">GIT_EMAIL:</span> <span class="string">user.email</span></span><br><span class="line">  <span class="attr">THEME_REPO:</span> <span class="string">birdmanwings/cactus-modify</span></span><br><span class="line">  <span class="attr">THEME_BRANCH:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">DEPLOY_REPO:</span> <span class="string">birdmanwings/birdmanwings.github.io</span></span><br><span class="line">  <span class="attr">DEPLOY_BRANCH:</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span> <span class="string">on</span> <span class="string">node</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span> <span class="string">and</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.os</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">os:</span> [<span class="string">ubuntu-latest</span>]</span><br><span class="line">        <span class="attr">node_version:</span> [<span class="number">14.</span><span class="string">x</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">theme</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">themes/cactus</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">deploy</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.DEPLOY_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.DEPLOY_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">.deploy_git</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configuration</span> <span class="string">environment</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">HEXO_DEPLOY_PRI:</span> <span class="string">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">sudo</span> <span class="string">timedatectl</span> <span class="string">set-timezone</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;$HEXO_DEPLOY_PRI&quot;</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">$GIT_USER</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">$GIT_EMAIL</span></span><br><span class="line">          <span class="string">cp</span> <span class="string">_config.theme.yml</span> <span class="string">themes/cactus/_config.yml</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">run</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>需要更改下名字，邮箱，主题地址，分支名称，然后commit就可以了，这里注意主题config，密钥对名称是否正确，之后本地pull下同步下代码，写一个文章push上去后能够发现成功自动部署。</p></li></ol><p>可以看下最后的项目结构类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy_git</span><br><span class="line">├── .git</span><br><span class="line">├── .github</span><br><span class="line">│   └── workflows</span><br><span class="line">│       ├── main.yml</span><br><span class="line">├── _config.landscape.yml</span><br><span class="line">├── _config.theme.yml</span><br><span class="line">├── _config.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── source</span><br><span class="line">│   ├── CNAME</span><br><span class="line">│   ├── _posts</span><br><span class="line">│   │   ├── Hello,World.md</span><br><span class="line">│   ├── about</span><br><span class="line">│   │   └── index.md</span><br><span class="line">│   ├── categories</span><br><span class="line">│   │   ├── index.md</span><br><span class="line">│   └── search</span><br><span class="line">│       ├── index.md</span><br><span class="line">└── themes</span><br><span class="line">    └── cactus</span><br><span class="line">        ├── LICENSE</span><br><span class="line">        ├── README.md</span><br><span class="line">        ├── gulpfile.js</span><br><span class="line">        ├── languages</span><br><span class="line">        ├── layout</span><br><span class="line">        ├── package.json</span><br><span class="line">        ├── scripts</span><br><span class="line">        └── source</span><br></pre></td></tr></table></figure><h3 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h3><p>如何备份恢复呢，先配好git，npm，hexo，然后clone recurvise自己的源代码下来，<code>npm install</code>安装下依赖，然后就可以写文章push自动部署了，跟我们平常做项目管理没有什么区别了。</p><h3 id="阿里云CDN加速"><a href="#阿里云CDN加速" class="headerlink" title="阿里云CDN加速"></a>阿里云CDN加速</h3><p>之后为了国内访问的速度，想想还是用下CDN加速，不过需要备案，过几天我来搞定。</p><h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>下一个十年，</p><p>想做一个懂业务的安全人，</p><p>想做一个有思考的技术人，</p><p>想做一个明白爱的成年人，</p><p>再起航，2021～</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/87053283">Git中submodule的使用</a></p></li><li><p><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">利用 Github Actions 自动部署 Hexo 博客</a></p></li><li><p><a href="https://www.sev7e0.site/2020/02/28/page%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91cdn%E8%BF%9B%E8%A1%8C%E5%85%A8%E7%AB%99%E5%8A%A0%E9%80%9F%E6%8C%87%E5%8C%97/">博客使用阿里云cdn进行全站加速指北</a></p></li><li><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-5">超详细Hexo+Github博客搭建小白教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
